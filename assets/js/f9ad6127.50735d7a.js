"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[42593],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var o=t(96540);const s={},i=o.createContext(s);function r(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:n},e.children)}},53248:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>o,toc:()=>h});const o=JSON.parse('{"id":"intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-2-4-es6-arrow-notation","title":"\ud83d\udcd3 2.2.2.4 ES6 Arrow Notation","description":"Arrow functions are one of the most popular and useful new features in ES6. In fact, we\'ve already been using arrow functions with Jest. Now it\'s time to delve more deeply into why they are useful and how we can use them in our code. There are a few reasons why arrow functions are so popular. We\'ll be focusing primarily on one of these reasons: arrow functions change the way this is bound inside of a nested function.","source":"@site/docs/2_intermediate-javascript/2_test-driven-development-and-environments-with-javascript/2-2-2-04-es6-arrow-notation.md","sourceDirName":"2_intermediate-javascript/2_test-driven-development-and-environments-with-javascript","slug":"/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-2-4-es6-arrow-notation","permalink":"/v1.2/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-2-4-es6-arrow-notation","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 2.2.2.4 ES6 Arrow Notation","day":"tuesday","id":"2-2-2-4-es6-arrow-notation","hide_table_of_contents":true},"sidebar":"intermediate-javascript","previous":{"title":"\ud83d\udcd3 2.2.2.3 ES6 Classes","permalink":"/v1.2/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-2-3-es6-classes"},"next":{"title":"\ud83d\udcd3 2.2.2.5 ES6 Template Literals","permalink":"/v1.2/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-2-5-es6-template-literals"}}');var s=t(74848),i=t(28453);const r={title:"\ud83d\udcd3 2.2.2.4 ES6 Arrow Notation",day:"tuesday",id:"2-2-2-4-es6-arrow-notation",hide_table_of_contents:!0},a=void 0,c={},h=[{value:"Arrow Functions and <code>this</code>",id:"arrow-functions-and-this",level:2},{value:"When to Use Arrow Functions",id:"when-to-use-arrow-functions",level:3},{value:"More Arrow Function Examples",id:"more-arrow-function-examples",level:3},{value:"Unnamed Functions",id:"unnamed-functions",level:4},{value:"Named Functions",id:"named-functions",level:4},{value:"Syntactic Sugar for Arrow Notation",id:"syntactic-sugar-for-arrow-notation",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Arrow functions are one of the most popular and useful new features in ES6. In fact, we've already been using arrow functions with Jest. Now it's time to delve more deeply into why they are useful and how we can use them in our code. There are a few reasons why arrow functions are so popular. We'll be focusing primarily on one of these reasons: arrow functions change the way ",(0,s.jsx)(n.code,{children:"this"})," is bound inside of a nested function."]}),"\n",(0,s.jsxs)(n.h2,{id:"arrow-functions-and-this",children:["Arrow Functions and ",(0,s.jsx)(n.code,{children:"this"})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["The value of ",(0,s.jsx)(n.code,{children:"this"})," changes based on where we are calling it in our code, but it always represents the object inside of which our code is executing. ",(0,s.jsx)(n.code,{children:"this"})," can be a very confusing topic in JavaScript, especially for beginners, and it's not always clear what ",(0,s.jsx)(n.code,{children:"this"})," is bound to \u2014 meaning, what object ",(0,s.jsx)(n.code,{children:"this"})," actually represents. You may have dealt with this issue in Introduction to Programming; it's very common (and frustrating) for new developers to try to use ",(0,s.jsx)(n.code,{children:"this"}),", only to find that it's ",(0,s.jsx)(n.code,{children:"undefined"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The best way to simplify ",(0,s.jsx)(n.code,{children:"this"})," is to think of it within the context of object-oriented programming. Specifically, we should probably only use ",(0,s.jsx)(n.code,{children:"this"})," if we're calling a function on a specific object."]}),"\n",(0,s.jsx)(n.p,{children:"In fact, this is what we commonly do inside of classes. (If classes still feel like a weird new concept, you can also think of this as being similar to what we've done with prototype methods in the past.)"}),"\n",(0,s.jsxs)(n.p,{children:["Let's look at some code that isn't going to work as expected. The reason, as you might guess, is related to ",(0,s.jsx)(n.code,{children:"this"}),". Go ahead and put the following code in the DevTools console:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class Box {\n\n  constructor() {\n    this.stuff = [];\n  }\n\n  addJunk(array) {\n    console.log(this);\n    array.forEach(function(thing) {\n      this.stuff.push(thing);\n    });\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, we create a ",(0,s.jsx)(n.code,{children:"Box"})," class. It has one property: ",(0,s.jsx)(n.code,{children:"this.stuff"}),", an empty array."]}),"\n",(0,s.jsxs)(n.p,{children:["Next, we have a prototype method ",(0,s.jsx)(n.code,{children:"Box.prototype.addJunk(array)"}),", but written using ",(0,s.jsx)(n.code,{children:"class"})," syntax. It seems like a straightforward method \u2014 we pass in an array and then for each element in the array, we push that element into ",(0,s.jsx)(n.code,{children:"this.stuff"}),", the property of our ",(0,s.jsx)(n.code,{children:"Box"})," object."]}),"\n",(0,s.jsxs)(n.p,{children:["Well, if we try it in the console, we'll see that ",(0,s.jsx)(n.code,{children:"Box.prototype.addJunk(array)"})," doesn't work correctly. Add this code in the console:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'> let box = new Box();\n> box.addJunk(["broken pencils", "busted rubber bands", "checkers pieces"]);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We'll get the following ",(0,s.jsx)(n.code,{children:"console.log()"})," message:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"Box\xa0{stuff: Array(0)}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This ",(0,s.jsx)(n.code,{children:"console.log()"})," message confirms that ",(0,s.jsx)(n.code,{children:"this"})," is set to our ",(0,s.jsx)(n.code,{children:"Box"})," object, which before the loop to add the new Junk has nothing in the ",(0,s.jsx)(n.code,{children:"stuff"})," property. This is what we expect to see."]}),"\n",(0,s.jsx)(n.p,{children:"However, we'll also get the following error:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"Uncaught TypeError: Cannot read property 'stuff' of undefined\n"})}),"\n",(0,s.jsxs)(n.p,{children:["What just happened? When our code tried to read ",(0,s.jsx)(n.code,{children:"this.stuff"})," inside the loop, it threw an error because ",(0,s.jsx)(n.code,{children:"this"})," is ",(0,s.jsx)(n.code,{children:"undefined"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["And why would that happen? We just used a ",(0,s.jsx)(n.code,{children:"console.log(this);"})," to verify that ",(0,s.jsx)(n.code,{children:"this"})," is exactly what we thought it was, the ",(0,s.jsx)(n.code,{children:"Box"})," object."]}),"\n",(0,s.jsxs)(n.p,{children:["However, we used ",(0,s.jsx)(n.code,{children:"console.log(this)"})," ",(0,s.jsx)(n.em,{children:"outside"})," of the loop. This is a weird thing about JavaScript. We entered a loop and ",(0,s.jsx)(n.code,{children:"this"})," lost its scope. What gives? Well, in JavaScript, every time a function is created, so too is a new scope. So, it's not that we've entered a loop that's causing ",(0,s.jsx)(n.code,{children:"this"})," to be undefined, it's because we're calling ",(0,s.jsx)(n.code,{children:"this"})," within the callback function (with the new scope!) that we pass into ",(0,s.jsx)(n.code,{children:"Array.prototype.forEach()"}),". The problem with the scope of the callback function is that it's not tied to any object, so ",(0,s.jsx)(n.code,{children:"this"})," ends up being ",(0,s.jsx)(n.code,{children:"undefined"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["To reiterate this and see the value of ",(0,s.jsx)(n.code,{children:"this"})," in the context of our ",(0,s.jsx)(n.code,{children:"Box"})," object, we've added commentary and a few additional ",(0,s.jsx)(n.code,{children:"console.log()"})," statements that describe what ",(0,s.jsx)(n.code,{children:"this"})," represents at every level of our script. You can read through the following commentary, or copy and paste the following code into your DevTools console to try it out. The last message you'll see is the same as before: a TypeError about ",(0,s.jsx)(n.code,{children:"this"})," being ",(0,s.jsx)(n.code,{children:"undefined"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// \'this\' is set to JavaScript global object, which\n// is the window object when run in the browser\nconsole.log("this at the top level of our script", this);\n\nclass Box {\n\n  constructor() {\n    // \'this\' is the Box object\n    console.log("this in the constructor", this);\n    this.stuff = [];\n  }\n\n  addJunk(array) {\n    // \'this\' is the Box object\n    console.log("this in addJunk method", this);\n\n    array.forEach(function(thing) {\n      // \'this\' is undefined, because \n      // the callback function does not belong to \n      // any object type\n      console.log("this in addJunk\'s forEach loop callback", this);\n      this.stuff.push(thing);\n    });\n  }\n}\nconst newBox = new Box();\nnewBox.addJunk(["broken pencils", "busted rubber bands", "checkers pieces"]);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Well, this is not ideal at all. We want ",(0,s.jsx)(n.code,{children:"this"})," to represent our ",(0,s.jsx)(n.code,{children:"Box"})," object within the ",(0,s.jsx)(n.code,{children:"Array.prototype.forEach()"})," callback function!"]}),"\n",(0,s.jsxs)(n.p,{children:["Traditionally (before arrow notation came along, that is), JavaScript developers dealt with the issue by manually binding ",(0,s.jsx)(n.code,{children:"this"})," to the object they wanted it to represent. There are several ways to bind ",(0,s.jsx)(n.code,{children:"this"}),", but here's the easiest approach:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"addJunk(array) {\n  let that = this;\n  array.forEach(function(thing) {\n    that.stuff.push(thing);\n  });\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We declare a variable named ",(0,s.jsx)(n.code,{children:"that"})," inside our function and set it to the value of ",(0,s.jsx)(n.code,{children:"this"}),". The inner function has access to ",(0,s.jsx)(n.code,{children:"that"}),", which is just a reference to ",(0,s.jsx)(n.code,{children:"this"}),", and so we can push stuff into the box. This works because the variable ",(0,s.jsx)(n.code,{children:"that"})," won't change until we tell it to, whereas the value of ",(0,s.jsx)(n.code,{children:"this"})," always depends on where it is scoped (where in our code it's being called from)."]}),"\n",(0,s.jsx)(n.p,{children:"This approach is a hack, though, and JavaScript's default behavior really isn't great. Do we really want to use the above hack any time there's a callback function inside of an object's method?"}),"\n",(0,s.jsxs)(n.p,{children:["Fortunately, we can fix this problem by using arrow notation. With arrow notation we can create an ",(0,s.jsx)(n.strong,{children:"arrow function expression"}),", which is also commonly called an ",(0,s.jsx)(n.strong,{children:"arrow function"}),". Arrow functions do not perform any binding of ",(0,s.jsx)(n.code,{children:"this"}),", which means that ",(0,s.jsx)(n.code,{children:"this"})," is set to the scope that the arrow function was defined in. For the ",(0,s.jsx)(n.code,{children:"Box.prototype.addJunk()"})," method, this means that inside of an arrow function, ",(0,s.jsx)(n.code,{children:"this"})," will remain unchanged and still set the ",(0,s.jsx)(n.code,{children:"Box"})," object."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's update ",(0,s.jsx)(n.code,{children:"Box.prototype.addJunk()"})," to use an arrow function."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"addJunk(array) {\n  // The arrow function is defined in the scope of \n  // the Box.prototype.addJunk() method, which \n  // belongs to the Box object.\n  array.forEach((thing) => {\n    // The arrow function's own scope is anywhere\n    // inside of the arrow function.\n    // 'this' is not bound to the arrow function's own scope, but \n    // instead to the scope in which the arrow function was defined,\n    // the Box object.\n    this.stuff.push(thing);\n  });\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"And this is the arrow function, separated out:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"(thing) => {\n  this.stuff.push(thing);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["What we've done here is taken away the ",(0,s.jsx)(n.code,{children:"function()"})," and replaced it with ",(0,s.jsx)(n.code,{children:"() =>"}),". Parameters still go inside the parentheses as needed."]}),"\n",(0,s.jsx)(n.h3,{id:"when-to-use-arrow-functions",children:"When to Use Arrow Functions"}),"\n",(0,s.jsxs)(n.p,{children:["So when should we use arrow notation instead of the notation we've used in the past? Well, it's becoming increasingly common to use arrow notation regardless of whether you're concerned about binding ",(0,s.jsx)(n.code,{children:"this"})," or not. That's because arrow syntax is more concise and because its behavior is predictable and helps ensure that our code works how we'd expect it to."]}),"\n",(0,s.jsxs)(n.p,{children:["However, ",(0,s.jsx)(n.strong,{children:"you should never use arrow notation to define an object's method or an object's constructor function."})," Using arrow functions in any other application, or inside of an object's method is acceptable. To review a list of all differences between other functions and arrow functions, visit ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions",children:"the MDN documentation"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"more-arrow-function-examples",children:"More Arrow Function Examples"}),"\n",(0,s.jsxs)(n.p,{children:["So how exactly does this syntax look in situations other than with ",(0,s.jsx)(n.code,{children:"Array.prototype.forEach()"}),"?"]}),"\n",(0,s.jsx)(n.p,{children:"Here are some examples:"}),"\n",(0,s.jsx)(n.h4,{id:"unnamed-functions",children:"Unnamed Functions"}),"\n",(0,s.jsx)(n.p,{children:"Here's an unnamed function without arrow notation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'function (name) {\n  return "hi " + name;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Here's the same function with arrow notation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'(name) => {\n  return "hi " + name;\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"named-functions",children:"Named Functions"}),"\n",(0,s.jsx)(n.p,{children:"How about for a named function? This is how we've done it so far:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'function greeting(name) {\n  return "hi " + name;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"To do this with arrow notation, we need to save the function in a variable like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const greeting = (name) => {\n  return "hi " + name;\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"This may look pretty strange at first, but it will become more familiar over time, and we will revisit arrow functions in React."}),"\n",(0,s.jsxs)(n.p,{children:["You can continue to use function declarations or function expressions instead of arrow function expressions. However, the one case where you must use an arrow function is when you need the value of ",(0,s.jsx)(n.code,{children:"this"})," to not change when a new scope is created by a function inside of an object's method."]}),"\n",(0,s.jsx)(n.p,{children:"And again, you should not use arrow functions to create constructors or object methods."}),"\n",(0,s.jsx)(n.h3,{id:"syntactic-sugar-for-arrow-notation",children:"Syntactic Sugar for Arrow Notation"}),"\n",(0,s.jsxs)(n.p,{children:["It's also possible to use arrow notation to make our code even more concise, though it will look even more abstract as a result. Specifically, if the body of the function is a single line, we can omit both the brackets ",(0,s.jsx)(n.em,{children:"and"})," the return keyword. Let's take a look:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const greeting = name => "hi " + name;\n'})}),"\n",(0,s.jsx)(n.p,{children:"We can even omit the parentheses around the example above as long as there's just one parameter."}),"\n",(0,s.jsx)(n.p,{children:"While this is very concise, it can be harder to read and understand, especially for new developers, so don't use this syntax unless you feel very comfortable with it. In fact, there are a few gotchas with this syntax."}),"\n",(0,s.jsx)(n.p,{children:"If the function has two arguments, you can't omit the parentheses:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const greeting = (greeting, name) => greeting + " " + name;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["And if the code is multi-line, you can't omit the brackets ",(0,s.jsx)(n.em,{children:"or"})," the ",(0,s.jsx)(n.code,{children:"return"})," keyword:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const greeting = (greeting, name) => {\n  const uppercasedGreeting = greeting.toUpperCase();  \n  const uppercasedName = name.toUpperCase();\n  return uppercasedGreeting + " " + uppercasedName;\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This is a contrived example because we could easily reduce this function to one line. The point is that as soon as we have multiple lines in the body of a function using arrow notation, we need to use brackets and the ",(0,s.jsx)(n.code,{children:"return"})," keyword."]}),"\n",(0,s.jsxs)(n.p,{children:["For more information on arrow notation, see ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions",children:"Arrow function expressions in the Mozilla documentation"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"You will see arrow notation a lot in documentation and in JavaScript libraries, like Jest \u2014 and the longer you code in JavaScript, the more likely you are to use it regularly. We recommend getting familiar with arrow notation and using it regularly once you are comfortable with it."})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);