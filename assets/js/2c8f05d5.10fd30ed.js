"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[8300],{28453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>r});var n=s(96540);const i={},a=n.createContext(i);function o(e){const t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(a.Provider,{value:t},e.children)}},38759:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-41-part-2-adding-a-teardown-method-and-completing-the-tests-for-static-class-members","title":"\ud83d\udcd3 3.0.0.41 Part 2: Adding a Teardown Method and Completing the Tests for Static Class Members","description":"In this lesson we\'ll move past the roadblock we hit when testing the GetAll() getter method for the private static _instances field. As we\'ll see, the solution is quite simple!","source":"@site/versioned_docs/version-v1_3/3_c-and-net/0_lessons-32-44-tdd-and-debugging/3-0-0-41-part-2-adding-a-teardown-method-and-completing-the-tests-for-static-class-members.md","sourceDirName":"3_c-and-net/0_lessons-32-44-tdd-and-debugging","slug":"/c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-41-part-2-adding-a-teardown-method-and-completing-the-tests-for-static-class-members","permalink":"/v1.3/c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-41-part-2-adding-a-teardown-method-and-completing-the-tests-for-static-class-members","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 3.0.0.41 Part 2: Adding a Teardown Method and Completing the Tests for Static Class Members","day":"weekend","id":"3-0-0-41-part-2-adding-a-teardown-method-and-completing-the-tests-for-static-class-members","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.0.0.40 Part 1: Testing Static Class Members and Collections","permalink":"/v1.3/c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-40-part-1-testing-static-class-members-and-collections"},"next":{"title":"\ud83d\udcd3 3.0.0.42 MSTest Configuration Quick Reference","permalink":"/v1.3/c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-42-mstest-configuration-quick-reference"}}');var i=s(74848),a=s(28453);const o={title:"\ud83d\udcd3 3.0.0.41 Part 2: Adding a Teardown Method and Completing the Tests for Static Class Members",day:"weekend",id:"3-0-0-41-part-2-adding-a-teardown-method-and-completing-the-tests-for-static-class-members",hide_table_of_contents:!0},r=void 0,l={},d=[{value:"Adding a Teardown Method",id:"adding-a-teardown-method",level:2},{value:"5.  Run the automated test to confirm it passes. If it doesn&#39;t, revisit step 4.",id:"5--run-the-automated-test-to-confirm-it-passes-if-it-doesnt-revisit-step-4",level:3},{value:"Steps 6 and 7",id:"steps-6-and-7",level:3},{value:"Steps 8 and 9",id:"steps-8-and-9",level:3},{value:"Testing the Private Static Field <code>_instances</code> through its Setter Method <code>ClearAll()</code>",id:"testing-the-private-static-field-_instances-through-its-setter-method-clearall",level:2},{value:"1.  Identify the simplest possible behavior the program must exhibit.",id:"1--identify-the-simplest-possible-behavior-the-program-must-exhibit",level:3},{value:"2.  Write a coded test for this behavior.",id:"2--write-a-coded-test-for-this-behavior",level:3},{value:"Steps 3 and 4.  Before coding, confirm the test fails.",id:"steps-3-and-4--before-coding-confirm-the-test-fails",level:3},{value:"5.  Run the automated test to confirm it passes. If it doesn&#39;t, revisit step 4.",id:"5--run-the-automated-test-to-confirm-it-passes-if-it-doesnt-revisit-step-4-1",level:3},{value:"Steps 6 and 7",id:"steps-6-and-7-1",level:3},{value:"Steps 8 and 9",id:"steps-8-and-9-1",level:3},{value:"Final Thoughts",id:"final-thoughts",level:2},{value:"Repository Reference",id:"repository-reference",level:3}];function c(e){const t={a:"a",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",hr:"hr",i:"i",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["In this lesson we'll move past the roadblock we hit when testing the ",(0,i.jsx)(t.code,{children:"GetAll()"})," getter method for the private static ",(0,i.jsx)(t.code,{children:"_instances"})," field. As we'll see, the solution is quite simple!"]}),"\n",(0,i.jsx)(t.h2,{id:"adding-a-teardown-method",children:"Adding a Teardown Method"}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsxs)(t.p,{children:["When we add a ",(0,i.jsx)(t.strong,{children:"teardown"})," method, we're adding a special method that will run between tests to perform cleanup. In this case, we'll use a teardown method to reset the ",(0,i.jsx)(t.code,{children:"_instances"})," data between each test, ensuring any individual test's results aren't affected by earlier tests."]}),"\n",(0,i.jsxs)(t.p,{children:["To set up a teardown method, we'll need to add the ",(0,i.jsx)(t.code,{children:"IDisposable"})," keyword to our ",(0,i.jsx)(t.code,{children:"TriangleTests"})," class declaration and include a new using directive for the ",(0,i.jsx)(t.code,{children:"System"})," namespace, the namespace that ",(0,i.jsx)(t.code,{children:"IDisposable"})," lives in."]}),"\n",(0,i.jsxs)(t.p,{children:["Here's the first update to ",(0,i.jsx)(t.code,{children:"TriangleTests.cs"}),":"]}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ShapeTracker.Tests/ModelTests/TriangleTests.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"using Microsoft.VisualStudio.TestTools.UnitTesting;\nusing ShapeTracker.Models;\nusing System.Collections.Generic; \nusing System; // new using directive!\n\nnamespace ShapeTracker.Tests\n{\n  [TestClass]\n  public class TriangleTests : IDisposable\n  {\n\n    ... // tests omitted for brevity\n\n  }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"IDisposable"})," is what is referred to as an interface. We'll cover interfaces later in this section, but for now, just be aware that the ",(0,i.jsx)(t.code,{children:":"})," syntax above ",(0,i.jsx)(t.strong,{children:"extends"})," functionality from ",(0,i.jsx)(t.code,{children:"IDisposable"})," to our ",(0,i.jsx)(t.code,{children:"TriangleTests"})," class."]}),"\n",(0,i.jsxs)(t.p,{children:["Now that we've extended the ",(0,i.jsx)(t.code,{children:"IDisposable"})," interface, we'll be able to create a special method called ",(0,i.jsx)(t.code,{children:"Dispose()"})," that resets data between tests. Let's add this method now:"]}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ShapeTracker.Tests/ModelTests/TriangleTests.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"using Microsoft.VisualStudio.TestTools.UnitTesting;\nusing ShapeTracker.Models;\nusing System.Collections.Generic; \nusing System; \n\nnamespace ShapeTracker.Tests\n{\n  [TestClass]\n  public class TriangleTests : IDisposable\n  {\n    public void Dispose()\n    {\n      Triangle.ClearAll();\n    }\n\n    ... // tests omitted for brevity\n\n  }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"Dispose()"})," is a special method. Any code we add to ",(0,i.jsx)(t.code,{children:"Dispose"})," automatically runs after every test. In our case, we'll call the ",(0,i.jsx)(t.code,{children:"ClearAll()"})," method on the ",(0,i.jsx)(t.code,{children:"Triangle"})," class. However, ",(0,i.jsx)(t.code,{children:"ClearAll()"})," ",(0,i.jsx)(t.em,{children:"isn't"})," a built-in method. We'll have to define this one ourselves. We were going to do this as part of our Test-Driven Development, but we'll have to skip ahead and do it now."]}),"\n",(0,i.jsxs)(t.p,{children:["We'll add the new ",(0,i.jsx)(t.code,{children:"ClearAll()"})," method at the end of the ",(0,i.jsx)(t.code,{children:"Triangle"})," class:"]}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ShapeTracker.Solution/ShapeTracker/Models/Item.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"using System.Collections.Generic;\n\nnamespace ShapeTracker.Models\n{\n  public class Triangle\n  {\n    ... // other code omitted for brevity\n\n    public static void ClearAll()\n    {\n      _instances.Clear();\n    }\n\n  }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Our ",(0,i.jsx)(t.code,{children:"ClearAll()"})," method is static because it affects all ",(0,i.jsx)(t.code,{children:"Triangle"}),"s in the class, not just one. We use the built-in ",(0,i.jsx)(t.code,{children:"List<T>.Clear()"})," method to empty ",(0,i.jsx)(t.code,{children:"_instances"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"5--run-the-automated-test-to-confirm-it-passes-if-it-doesnt-revisit-step-4",children:"5.  Run the automated test to confirm it passes. If it doesn't, revisit step 4."}),"\n",(0,i.jsxs)(t.p,{children:["We can now check our tests to see if the code we implemented in the last lesson for the ",(0,i.jsx)(t.code,{children:"GetAll"})," test works as expected."]}),"\n",(0,i.jsxs)(t.p,{children:["Within the ",(0,i.jsx)(t.code,{children:"ShapeTracker.Tests"})," directory, run ",(0,i.jsx)(t.code,{children:"dotnet test"}),"."]}),"\n",(0,i.jsxs)(t.pre,{children:[(0,i.jsx)(t.code,{style:{color:"green"},children:"\nPassed!  - Failed:     0, Passed:    12, Skipped:     0, Total:    12, Duration: 138 ms - ShapeTracker.Tests.dll (net6.0)\n"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Woo-hoo! All our tests are passing now, which means both the ",(0,i.jsx)(t.code,{children:"Dispose()"})," test method and ",(0,i.jsx)(t.code,{children:"Triangle.GetAll()"})," method are both working correctly. Great!"]}),"\n",(0,i.jsxs)(t.p,{children:["To wrap up the RGR workflow for the ",(0,i.jsx)(t.code,{children:"GetAll()"})," method, let's complete the last four steps."]}),"\n",(0,i.jsx)(t.h3,{id:"steps-6-and-7",children:"Steps 6 and 7"}),"\n",(0,i.jsx)(t.p,{children:"We can also confirm that all previous tests still pass and there are no opportunities for refactoring yet."}),"\n",(0,i.jsx)(t.h3,{id:"steps-8-and-9",children:"Steps 8 and 9"}),"\n",(0,i.jsx)(t.p,{children:"We'll commit our passing code and move onto the next simplest behavior."}),"\n",(0,i.jsxs)(t.p,{children:["So what's next? Even though we've already written the code for the ",(0,i.jsx)(t.code,{children:"Triangle.ClearAll()"})," method, and successfully put it to use in the ",(0,i.jsx)(t.code,{children:"Dispose()"})," method, we need to write a test for it."]}),"\n",(0,i.jsxs)(t.h2,{id:"testing-the-private-static-field-_instances-through-its-setter-method-clearall",children:["Testing the Private Static Field ",(0,i.jsx)(t.code,{children:"_instances"})," through its Setter Method ",(0,i.jsx)(t.code,{children:"ClearAll()"})]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"1--identify-the-simplest-possible-behavior-the-program-must-exhibit",children:"1.  Identify the simplest possible behavior the program must exhibit."}),"\n",(0,i.jsxs)(t.p,{children:["To test the ability to change the value of ",(0,i.jsx)(t.code,{children:"_instances"}),", we'll need to write a setter method. In this case, we already know the name of our setter method: ",(0,i.jsx)(t.code,{children:"ClearAll()"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"2--write-a-coded-test-for-this-behavior",children:"2.  Write a coded test for this behavior."}),"\n",(0,i.jsx)(t.p,{children:"Here's our new test:"}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ShapeTracker.Solution/ShapeTracker.Tests/ModelTests/TriangleTests.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"using Microsoft.VisualStudio.TestTools.UnitTesting;\nusing ShapeTracker.Models;\n\nnamespace ShapeTracker.Tests\n{\n  [TestClass]\n  public class TriangleTests\n  {\n\n    ... // other tests omitted for brevity\n\n    [TestMethod]\n    public void ClearAll_DeletesAllTriangleInList_Void()\n    {\n      // Arrange\n      Triangle tri1 = new Triangle(2, 2, 9);\n      Triangle tri2 = new Triangle(21, 3, 9);\n      Triangle tri3 = new Triangle(1, 3, 9);\n      List<Triangle> expected = new List<Triangle> { };\n      // Act\n      Triangle.ClearAll();\n      // Assert\n      CollectionAssert.AreEqual(expected, Triangle.GetAll());\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"steps-3-and-4--before-coding-confirm-the-test-fails",children:"Steps 3 and 4.  Before coding, confirm the test fails."}),"\n",(0,i.jsx)(t.p,{children:"We can't complete steps 3 and 4 of the RGR workflow:"}),"\n",(0,i.jsxs)(t.ol,{start:"3",children:["\n",(0,i.jsx)(t.li,{children:"Before coding, confirm the test fails."}),"\n",(0,i.jsx)(t.li,{children:"Implement the behavior with the least amount of code possible."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["That's because we already have the code for ",(0,i.jsx)(t.code,{children:"ClearAll()"})," in place within the ",(0,i.jsx)(t.code,{children:"Triangle"})," class. This situation is unique, so it's okay that we can't complete these steps following the RGR workflow."]}),"\n",(0,i.jsx)(t.h3,{id:"5--run-the-automated-test-to-confirm-it-passes-if-it-doesnt-revisit-step-4-1",children:"5.  Run the automated test to confirm it passes. If it doesn't, revisit step 4."}),"\n",(0,i.jsxs)(t.p,{children:["Let's run ",(0,i.jsx)(t.code,{children:"dotnet test"})," within the ",(0,i.jsx)(t.code,{children:"ShapeTracker.Tests"})," directory, and see if our tests are passing:"]}),"\n",(0,i.jsxs)(t.pre,{children:[(0,i.jsx)(t.code,{style:{color:"green"},children:"\nPassed!  - Failed:     0, Passed:     13, Skipped:     0, Total:     8, Duration: 91 ms - ShapeTracker.Tests.dll (net6.0)\n"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Sweet!"}),"\n",(0,i.jsx)(t.h3,{id:"steps-6-and-7-1",children:"Steps 6 and 7"}),"\n",(0,i.jsx)(t.p,{children:"We can also confirm that all previous tests still pass and there are no opportunities for refactoring yet."}),"\n",(0,i.jsx)(t.h3,{id:"steps-8-and-9-1",children:"Steps 8 and 9"}),"\n",(0,i.jsxs)(t.p,{children:["We'll commit our passing code and move onto the next simplest behavior \u2014 only, that's it! There's nothing more for us to do because we've covered all of the ",(0,i.jsx)(t.code,{children:"Triangle"})," class logic that we need at this time."]}),"\n",(0,i.jsx)(t.h2,{id:"final-thoughts",children:"Final Thoughts"}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsxs)(t.p,{children:["Going forward, remember that whenever we use static data, we need to create a ",(0,i.jsx)(t.code,{children:"Dispose()"})," method to clean up between each test, and that we'll need to have our test classes extend from the ",(0,i.jsx)(t.code,{children:"IDisposable"})," interface."]}),"\n",(0,i.jsx)(t.h3,{id:"repository-reference",children:"Repository Reference"}),"\n",(0,i.jsx)(t.p,{children:"Follow the link below to view how a sample version of the project should look at this point. Note that this is a link to a specific branch in the repository. Also note the following:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["This branch contains completed business logic and tests for the ",(0,i.jsx)(t.code,{children:"Triangle"})," class."]}),"\n",(0,i.jsxs)(t.li,{children:["UI Logic in ",(0,i.jsx)(t.code,{children:"Program.cs"})," has been commented back in."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:(0,i.jsxs)(t.a,{href:"https://github.com/epicodus-lessons/prework-TDD-with-shape-tracker-csharp-net6/tree/2_complete_testing",children:[(0,i.jsx)(t.i,{className:"glyphicon glyphicon-folder-open"})," Example GitHub Repo for TDD with Shape Tracker: ",(0,i.jsx)(t.code,{children:"2_complete_testing"})]})})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);