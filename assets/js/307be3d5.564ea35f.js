"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[19024],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var i=n(96540);const s={},o=i.createContext(s);function a(e){const t=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:t},e.children)}},92051:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"react/react-fundamentals/4-2-2-4-passing-data-via-callbacks","title":"\ud83d\udcd3 4.2.2.4 Passing Data Via Callbacks","description":"In the last lesson, we covered the tricky concept of unidirectional data flow. In this lesson, we\'ll apply what we\'ve learned. To recap, we\'ll need to do the following:","source":"@site/docs/4_react/2_react-fundamentals/4-2-2-04-passing-data-via-callbacks.md","sourceDirName":"4_react/2_react-fundamentals","slug":"/react/react-fundamentals/4-2-2-4-passing-data-via-callbacks","permalink":"/v1.2/react/react-fundamentals/4-2-2-4-passing-data-via-callbacks","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 4.2.2.4 Passing Data Via Callbacks","day":"tuesday","id":"4-2-2-4-passing-data-via-callbacks","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 4.2.2.3 Unidirectional Data Flow","permalink":"/v1.2/react/react-fundamentals/4-2-2-3-unidirectional-data-flow"},"next":{"title":"\ud83d\udcd3 4.2.2.5 Styling React: CSS Objects","permalink":"/v1.2/react/react-fundamentals/4-2-2-5-styling-react-css-objects"}}');var s=n(74848),o=n(28453);const a={title:"\ud83d\udcd3 4.2.2.4 Passing Data Via Callbacks",day:"tuesday",id:"4-2-2-4-passing-data-via-callbacks",hide_table_of_contents:!0},c=void 0,r={},d=[{value:"Step 1: Move mainTicketList into State",id:"step-1-move-mainticketlist-into-state",level:3},{value:"Step #2: Pass New Props to TicketList Component and Add propTypes",id:"step-2-pass-new-props-to-ticketlist-component-and-add-proptypes",level:3},{value:"Step 3: Create a Method to Handle Our Form Submission",id:"step-3-create-a-method-to-handle-our-form-submission",level:3},{value:"Step 4: Pass Method Down to Child Component as a Prop",id:"step-4-pass-method-down-to-child-component-as-a-prop",level:3},{value:"Step 5: Add a Unique ID and Utilize the Parent Component&#39;s Method in the Child Component",id:"step-5-add-a-unique-id-and-utilize-the-parent-components-method-in-the-child-component",level:3}];function l(e){const t={code:"code",div:"div",em:"em",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"In the last lesson, we covered the tricky concept of unidirectional data flow. In this lesson, we'll apply what we've learned. To recap, we'll need to do the following:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Move ",(0,s.jsx)(t.code,{children:"mainTicketList"})," into state."]}),"\n",(0,s.jsxs)(t.li,{children:["Create a method in our parent ",(0,s.jsx)(t.code,{children:"TicketControl"})," component. This method will take any form data and turn it into an actual ticket."]}),"\n",(0,s.jsxs)(t.li,{children:["Pass this method down to the child ",(0,s.jsx)(t.code,{children:"NewTicketForm"})," component as a prop \u2014 and also add PropTypes."]}),"\n",(0,s.jsx)(t.li,{children:"Add our new method to the existing function in our child component so that it's triggered when a user submits the form."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"In order to do this, we only need to add a few lines of code \u2014 and make small modifications to a few other lines. Despite the relatively small amount of code being added, we are still working with challenging new concepts. Be patient with yourself and follow along slowly. If it doesn't all click immediately (and it probably won't), trust the process and keep practicing these concepts in class and on your own."}),"\n",(0,s.jsx)(t.h3,{id:"step-1-move-mainticketlist-into-state",children:"Step 1: Move mainTicketList into State"}),"\n",(0,s.jsxs)(t.p,{children:["Let's start by adding a mainTicketList property to state and passing it down as a prop to ",(0,s.jsx)(t.code,{children:"TicketList"})," :"]}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"src/components/TicketControl.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'class TicketControl extends React.Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      formVisibleOnPage: false,\n      mainTicketList: [] // new code\n    };\n  }\n\n...\n\n    if (this.state.formVisibleOnPage) {\n      currentlyVisibleState = <NewTicketForm />;\n      buttonText = "Return to Ticket List";\n    } else {\n      currentlyVisibleState = <TicketList ticketList={this.state.mainTicketList} />; // new code\n      buttonText = "Add Ticket"; \n    }\n...\n\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Notice we're initializing mainTicketList as an empty array. We're doing this because we don't want this application to start with fake tickets. The queue should be empty until we start adding tickets via our form. (We'll be removing our array of dummy tickets from ",(0,s.jsx)(t.code,{children:"TicketList"})," in just a moment.) Also, notice how we're passing mainTicketList down to ",(0,s.jsx)(t.code,{children:"TicketList"}),". We include it as a prop and target its place in state with ",(0,s.jsx)(t.code,{children:"this.state.mainTicketList"}),". Here we're calling it ",(0,s.jsx)(t.code,{children:"ticketList"}),", so that's the name we'll use to access it as a prop in ",(0,s.jsx)(t.code,{children:"TicketList"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"step-2-pass-new-props-to-ticketlist-component-and-add-proptypes",children:"Step #2: Pass New Props to TicketList Component and Add propTypes"}),"\n",(0,s.jsxs)(t.p,{children:["In the first step, we passed ",(0,s.jsx)(t.code,{children:"mainTicketList"})," state from ",(0,s.jsx)(t.code,{children:"TicketControl.js"})," down to our ",(0,s.jsx)(t.code,{children:"TicketList"})," component. Now we need to actually add props and prop types to ",(0,s.jsx)(t.code,{children:"TicketList.js"}),". We'll also remove the ",(0,s.jsx)(t.code,{children:"mainTicketList"})," constant that holds our dummy tickets as well."]}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"src/components/TicketList.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'import React from "react";\nimport Ticket from "./Ticket";\nimport PropTypes from "prop-types";\n\n// remove const mainTicketList = [ ... ]. We no longer want these.\n\nfunction TicketList(props) { // Add props as parameter.\n  return (\n    <React.Fragment>\n      <hr />\n      {props.ticketList.map((ticket, index) => // Loop through the list passed down from TicketControl.\n        <Ticket names={ticket.names}\n          location={ticket.location}\n          issue={ticket.issue}\n          key={index} />\n      )}\n    </React.Fragment>\n  );\n}\n\n// Add propTypes for ticketList.\nTicketList.propTypes = {\n  ticketList: PropTypes.array\n};\n\nexport default TicketList;\n'})}),"\n",(0,s.jsxs)(t.p,{children:["We've made several changes here. Now that we are passing ",(0,s.jsx)(t.code,{children:"ticketList"})," down through ",(0,s.jsx)(t.code,{children:"props"}),", we need to ",(0,s.jsx)(t.code,{children:"import prop-types"})," and add a prop type of array for our ",(0,s.jsx)(t.code,{children:"ticketList"}),". We also remove our ",(0,s.jsx)(t.code,{children:"mainTicketList"})," constant which stored three fake tickets \u2014 we won't need these anymore!"]}),"\n",(0,s.jsx)(t.p,{children:"Now we'll be able to make changes to our ticket list and, ultimately, display tickets as they're added."}),"\n",(0,s.jsx)(t.h3,{id:"step-3-create-a-method-to-handle-our-form-submission",children:"Step 3: Create a Method to Handle Our Form Submission"}),"\n",(0,s.jsxs)(t.p,{children:["We'll start with step #1: creating a method in our ",(0,s.jsx)(t.code,{children:"TicketControl"})," component."]}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"TicketControl.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"...\n\nclass TicketControl extends React.Component {\n\n  constructor(props) {\n    ...\n  }\n\n...\n\n  handleAddingNewTicketToList = (newTicket) => {\n    const newMainTicketList = this.state.mainTicketList.concat(newTicket);\n    this.setState({mainTicketList: newMainTicketList,\n                  formVisibleOnPage: false });\n  }\n...\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Our new method is called ",(0,s.jsx)(t.code,{children:"handleAddingNewTicketToList"})," because it does just that \u2014 handle the process of adding a new ticket in our ",(0,s.jsx)(t.code,{children:"mainTicketList"}),". It takes a ",(0,s.jsx)(t.code,{children:"newTicket"})," as a parameter."]}),"\n",(0,s.jsxs)(t.p,{children:["It's common practice to prefix the name of an event handler function with ",(0,s.jsx)(t.code,{children:"handle"}),". Any props containing that function will be prefixed with ",(0,s.jsx)(t.code,{children:"on"}),". (We will add our prop in the next step.) This is because the prop will be used ",(0,s.jsx)(t.em,{children:"when"})," the event occurs, but the function itself is what ",(0,s.jsx)(t.em,{children:"actually handles"})," the necessary actions. It also ensures the names are similar enough to easily determine which props and functions correspond, yet different enough to determine when we're referencing a function and when we're referencing a prop containing a function."]}),"\n",(0,s.jsxs)(t.p,{children:["Next, we create a constant called ",(0,s.jsx)(t.code,{children:"newMainTicketList"}),". Remember that we should ",(0,s.jsx)(t.strong,{children:"never"})," alter state directly. Instead, we will let React do that with the ",(0,s.jsx)(t.code,{children:"setState()"})," method."]}),"\n",(0,s.jsxs)(t.p,{children:["We take ",(0,s.jsx)(t.code,{children:"this.state.mainTicketList"})," and call ",(0,s.jsx)(t.code,{children:"concat()"})," on it. Unlike ",(0,s.jsx)(t.code,{children:"push()"}),", which directly alters the array its called on, ",(0,s.jsx)(t.code,{children:"concat()"})," makes a ",(0,s.jsx)(t.em,{children:"copy"})," of that array. Anything passed into ",(0,s.jsx)(t.code,{children:"concat()"})," (in this case, our ",(0,s.jsx)(t.code,{children:"newTicket"}),") will be concatenated to the end of the new array."]}),"\n",(0,s.jsxs)(t.p,{children:["Next, we set the value of ",(0,s.jsx)(t.code,{children:"mainTicketList"})," to the ",(0,s.jsx)(t.code,{children:"newMainTicketList"})," variable we just created. As noted, we are using ",(0,s.jsx)(t.code,{children:"setState()"})," to make our direct change to state."]}),"\n",(0,s.jsxs)(t.p,{children:["Finally, once the ticket has successfully been submitted, we want to set ",(0,s.jsx)(t.code,{children:"formVisibleOnPage"})," to false again so that the user will see the queue, not the form."]}),"\n",(0,s.jsx)(t.h3,{id:"step-4-pass-method-down-to-child-component-as-a-prop",children:"Step 4: Pass Method Down to Child Component as a Prop"}),"\n",(0,s.jsxs)(t.p,{children:["Now we need to pass our new ",(0,s.jsx)(t.code,{children:"handleAddingNewTicketToList"})," method down to our ",(0,s.jsx)(t.code,{children:"NewTicketForm"})," component as a prop. We'll start by making a small update to our ",(0,s.jsx)(t.code,{children:"TicketControl"}),"'s ",(0,s.jsx)(t.code,{children:"render()"})," method:"]}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"TicketControl.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'...\nrender(){\n    ...\n    if (this.state.formVisibleOnPage) {\n      currentlyVisibleState = <NewTicketForm onNewTicketCreation={this.handleAddingNewTicketToList} /> { // new code in this line }\n      buttonText = "Return to Ticket List";\n    } else {\n      ....\n\n'})}),"\n",(0,s.jsxs)(t.p,{children:["We will pass ",(0,s.jsx)(t.code,{children:"this.handleAddingNewTicketToList"})," as a prop to the ",(0,s.jsx)(t.code,{children:"NewTicketForm"}),". It will be saved in the prop ",(0,s.jsx)(t.code,{children:"onNewTicketCreation"}),". As noted in Step 1, we prefix the prop with ",(0,s.jsx)(t.code,{children:"on"}),". This differentiates the method in our parent component (which will actually handle the event) from the function in our child component (which is triggered when the event happens)."]}),"\n",(0,s.jsxs)(t.p,{children:["Next, we need to make a few changes to our child ",(0,s.jsx)(t.code,{children:"NewTicketForm"})," so that it will accept props."]}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"NewTicketForm.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'import React from "react";\nimport PropTypes from "prop-types"; //import PropTypes\n\nfunction NewTicketForm(props){ // Make sure to add props as a parameter.\n  ...\n}\n\n// We also need to add PropTypes for our new prop.\n\nNewTicketForm.propTypes = {\n  onNewTicketCreation: PropTypes.func\n};\n\nexport default NewTicketForm;\n'})}),"\n",(0,s.jsx)(t.p,{children:"We do two things here:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Ensure we are passing ",(0,s.jsx)(t.code,{children:"props"})," into our function component. Otherwise, our ",(0,s.jsx)(t.code,{children:"NewTicketForm"})," won't have access to props from ",(0,s.jsx)(t.code,{children:"TicketControl"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["We add a ",(0,s.jsx)(t.code,{children:"PropTypes"})," for ",(0,s.jsx)(t.code,{children:"onNewTicketCreation"}),". Remember that ",(0,s.jsx)(t.code,{children:"this.handleAddingNewTicketToList"})," is passed down to the child component as ",(0,s.jsx)(t.code,{children:"onNewTicketCreation"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"step-5-add-a-unique-id-and-utilize-the-parent-components-method-in-the-child-component",children:"Step 5: Add a Unique ID and Utilize the Parent Component's Method in the Child Component"}),"\n",(0,s.jsx)(t.p,{children:"We're almost done! We need to two things:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Import the UUID library to assign unique IDs to new tickets."}),"\n",(0,s.jsxs)(t.li,{children:["Update the ",(0,s.jsx)(t.code,{children:"handleNewTicketFormSubmission"})," function so that it creates a new ticket object and uses our ",(0,s.jsx)(t.code,{children:"onNewTicketCreation"})," prop to send the ticket object to the parent component, ",(0,s.jsx)(t.code,{children:"TicketControl"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Here's the updated code:"}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"NewTicketForm.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"...\nimport { v4 } from 'uuid'; // new code\n\nfunction NewTicketForm(props){\n  ...\n\n  function handleNewTicketFormSubmission(event) {\n    event.preventDefault();\n    props.onNewTicketCreation({\n      names: event.target.names.value, \n      location: event.target.location.value, \n      issue: event.target.issue.value, \n      id: v4()\n    });\n  }\n\n...\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Because a function component doesn't have ",(0,s.jsx)(t.code,{children:"this"})," as a reference like a class component, we need to directly refer to the ",(0,s.jsx)(t.code,{children:"props"})," passed into the function component. That's why we do ",(0,s.jsx)(t.code,{children:"props.onNewTicketCreation()"})," instead of ",(0,s.jsx)(t.code,{children:"this.onNewTicketCreation()"})," (as we'd do if this were a class component)."]}),"\n",(0,s.jsxs)(t.p,{children:["We create an object with all of the ticket properties and pass it as the argument to ",(0,s.jsx)(t.code,{children:"props.onNewTicketCreation()"}),". We also create a unique ID with the UUID library."]}),"\n",(0,s.jsxs)(t.p,{children:["Take note that if we need to get a number from our form, we'd want to parse any form values at this point. For example, say we wanted to track the number of students who need help; in this case, we might have a property called ",(0,s.jsx)(t.code,{children:"numberOfStudents"})," and we'd want to make sure we parse the corresponding form value:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"props.onNewTicketCreation({\n  ...\n  numberOfStudents: parseInt(event.target.numberOfStudents.value)\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Remember that ",(0,s.jsx)(t.code,{children:"onNewTicketCreation()"})," is the callback from the parent component even though it has a different name now. The following method is invoked in ",(0,s.jsx)(t.code,{children:"TicketControl"}),":"]}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"TicketControl.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"handleAddingNewTicketToList = (newTicket) => {\n    const newMainTicketList = this.state.mainTicketList.concat(newTicket);\n    this.setState({\n      mainTicketList: newMainTicketList,\n      formVisibleOnPage: false\n    });\n  }\n"})}),"\n",(0,s.jsxs)(t.p,{children:["When we call ",(0,s.jsx)(t.code,{children:"props.onNewTicketCreation({names: names.value, location: location.value, issue: issue.value});"})," in the ",(0,s.jsx)(t.code,{children:"NewTicketForm"})," component, this object is passed in as an argument to the ",(0,s.jsx)(t.code,{children:"newTicket"})," parameter, updating the ",(0,s.jsx)(t.code,{children:"mainTicketList"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Try it out in the browser. Now when we add a ticket via the form, it will be added to the queue!"})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);