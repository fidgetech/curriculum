"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[96427],{24824:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/breadth_first_search-01ef9bebed2e9a259e44a3c0c3220884.png"},28453:(e,t,a)=>{a.d(t,{R:()=>o,x:()=>i});var n=a(96540);const s={},r=n.createContext(s);function o(e){const t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(r.Provider,{value:t},e.children)}},28735:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/friend-graph-1b59aa48b4b6b400f4fc56b71f52924d.png"},57929:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>h,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"capstone/capstone-week-1/depth-and-breadth-search-algorithms","title":"\ud83d\udcd3 Depth and Breadth Search Algorithms","description":"There are two ways we can search a tree \u2014 regardless of whether that\'s a binary search tree or a more general tree. We can take a depth-first search (DFS) approach or a breadth-first search (BFS) approach. You can probably guess a little bit about each approach. If we are looking at a tree that has a root node and child nodes, a depth-first search algorithm will search a tree vertically while a breadth-first search algorithm will search a tree horizontally. A graph can\'t really be measured vertically or horizontally in this way but the same concept still applies \u2014 we can search broadly or go deeper into each branch first. We just don\'t necessarily do so from a root node. Instead, we can start our search from any node in the graph.","source":"@site/docs/capstone/1_capstone-week-1/depth-and-breadth-search-algorithms.md","sourceDirName":"capstone/1_capstone-week-1","slug":"/capstone/capstone-week-1/depth-and-breadth-search-algorithms","permalink":"/v1.2/capstone/capstone-week-1/depth-and-breadth-search-algorithms","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":22,"frontMatter":{"title":"\ud83d\udcd3 Depth and Breadth Search Algorithms","id":"depth-and-breadth-search-algorithms","slug":"depth-and-breadth-search-algorithms","hide_table_of_contents":true,"sidebar_position":22,"day":"tuesday","type":"lesson","url":"https://github.com/epicodus-curriculum/capstone/blob/main/6_depth_and_breadth_search_algorithms_overview.md"},"sidebar":"capstone","previous":{"title":"\ud83d\udcd3 Introduction to Stacks and Queues","permalink":"/v1.2/capstone/capstone-week-1/introduction-to-stacks-and-queues"},"next":{"title":"\ud83d\udcd3 Depth First Algorithms","permalink":"/v1.2/capstone/capstone-week-1/depth-first-algorithms"}}');var s=a(74848),r=a(28453);const o={title:"\ud83d\udcd3 Depth and Breadth Search Algorithms",id:"depth-and-breadth-search-algorithms",slug:"depth-and-breadth-search-algorithms",hide_table_of_contents:!0,sidebar_position:22,day:"tuesday",type:"lesson",url:"https://github.com/epicodus-curriculum/capstone/blob/main/6_depth_and_breadth_search_algorithms_overview.md"},i=void 0,h={},d=[{value:"Depth-First Search",id:"depth-first-search",level:2},{value:"Advantages",id:"advantages",level:3},{value:"Breadth-First Search",id:"breadth-first-search",level:2},{value:"Advantages",id:"advantages-1",level:3},{value:"Summary",id:"summary",level:2}];function l(e){const t={code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["There are two ways we can search a tree \u2014 regardless of whether that's a binary search tree or a more general tree. We can take a ",(0,s.jsx)(t.strong,{children:"depth-first search"})," (DFS) approach or a ",(0,s.jsx)(t.strong,{children:"breadth-first search"})," (BFS) approach. You can probably guess a little bit about each approach. If we are looking at a tree that has a root node and child nodes, a depth-first search algorithm will search a tree vertically while a breadth-first search algorithm will search a tree horizontally. A graph can't really be measured vertically or horizontally in this way but the same concept still applies \u2014 we can search broadly or go deeper into each branch first. We just don't necessarily do so from a root node. Instead, we can start our search from any node in the graph."]}),"\n",(0,s.jsx)(t.h2,{id:"depth-first-search",children:"Depth-First Search"}),"\n",(0,s.jsx)(t.p,{children:"Remember our binary search tree application where we worked with a perfect binary search tree? If we wanted to do a depth-first search, we'd do so in this order."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Illustration shows the order the nodes will be traversed.",src:a(70267).A+"",width:"531",height:"305"})}),"\n",(0,s.jsxs)(t.p,{children:["We can say that the tree in this picture has four ",(0,s.jsx)(t.strong,{children:"branches"}),". They all start at the root node and terminate in a leaf node. So the left-most branch terminates at 1, the next branch terminates at 3, the next terminates at 5, and the last branch terminates at 7."]}),"\n",(0,s.jsx)(t.p,{children:"In a depth-first search, our algorithm will completely traverse the left-most branch. Once that is complete, it will backtrack (in this case, to the 2 node) and then completely traverse the next branch. It will continue doing this until it finds what it's searching for \u2014 or, if the value doesn't exist, until the tree is completely traversed."}),"\n",(0,s.jsxs)(t.p,{children:["But how does the algorithm actually backtrack? Well, a DFS algorithm commonly uses a ",(0,s.jsx)(t.strong,{children:"stack"})," (last-in, first-out) to search through each branch to the very end. Remember, to visualize a stack we can think of a stack of pancakes. The last pancake we add to a stack goes on top (the beginning of the stack) \u2014 and the first pancake we eat is the one on top \u2014 the last pancake on the stack is the first one we eat."]}),"\n",(0,s.jsx)(t.p,{children:"Let's walk through this process for our perfect binary search tree \u2014 and in doing so, we'll see how using a stack allows our algorithm to traverse and automatically backtrack through a tree's branches."}),"\n",(0,s.jsx)(t.p,{children:"We'll start with the simple example \u2014 the one above \u2014 and then move onto a more complex example using a graph."}),"\n",(0,s.jsx)(t.p,{children:"In the perfect binary search tree above, we start with the root node. Here's our stack so far:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"let stack = [4]\n"})}),"\n",(0,s.jsxs)(t.p,{children:["There's only one element, so we can't really demonstrate its LIFO yet. We get the children of ",(0,s.jsx)(t.code,{children:"4"})," (",(0,s.jsx)(t.code,{children:"2"})," and ",(0,s.jsx)(t.code,{children:"6"}),") and remove the ",(0,s.jsx)(t.code,{children:"4"})," from the stack. Now our stack looks like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"stack = [2, 6];\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Remember, we want to search the left-most branch first. So now we grab ",(0,s.jsx)(t.code,{children:"2"})," from the beginning of the stack and add this node's children to the beginning of the stack: ",(0,s.jsx)(t.code,{children:"1"})," and ",(0,s.jsx)(t.code,{children:"3"}),". Here's the stack now:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"stack = [1, 3, 6];\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Once again, to continue down the left-most branch, we just need to grab the first value. We take the ",(0,s.jsx)(t.code,{children:"1"})," from the beginning of the stack. It has no children, so we are done with that branch. So here's our stack now:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"stack = [3, 6];\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Look at that \u2014 the first element in our stack is the next branch! We see that the ",(0,s.jsx)(t.code,{children:"3"})," has no children of its own \u2014 so now our stack is just this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"stack = [6];\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We've completely evaluated the left subtree and now only the right subtree remains. We take ",(0,s.jsx)(t.code,{children:"6"})," from the stack, evaluate its children, and so on."]}),"\n",(0,s.jsx)(t.p,{children:"Now that we've looked at a basic example of how a DFS uses a stack, let's apply a more complex example. This time we'll use a graph. After all, we are in the middle of learning about graph theory."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"The following chart shows a graph of friends.",src:a(28735).A+"",width:"601",height:"361"})}),"\n",(0,s.jsx)(t.p,{children:"Here's a graph of friends. We will actually be using this very graph when we actually write our BFS and DFS algorithms over the next several lessons. Let's say we want to find a connection between Jasmine and Thomas. How would we do that with a depth-first search?"}),"\n",(0,s.jsx)(t.p,{children:"First, we'll get an array of Jasmine's friends. This is our initial stack:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'let stack = ["Ada", "Lydia", "Rose"];\n'})}),"\n",(0,s.jsx)(t.p,{children:"Now we want to navigate down through the first branch on the list. There's really no working from left-to-right here \u2014 nor can we really say we are searching the graph horizontally or vertically like we would with a binary search tree. Instead, we'd just grab the list of Jasmine's friends from an adjacency list or similar structure. Because this is a stack, we are starting with the first friend in the array. We remove Ada from the stack and get her list of friends."}),"\n",(0,s.jsx)(t.p,{children:"Ada is connected to Dylan and Lydia. Let's add them to the top of the stack. Now our stack looks like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'stack = ["Dylan", "Lydia", "Lydia", "Rose"];\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Ada has been removed from the top of the stack while her friends have been added. Because this is a stack, we need to continue with the last-in, first-out approach. But now hopefully it's clear ",(0,s.jsx)(t.em,{children:"why"})," we need to do that. What gets added to the top of the stack is any remaining friends in the branch we are currently traversing \u2014 as well as friends in sub-branches we will be traversing soon. Meanwhile, what's at the bottom of the stack? A completely different branch. So everything we add right now is what we need to evaluate right now \u2014 in other words, last-in, first-out."]}),"\n",(0,s.jsx)(t.p,{children:"So now we take Dylan from the top of the stack and grab his friends. There is just Allison, which we add to the top of the stack."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'stack = ["Allison", "Lydia", "Lydia", "Rose"];\n'})}),"\n",(0,s.jsx)(t.p,{children:"When we take Allison from the top of the stack, we'll see that she only has Dylan as a friend. However, we have already traversed the node that represents Dylan \u2014 and we don't want to traverse it again. To avoid that, we flag nodes as we traverse them. This is a key difference between how we'd traverse this graph versus how we'd traverse a binary search tree. Our binary search tree is directed \u2014 information can only flow from parents to children \u2014 and children know nothing about their parents. There is no risk of accidentally going back to a node that has already been traversed. However, our graph is undirected \u2014 so we need to make sure our algorithm doesn't accidentally traverse nodes that have already been covered."}),"\n",(0,s.jsx)(t.p,{children:"So at this point, because we've traversed through nodes representing Jasmine, Ada and Dylan already, we wouldn't add them back to the stack. So when Allison is removed from the top of the stack, no one else is added."}),"\n",(0,s.jsx)(t.p,{children:"So now our stack looks like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'stack = ["Lydia", "Lydia", "Rose"];\n'})}),"\n",(0,s.jsxs)(t.p,{children:["We are moving onto our next branch! Once we reach the end of a branch, there are no more nodes to traverse. The last item in the stack will now be the ",(0,s.jsx)(t.em,{children:"most recent"})," sub-branch we haven't explored yet. In this case, it is Lydia. But note that we are exploring Lydia's connection to Ada, not Lydia's connection to Jasmine here."]}),"\n",(0,s.jsxs)(t.p,{children:["We remove that from the top of the stack and find Thomas. We've successfully determined the reachability between Thomas and Jasmine. So at this point, if we've been tracking our traversal, we can see that there's a connection going like this: ",(0,s.jsx)(t.code,{children:"Jasmine -> Ada -> Lydia -> Thomas"}),". So we could say that Thomas is a friend of a friend of a friend."]}),"\n",(0,s.jsx)(t.p,{children:"But if we actually look at our graph, we can quickly see that there is a closer connection. After all, we normally call them friends of friends if we can \u2014 not friends of friends of friends. If we wanted to determine not just the reachability of a node but the shortest path, our depth-first search would continue."}),"\n",(0,s.jsx)(t.p,{children:"By the way, here's a very important reason we need to flag nodes as we traverse them. Jasmine is Lydia's friend. If we didn't flag that we'd already traversed through that node, our algorithm could check Jasmine's friends, find Ada, and then check Ada's friends, find Lydia, and then check Lydia's friends, only to find Jasmine, forever and ever in an infinite loop of friends that sounds wonderful in practice but not in programming."}),"\n",(0,s.jsx)(t.p,{children:"So the key takeaways here, at least from a programming perspective, is that we need to use a stack to walk through the graph with a depth-first search, and also that we need to flag nodes we've already traversed so we don't run into infinite loops or other inefficiencies."}),"\n",(0,s.jsx)(t.p,{children:"If this is still confusing, don't worry. It should become clearer when we use TDD to write a depth-first search algorithm in the next lesson."}),"\n",(0,s.jsx)(t.h3,{id:"advantages",children:"Advantages"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"DFSs are great for building games because they allow the algorithm to explore winning and losing possibilities."}),"\n",(0,s.jsx)(t.li,{children:"If we know that the answer we are looking for will be at the bottom of a tree, a DFS will usually be faster than a BFS. For instance, we might be looking for living descendants of a long family tree \u2014 and everyone alive will be at the bottom of the tree."}),"\n",(0,s.jsx)(t.li,{children:"DFS usually takes less memory than BFS."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"breadth-first-search",children:"Breadth-First Search"}),"\n",(0,s.jsx)(t.p,{children:"On the other hand, a breadth-first search algorithm searches horizontally. The image below demonstrates this:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"The order in which a breadth-first algorithm will traverse a tree.",src:a(24824).A+"",width:"531",height:"305"})}),"\n",(0,s.jsx)(t.p,{children:"As we can see, the algorithm will search each row in the tree completely before moving onto the next one."}),"\n",(0,s.jsxs)(t.p,{children:["In contrast to a depth-first search, a breadth-first search uses a ",(0,s.jsx)(t.strong,{children:"queue"})," instead of a stack. That means that when we add new nodes to the collection, they are added at the ",(0,s.jsx)(t.em,{children:"end"}),". Meanwhile, we evaluate the node at the beginning of the collection first. In other words, we're saying, hey, node, get in line! We'll get to you once we've gotten through all the nodes ahead of you."]}),"\n",(0,s.jsx)(t.p,{children:"Once again, let's demonstrate how this works first on the perfect binary search tree in the diagram above and then on our graph of friends."}),"\n",(0,s.jsx)(t.p,{children:"Our queue starts like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"let queue = [4];\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We grab ",(0,s.jsx)(t.code,{children:"4"})," and then add ",(0,s.jsx)(t.code,{children:"2"})," and ",(0,s.jsx)(t.code,{children:"6"})," to the queue."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"queue = [2, 6];\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"2"})," is first in line, so let's add its children: ",(0,s.jsx)(t.code,{children:"1"})," and ",(0,s.jsx)(t.code,{children:"3"}),". Here's the big difference between the stack we used before and the queue we are using now. We add ",(0,s.jsx)(t.code,{children:"1"})," and ",(0,s.jsx)(t.code,{children:"3"})," to the ",(0,s.jsx)(t.em,{children:"end"}),' of the queue \u2014 not to the beginning (or "top") of the stack.']}),"\n",(0,s.jsx)(t.p,{children:"So now our queue looks like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"queue = [6, 1, 3];\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We take ",(0,s.jsx)(t.code,{children:"6"})," from the front and add its children (",(0,s.jsx)(t.code,{children:"5"})," and ",(0,s.jsx)(t.code,{children:"7"}),") to the queue:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"queue = [1, 3, 5, 7];\n"})}),"\n",(0,s.jsx)(t.p,{children:"As we can see, we've finished an entire \"row\" of the tree \u2014 and all that's left to traverse is the bottom row."}),"\n",(0,s.jsx)(t.p,{children:"Now let's look at the more complex example. Our graph of friends. Here's the picture of the graph again:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"The following chart shows a graph of friends.",src:a(28735).A+"",width:"601",height:"361"})}),"\n",(0,s.jsxs)(t.p,{children:["In this case, we want to check ",(0,s.jsx)(t.em,{children:"all"})," of Jasmine's friends before we check her friends' friends."]}),"\n",(0,s.jsx)(t.p,{children:"First, we add all of her friends to an array:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'let queue = ["Ada", "Lydia", "Rose"];\n'})}),"\n",(0,s.jsx)(t.p,{children:"The first friend in the queue is Ada. We remove Ada from the queue and get her friends: Dylan and Lydia. We add them to the end of the queue:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'queue = ["Lydia", "Rose", "Dylan", "Lydia"];\n'})}),"\n",(0,s.jsx)(t.p,{children:"As we can see, the first few names still on the list are the ones that are Jasmine's friends \u2014 we save the names we added (friends of friends) to the end of the list. Remember, nodes added to the end of the list always represent going deeper into the tree. If we want to go depth-first, we add elements to the beginning of the collection. If we want to go breadth-first, we add new elements to the end of the collection."}),"\n",(0,s.jsxs)(t.p,{children:["If this is still confusing, we'll be covering BFS more in-depth \u2014 or maybe we should say ",(0,s.jsx)(t.em,{children:"more broadly"})," \u2014 in the lesson after next."]}),"\n",(0,s.jsx)(t.h3,{id:"advantages-1",children:"Advantages"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"If we know that an answer will be close to the root node, a BFS is more efficient. For instance, in the family tree example, we might be looking for a direct descendant that lived 50 years later than the ancestor at the root node, not 300 years later."}),"\n",(0,s.jsx)(t.li,{children:"BFSs are great for computing the most efficient path between two nodes. For that reason, they are great for GPS and mapping applications and even for finding people near each other in social networks."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(t.p,{children:"In this lesson, we gave a brief overview of BFS and DFS algorithms, including the advantages of both. We also learned how depth-first algorithms utilize a stack (LIFO) while breadth-first algorithms use a queue (FIFO). At this point, we are ready to actually incorporate these algorithms into our graph application!"})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},70267:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/depth_first_search-2e5eb037cbcbb01ba10c5a2319747b37.png"}}]);