"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[44461],{18209:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-35-using-the-rgr-workflow-to-write-our-first-test-for-the-constructor","title":"\ud83d\udcd3 3.0.0.35 Using the RGR Workflow to Write our First Test for the Constructor","description":"Let\'s create our first test. Remember that the purpose of test-driven development is to write a test for the smallest unit of behavior possible. The test should fail first. Then we should add the smallest amount of code possible to get the test to pass. After that, we can refactor our code as necessary. This follows the \\"Red, Green, Refactor\\" TDD workflow.","source":"@site/docs/3_c-and-net/0_lessons-32-44-tdd-and-debugging/3-0-0-35-using-the-rgr-workflow-to-write-our-first-test-for-the-constructor.md","sourceDirName":"3_c-and-net/0_lessons-32-44-tdd-and-debugging","slug":"/c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-35-using-the-rgr-workflow-to-write-our-first-test-for-the-constructor","permalink":"/v1.2/c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-35-using-the-rgr-workflow-to-write-our-first-test-for-the-constructor","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 3.0.0.35 Using the RGR Workflow to Write our First Test for the Constructor","day":"weekend","id":"3-0-0-35-using-the-rgr-workflow-to-write-our-first-test-for-the-constructor","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.0.0.34 MSTest Configuration and Setup","permalink":"/v1.2/c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-34-mstest-configuration-and-setup"},"next":{"title":"\ud83d\udcd3 3.0.0.36 Testing A Private Field through its Public Property and Organizing Tests with Arrange, Act, Assert","permalink":"/v1.2/c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-36-testing-a-private-field-through-its-public-property-and-organizing-tests-with-arrange-act-assert"}}');var r=s(74848),i=s(28453);const o={title:"\ud83d\udcd3 3.0.0.35 Using the RGR Workflow to Write our First Test for the Constructor",day:"weekend",id:"3-0-0-35-using-the-rgr-workflow-to-write-our-first-test-for-the-constructor",hide_table_of_contents:!0},a=void 0,l={},c=[{value:"Clearing <code>Triangle</code> Logic",id:"clearing-triangle-logic",level:2},{value:"Reference for the &quot;Red, Green, Refactor&quot; (RGR) Workflow",id:"reference-for-the-red-green-refactor-rgr-workflow",level:2},{value:"1. Identify the Simplest Behavior",id:"1-identify-the-simplest-behavior",level:2},{value:"2. Write a Coded Test",id:"2-write-a-coded-test",level:2},{value:"Test Method Naming Conventions",id:"test-method-naming-conventions",level:3},{value:"Creating an Assertion",id:"creating-an-assertion",level:3},{value:"3. Before coding, confirm the test fails.",id:"3-before-coding-confirm-the-test-fails",level:2},{value:"4. Implement the behavior with the least amount of code possible.",id:"4-implement-the-behavior-with-the-least-amount-of-code-possible",level:2},{value:"5. Run the automated test to confirm it passes.",id:"5-run-the-automated-test-to-confirm-it-passes",level:2},{value:"6. Confirm Previous Tests Still Pass",id:"6-confirm-previous-tests-still-pass",level:3},{value:"7. Check For Refactoring",id:"7-check-for-refactoring",level:3},{value:"8. Commit Your Passing Code!",id:"8-commit-your-passing-code",level:2}];function h(e){const t={code:"code",div:"div",em:"em",font:"font",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:'Let\'s create our first test. Remember that the purpose of test-driven development is to write a test for the smallest unit of behavior possible. The test should fail first. Then we should add the smallest amount of code possible to get the test to pass. After that, we can refactor our code as necessary. This follows the "Red, Green, Refactor" TDD workflow.'}),"\n",(0,r.jsx)(t.p,{children:"Keep in mind, though, that the process of using TDD with C# will feel very different. When there is an error in our C# code, our code will often fail to compile \u2014 an issue we won't run into with JavaScript. While in JavaScript this was not considered a good fail, in C#, compiler errors are acceptable and we can consider them to be a good fail."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsxs)(t.strong,{children:["Note: If you are working along with the lessons in your own project, you will need to comment out the code inside the Main method in the ",(0,r.jsx)(t.code,{children:"Program.cs"})," file. As a reference, please see the example project linked at the bottom of the previous lesson."]})}),"\n",(0,r.jsxs)(t.h2,{id:"clearing-triangle-logic",children:["Clearing ",(0,r.jsx)(t.code,{children:"Triangle"})," Logic"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsxs)(t.p,{children:["The first thing we'll want to do is remove the contents of our ",(0,r.jsx)(t.code,{children:"Triangle"})," class, so that it is just a class and namespace declaration. We'll remove the using directive for ",(0,r.jsx)(t.code,{children:"System.Collections.Generic"})," as well. This is what the contents ",(0,r.jsx)(t.code,{children:"Triangle.cs"})," should look like:"]}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"ShapeTracker/Models/Triangle.cs"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"namespace ShapeTracker.Models\n{\n  public class Triangle\n  {\n    // Code for Triangle business logic will go here.\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Now we're ready to start re-creating our ",(0,r.jsx)(t.code,{children:"Triangle"})," class logic using TDD."]}),"\n",(0,r.jsx)(t.h2,{id:"reference-for-the-red-green-refactor-rgr-workflow",children:'Reference for the "Red, Green, Refactor" (RGR) Workflow'}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.p,{children:'For reference, here\'s the "Red, Green, Refactor" (RGR) workflow we follow with TDD:'}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:"Identify the simplest possible behavior the program must exhibit."}),"\n",(0,r.jsx)(t.li,{children:"Write a coded test for this behavior."}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.font,{color:"red",children:"Before coding, confirm the test fails."})}),"\n",(0,r.jsx)(t.li,{children:"Implement the behavior with the least amount of code possible."}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.font,{color:"green",children:"Run the automated test to confirm it passes. If it doesn't, revisit step 4."})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.font,{color:"green",children:"Confirm all previous tests still pass. If it doesn't, revisit step 4."})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.font,{color:"blue",children:"Check if code can be refactored. If so, refactor and repeat step 6."})}),"\n",(0,r.jsx)(t.li,{children:"Commit your passing code."}),"\n",(0,r.jsx)(t.li,{children:"Repeat this process with the next simplest behavior."}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"1-identify-the-simplest-behavior",children:"1. Identify the Simplest Behavior"}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsxs)(t.p,{children:["What's the simplest possible behavior our program should exhibit? What should a ",(0,r.jsx)(t.code,{children:"Triangle"})," class actually do and how will we create it programmatically?"]}),"\n",(0,r.jsxs)(t.p,{children:["Our ",(0,r.jsx)(t.code,{children:"Triangle"})," class will eventually need to check the type of a triangle, given three sides. That means, we need to save the values of three sides in our ",(0,r.jsx)(t.code,{children:"Triangle"})," class logic. But before we can begin saving three sides to a ",(0,r.jsx)(t.code,{children:"Triangle"})," object, we need to be able to create a ",(0,r.jsx)(t.code,{children:"Triangle"})," object \u2014 that's the simplest behavior our program can exhibit."]}),"\n",(0,r.jsx)(t.p,{children:"Let's start with a test."}),"\n",(0,r.jsx)(t.h2,{id:"2-write-a-coded-test",children:"2. Write a Coded Test"}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsxs)(t.p,{children:["Our test will confirm ",(0,r.jsx)(t.code,{children:"Triangle"})," objects of the ",(0,r.jsx)(t.code,{children:"Triangle"})," type can be created successfully."]}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"ShapeTracker.Solution/ShapeTracker.Tests/ModelTests/TriangleTests.cs"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"using Microsoft.VisualStudio.TestTools.UnitTesting;\nusing ShapeTracker.Models;\n\nnamespace ShapeTracker.Tests\n{\n  [TestClass]\n  public class TriangleTests\n  {\n\n    [TestMethod]\n    public void TriangleConstructor_CreatesInstanceOfTriangle_Triangle()\n    {\n      Triangle newTriangle = new Triangle();\n      Assert.AreEqual(typeof(Triangle), newTriangle.GetType());\n    }\n\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["We declare our test method with the line ",(0,r.jsx)(t.code,{children:"public void TriangleConstructor_CreatesInstanceOfTriangle_Triangle()"}),". MSTest tests are actually methods! Also, they always begin with ",(0,r.jsx)(t.code,{children:"public void"}),":"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["They are ",(0,r.jsx)(t.code,{children:"public"}),", which allows the tools running our tests to access them."]}),"\n",(0,r.jsxs)(t.li,{children:["We add ",(0,r.jsx)(t.code,{children:"void"})," because we don't ",(0,r.jsx)(t.code,{children:"return"})," anything from the tests we write."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["Finally, we include the attribute ",(0,r.jsx)(t.code,{children:"[TestMethod]"})," to identify this method as a test, similar to how we list ",(0,r.jsx)(t.code,{children:"[TestClass]"})," above our ",(0,r.jsx)(t.code,{children:"TriangleTests"})," class in order to identify it as a class of tests."]}),"\n",(0,r.jsx)(t.h3,{id:"test-method-naming-conventions",children:"Test Method Naming Conventions"}),"\n",(0,r.jsx)(t.p,{children:"The naming convention used for test methods is the following:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public void NameOfMethodWeAreTesting_DescriptionOfBehavior_ExpectedReturnValue()\n"})}),"\n",(0,r.jsx)(t.p,{children:"It's a very verbose way of naming tests, however this naming convention is meant to be verbose so that we can clearly understand the goal of the test method just from the name of it."}),"\n",(0,r.jsxs)(t.p,{children:["The name we chose for our first ",(0,r.jsx)(t.code,{children:"Triangle"})," test is ",(0,r.jsx)(t.code,{children:"TriangleConstructor_CreatesInstanceOfTriangle_Triangle()"}),", and that follows the naming convention:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"TriangleConstructor"})," is the method we're testing."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"CreatesInstanceOfTriangle"})," describes the behavior we want our method to have."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"Triangle"})," is the expected return value of the method we're testing."]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"creating-an-assertion",children:"Creating an Assertion"}),"\n",(0,r.jsxs)(t.p,{children:["Within the body of the test method, we do a few things. First, we create an instance of our ",(0,r.jsx)(t.code,{children:"Triangle"})," class with the line ",(0,r.jsx)(t.code,{children:"Triangle newTriangle = new Triangle();"}),". This is the ",(0,r.jsx)(t.strong,{children:"behavior that we are testing"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"Triangle newTriangle = new Triangle();\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Then we write our first ",(0,r.jsx)(t.strong,{children:"assertion"})," using a static MSTest method from the ",(0,r.jsx)(t.code,{children:"Assert"})," class, ",(0,r.jsx)(t.code,{children:"Assert.AreEqual()"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"Assert.AreEqual(typeof(Triangle), newTriangle.GetType());\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"Assert.AreEqual()"})," method checks whether the two arguments provided are equal:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["The first argument is what we ",(0,r.jsx)(t.em,{children:"expect"})," the result of the test to be. ",(0,r.jsx)(t.code,{children:"typeof()"})," returns the data type of a class."]}),"\n",(0,r.jsxs)(t.li,{children:["The second is the expression to be evaluated. ",(0,r.jsx)(t.code,{children:"GetType()"})," returns the data type of a specific object."]}),"\n",(0,r.jsxs)(t.li,{children:["In our case, our assertion is checking if the type of the ",(0,r.jsx)(t.code,{children:"Triangle"})," class matches the type of the ",(0,r.jsx)(t.code,{children:"Triangle"})," instance."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["Let's look at another example of using ",(0,r.jsx)(t.code,{children:"Assert.AreEqual()"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"Assert.AreEqual(true, 1 == 1)\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The above assertion would be a passing test because the first argument ",(0,r.jsx)(t.code,{children:"true"})," is equal to the second argument ",(0,r.jsx)(t.code,{children:"1 == 1"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"3-before-coding-confirm-the-test-fails",children:"3. Before coding, confirm the test fails."}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.p,{children:"We're now ready to move onto the red phase, which is confirming that our test fails before we write any code."}),"\n",(0,r.jsxs)(t.p,{children:["Within the ",(0,r.jsx)(t.code,{children:"ShapeTracker.Tests"})," directory, run the following command:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"$ dotnet test\n"})}),"\n",(0,r.jsx)(t.p,{children:"From the output, we should see a green message highlighting that our new test passed. See the terminal output below, and take note that some of the MSTest terminal output has been omitted for brevity:"}),"\n",(0,r.jsxs)(t.pre,{children:[(0,r.jsx)(t.code,{style:{color:"green"},children:"\nPassed!  - Failed:     0, Passed:     1, Skipped:     0, Total:     1, Duration: 89 ms - ShapeTracker.Tests.dll (net6.0)\n"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Wait... shouldn't this test fail? Does this mean we have a false positive?"}),"\n",(0,r.jsxs)(t.p,{children:["In this case, there are no false positives. Our test passes because we already have an ",(0,r.jsx)(t.code,{children:"Triangle"})," class declared in ",(0,r.jsx)(t.code,{children:"ShapeTracker/Models/Triangle.cs"}),", and an empty class always comes with an implicit constructor that we can use until we explicitly define a constructor. In this case, it's okay that our test has passed immediately, so long as we're making sure that we know why this is happening."]}),"\n",(0,r.jsx)(t.p,{children:"There are other scenarios where our test could pass immediately without there being a false positive. For example, the next test case we write could already be covered in the code we implemented for the last test case. Our job in these situations is simply to verify there are no false positives before we move on."}),"\n",(0,r.jsx)(t.p,{children:"Let's continue onto the next step."}),"\n",(0,r.jsx)(t.h2,{id:"4-implement-the-behavior-with-the-least-amount-of-code-possible",children:"4. Implement the behavior with the least amount of code possible."}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsxs)(t.p,{children:["Next, let's add a simple ",(0,r.jsx)(t.code,{children:"Triangle()"})," constructor:"]}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"ShapeTracker/Models/Triangle.cs"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"namespace ShapeTracker.Models\n{\n  public class Triangle\n  {\n    public Triangle()\n    {\n      \n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"With the above change, we've added an explicit constructor that doesn't actually do anything different than the implicit constructor we had before. However, we'll be updating our constructor as we go along, so we'll want this basic structure in place."}),"\n",(0,r.jsx)(t.p,{children:"Let's continue onto the next step."}),"\n",(0,r.jsx)(t.h2,{id:"5-run-the-automated-test-to-confirm-it-passes",children:"5. Run the automated test to confirm it passes."}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsxs)(t.p,{children:["After implementing business logic code, we'll run our tests again to confirm that our test passes (or in this case ",(0,r.jsx)(t.em,{children:"still"})," passes). Within the ",(0,r.jsx)(t.code,{children:"ShapeTracker.Tests"})," directory, run the following command:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"$ dotnet test\n"})}),"\n",(0,r.jsx)(t.p,{children:"From the output, we should see a green message highlighting that our test is passing. See the terminal output below, and take note that some of the MSTest terminal output has been omitted for brevity:"}),"\n",(0,r.jsxs)(t.pre,{children:[(0,r.jsx)(t.code,{style:{color:"green"},children:"\nPassed!  - Failed:     0, Passed:     1, Skipped:     0, Total:     1, Duration: 187 ms - ShapeTracker.Tests.dll (net6.0)\n"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"6-confirm-previous-tests-still-pass",children:"6. Confirm Previous Tests Still Pass"}),"\n",(0,r.jsx)(t.p,{children:"We don't have any other tests yet so we can advance to the next step."}),"\n",(0,r.jsx)(t.h3,{id:"7-check-for-refactoring",children:"7. Check For Refactoring"}),"\n",(0,r.jsx)(t.p,{children:"Once our code is working and a test passes, we should look for opportunities to improve our code. If we accidentally break something while refactoring, our tests will let us know."}),"\n",(0,r.jsxs)(t.p,{children:["In our case, we only have one test and one very basic constructor, so we can't refactor it further. Even so, it's ",(0,r.jsx)(t.strong,{children:"always important to check"})," if refactoring is possible before moving onto the next behavior."]}),"\n",(0,r.jsx)(t.h2,{id:"8-commit-your-passing-code",children:"8. Commit Your Passing Code!"}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.p,{children:"Remember that making a commit when your code is passing does two important things:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Gives yourself credit for the work you are doing."}),"\n",(0,r.jsx)(t.li,{children:"Acts as a save point that we can revert our code back to if something really goes awry later."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:'Our commit message will be "pass triangle constructor test".'}),"\n",(0,r.jsx)(t.p,{children:"Finally, we're ready for step number 9: Repeat this process with the next simplest behavior."}),"\n",(0,r.jsx)(t.p,{children:"Commit your code now, and then move on to the next lesson to start the RGR workflow over for the next simplest behavior."})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>a});var n=s(96540);const r={},i=n.createContext(r);function o(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);