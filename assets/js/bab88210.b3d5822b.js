"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[65747],{5856:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>h});const o=JSON.parse('{"id":"capstone/capstone-week-1/insertion-sort","title":"\ud83d\udcd3 Insertion Sort","description":"In this lesson, we\'ll take a look at the insertion sort algorithm. This algorithm uses O(n2) time, so it\'s not a good choice for large lists. Interestingly enough, this algorithm isn\'t a bad choice for smaller lists, though. Why is that? Well, some of the algorithms that are efficient for large lists have a high constant while the insertion sort algorithm has a low constant. Think of it like this: if you want to give a letter to your neighbor next door, is it faster to just walk next door or deliver it by mail? It\'s faster to just go next door \u2014 because there is no overhead of a constant to worry about. On the other hand, the further away you need to go to mail a letter, the more it makes sense to send it via the post office instead of hand delivering it.","source":"@site/docs/capstone/1_capstone-week-1/insertion-sort.md","sourceDirName":"capstone/1_capstone-week-1","slug":"/capstone/capstone-week-1/insertion-sort","permalink":"/v1.2/capstone/capstone-week-1/insertion-sort","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":35,"frontMatter":{"title":"\ud83d\udcd3 Insertion Sort","id":"insertion-sort","slug":"insertion-sort","hide_table_of_contents":true,"sidebar_position":35,"day":"thursday","type":"lesson","url":"https://github.com/epicodus-curriculum/capstone/blob/main/insertion_sort.md"},"sidebar":"capstone","previous":{"title":"\ud83d\udcd3 Binary Search Algorithm","permalink":"/v1.2/capstone/capstone-week-1/binary-search-algorithm"},"next":{"title":"\ud83d\udcd3 Selection Sort","permalink":"/v1.2/capstone/capstone-week-1/selection-sort"}}');var i=n(74848),r=n(28453);const s={title:"\ud83d\udcd3 Insertion Sort",id:"insertion-sort",slug:"insertion-sort",hide_table_of_contents:!0,sidebar_position:35,day:"thursday",type:"lesson",url:"https://github.com/epicodus-curriculum/capstone/blob/main/insertion_sort.md"},a=void 0,l={},h=[{value:"Clues",id:"clues",level:3},{value:"Solution",id:"solution",level:3}];function d(e){const t={code:"code",em:"em",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",sup:"sup",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["In this lesson, we'll take a look at the ",(0,i.jsx)(t.strong,{children:"insertion sort"})," algorithm. This algorithm uses O(n",(0,i.jsx)(t.sup,{children:"2"}),") time, so it's not a good choice for large lists. Interestingly enough, this algorithm isn't a bad choice for smaller lists, though. Why is that? Well, some of the algorithms that are efficient for large lists have a high constant while the insertion sort algorithm has a low constant. Think of it like this: if you want to give a letter to your neighbor next door, is it faster to just walk next door or deliver it by mail? It's faster to just go next door \u2014 because there is no overhead of a constant to worry about. On the other hand, the further away you need to go to mail a letter, the more it makes sense to send it via the post office instead of hand delivering it."]}),"\n",(0,i.jsxs)(t.p,{children:["So how does the insertion sort work? Well, we can think of it as separating a collection into two parts. The first part is a sorted section and the second is an unsorted section. At first, the sorted part is just the first item in the collection. Let's take a look at an example that uses the array ",(0,i.jsx)(t.code,{children:"[9,5,7,3,15,12]"}),"."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"The illustration shows what will happen each time through the loop.",src:n(53484).A+"",width:"681",height:"931"})}),"\n",(0,i.jsxs)(t.p,{children:["The first time through the loop, the algorithm takes the first element in the unsorted section and then determines where it should go in the sorted section. Right now, the sorted section is only one element ",(0,i.jsx)(t.code,{children:"[9]"}),". Meanwhile, the unsorted section is the rest of the array. The first element of the unsorted section is ",(0,i.jsx)(t.code,{children:"5"}),". So the algorithm will insert the ",(0,i.jsx)(t.code,{children:"5"})," before the ",(0,i.jsx)(t.code,{children:"9"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Now the sorted section is ",(0,i.jsx)(t.code,{children:"[5,9]"})," while the unsorted section is ",(0,i.jsx)(t.code,{children:"[7,3,15,12]"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The second time through the loop, the current index will be ",(0,i.jsx)(t.code,{children:"7"}),". So we'll iterate through the sorted section until we determine where it should go. It happens to be in the second position."]}),"\n",(0,i.jsxs)(t.p,{children:["That makes the sorted section ",(0,i.jsx)(t.code,{children:"[5,7,9]"})," while the unsorted section is ",(0,i.jsx)(t.code,{children:"[3,15,12]"}),". You can look at the illustration to see how the rest of the process should go."]}),"\n",(0,i.jsx)(t.p,{children:"You'll see that there is one iteration where the algorithm knows it doesn't need to swap because the value it's checking is already sorted. How does it know? It just needs to check the last value of the sorted section. If the value that it's comparing is higher than that value, we know it needs to go at the end of the sorted section. No insertion necessary!"}),"\n",(0,i.jsxs)(t.p,{children:["So this might seem relatively easy, right? Well, there's one thing that's tricky. There's no method that just inserts an element between two other elements in an array. It's easy to ",(0,i.jsx)(t.em,{children:"replace"})," an element \u2014 such as with splice. But ",(0,i.jsx)(t.em,{children:"adding"})," an element to the middle of the array is trickier. It involves ",(0,i.jsx)(t.em,{children:"shifting"})," every element that should come after the inserted element to the right. There are a lot of ways to do that, fortunately."]}),"\n",(0,i.jsx)(t.p,{children:"Now that you know how an insertion sort algorithm should work, it's time to try to write your own. We recommend implementing TDD though you can also try to whiteboard the solution as well. This one can actually be fairly tricky to solve."}),"\n",(0,i.jsx)(t.p,{children:"If you are stumped, read a clue below and then continue trying to solve the problem. This is what would happen in an actual technical interview \u2014 an interviewer might prompt you, which could help you get to the next step."}),"\n",(0,i.jsx)(t.p,{children:"If the clue isn't helpful because you've already solved that part of the equation, go to the next clue."}),"\n",(0,i.jsx)(t.h3,{id:"clues",children:"Clues"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Clue #1:"})," You will need two loops \u2014 an outer loop and an inner loop. The outer loop always starts with the first value of the unsorted section of the array. Since we can consider the first element of the array to be a sorted section of one element, that means our outer loop should start with an index of 1."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"for (let index = 1; index < array.length; index++) {\n    // Code omitted...\n  }\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Clue #2:"})," What value do we need to insert in the ordered section of the array? That would be ",(0,i.jsx)(t.code,{children:"array[index]"}),", which we'll call ",(0,i.jsx)(t.code,{children:"valueToInsert"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"let valueToInsert = array[index];\n"})}),"\n",(0,i.jsxs)(t.p,{children:["How should we determine where ",(0,i.jsx)(t.code,{children:"valueToInsert"})," should go in the sorted section? Should we work from the front of the sorted section or the end of the sorted section? Well, remember that when we insert ",(0,i.jsx)(t.code,{children:"valueToInsert"}),", we also need to ",(0,i.jsx)(t.em,{children:"shift"})," all elements after it one index ",(0,i.jsx)(t.em,{children:"to the right"}),". So if we start at the beginning of the sorted section, we'll first have to find where to insert the element \u2014 and then we'll have to continue iterating, shifting all elements after it. It would be better to work ",(0,i.jsx)(t.em,{children:"backwards"})," instead, shifting elements to the right as we find where to insert ",(0,i.jsx)(t.code,{children:"valueToInsert"}),". As an analogy, imagine that you want to insert a book on a shelf where there is only room for one book. You look at the last book on the shelf \u2014 and if the book should go before that, you move that book to the right so there is a new space for the inserted book to go. You keep moving books to the right until you find the correct space for the inserted book. Because you've been shifting books to the right, you have a space for it available."]}),"\n",(0,i.jsxs)(t.p,{children:["Because our inner loop should work ",(0,i.jsx)(t.em,{children:"from the end"})," of the sorted section, that means we'd start at ",(0,i.jsx)(t.code,{children:"index-1"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"let indexOfSortedSection = index -1;\n"})}),"\n",(0,i.jsx)(t.p,{children:"So our code so far would look like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"for (let index = 1; index < array.length; index++) {\n  let indexOfSortedSection = index - 1;\n  let valueToInsert = array[index];\n  // We will need an inner loop here that starts at array[indexOfSortedSection] and works backwards through the sorted section of the array until it finds where valueToInsert should go.\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Clue #3:"})," What should our inner loop look like? Well, we could use a while loop. (Note we could use a ",(0,i.jsx)(t.code,{children:"for"})," loop as well.) As long as ",(0,i.jsx)(t.code,{children:"array[indexOfSortedSection] > valueToInsert"}),", we need to keep moving to the right. Remember, we want our numbers all in order \u2014 and currently ",(0,i.jsx)(t.code,{children:"valueToInsert"})," is to the right of ",(0,i.jsx)(t.code,{children:"array[indexOfSortedSection]"}),". That means the numbers will be out of order still. Once ",(0,i.jsx)(t.code,{children:"valueToInsert"})," is greater than or equal to ",(0,i.jsx)(t.code,{children:"array[indexOfSortedSection]"}),", we know we've found the right place."]}),"\n",(0,i.jsx)(t.p,{children:"So here's the code up to this point:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"for (let index = 1; index < array.length; index++) {\n  let indexOfSortedSection = index - 1;\n  let valueToInsert = array[index];\n  while ((array[indexOfSortedSection] > valueToInsert)) {\n    // What should we do while this condition is true?\n  }\n  // And finally, what should we do once we've found the correct place for valueToInsert to go?\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Clue #4:"})," At this point, you might be struggling to figure out what goes inside the while loop. Well, remember, if the condition in the loop is true, we need to move the element ",(0,i.jsx)(t.em,{children:"to the right"}),". We will also need to decrement the value of ",(0,i.jsx)(t.code,{children:"indexOfSortedSection"})," after we are done because we aren't using a ",(0,i.jsx)(t.code,{children:"for"})," loop to do it for us."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"while ((array[indexOfSortedSection] > valueToInsert)) {\n  let newValue = array[indexOfSortedSection];\n  array[indexOfSortedSection + 1 ] = newValue;\n  indexOfSortedSection--\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Here, we are saying, ",(0,i.jsx)(t.em,{children:"hey, we still haven't found the correct place to insert our value. Let's shift this element one spot to the right."})," To do that, we first get the value of the current element in the sorted section. Then we assign the ",(0,i.jsx)(t.em,{children:"next"})," element in the array that collection. It's kind of like moving our books to create a space \u2014 though what we are actually doing is replacing the value at the next index with the value at the current index. You might be wondering how we aren't losing any data this way. Well, we saved ",(0,i.jsx)(t.code,{children:"valueToInsert"})," in a variable \u2014 so when we overwrite that element, it doesn't matter since we have the data saved. We will always shift an element one over to the right before we overwrite it. And the first time we do that, as we just mentioned, is when we overwrite the element that we've stored in ",(0,i.jsx)(t.code,{children:"valueToInsert"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Clue #5:"})," This code is still missing one thing \u2014 we never actually insert ",(0,i.jsx)(t.code,{children:"valueToInsert"})," anywhere! We actually need to do this after we finish the while loop. This is what we need:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"while ((array[indexOfSortedSection] > valueToInsert)) {\n  let newValue = array[indexOfSortedSection];\n  array[indexOfSortedSection + 1 ] = newValue;\n  indexOfSortedSection--\n}\narray[indexOfSortedSection + 1] = valueToInsert;\n"})}),"\n",(0,i.jsx)(t.p,{children:"The key line is the final one:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"array[indexOfSortedSection + 1] = valueToInsert;\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Why do the insert at ",(0,i.jsx)(t.code,{children:"array[indexOfSortedSection + 1]"}),"? Well, each time through the while loop, we decrement the index with ",(0,i.jsx)(t.code,{children:"indexOfSortedSection--"}),". Once we've verified that the previous element ",(0,i.jsx)(t.em,{children:"isn't"})," greater than ",(0,i.jsx)(t.code,{children:"valueToInsert"}),", we need to insert the value after the previous element."]}),"\n",(0,i.jsx)(t.h3,{id:"solution",children:"Solution"}),"\n",(0,i.jsx)(t.p,{children:"Here's the full solution to the problem:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"function insertionSort(array) {\n  for (let index = 1; index < array.length; index++) {\n    let indexOfSortedSection = index - 1;\n    let valueToInsert = array[index];\n    while ((array[indexOfSortedSection] > valueToInsert)) {\n      let newValue = array[indexOfSortedSection];\n      array[indexOfSortedSection + 1 ] = newValue;\n      indexOfSortedSection--\n    }\n    array[indexOfSortedSection + 1] = valueToInsert;\n  }\n  return array;\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Our algorithm takes an array as an argument. It essentially separates the array into two sections \u2014 the first sorted, the second unsorted. Since the sorted section is always the first element, that's why our outer loop, which sorts through the unsorted section, starts at an index of 1. It will always run through the entire array \u2014 that is, until ",(0,i.jsx)(t.code,{children:"index < array.length"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Since ",(0,i.jsx)(t.code,{children:"index"})," is always the first element of the unsorted section, that means that ",(0,i.jsx)(t.code,{children:"index - 1"})," is the last element of the unsorted section. We are going to work our way ",(0,i.jsx)(t.em,{children:"backwards"})," through the unsorted section. We discussed why in the clues and we'll cover the reason again in a moment."]}),"\n",(0,i.jsx)(t.p,{children:"For our inner loop, we need to keep track of two things:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The current index of the sorted section. We initialize this by doing the following:"}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"let indexOfSortedSection = index - 1;\n"})}),"\n",(0,i.jsx)(t.p,{children:"Remember, we are working backwards through the array so we need to start with the last element in the unsorted section."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The value we need to insert in our array. This is the value at ",(0,i.jsx)(t.code,{children:"array[index]"}),":"]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"let valueToInsert = array[index];\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Next, we have our while loop. Our while loop is going to ",(0,i.jsx)(t.em,{children:"shift"})," elements to the right as it looks for where the ",(0,i.jsx)(t.code,{children:"valueToInsert"})," needs to be inserted. As long as ",(0,i.jsx)(t.code,{children:"array[indexOfSortedSection] > valueToInsert"}),", our loop will keep running. This condition states that as long as the element in our sorted array is greater than the value we need to insert, we need to keep shifting elements to the right. We can clarify this with a little example."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"// Unsorted Section\n\n[3, 5, 8, 14] \n\n// Value to Insert\n\n12\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In the example above, we don't want ",(0,i.jsx)(t.code,{children:"12"})," to be inserted at the end of the sorted section. We need to shift the last value in the sorted section (",(0,i.jsx)(t.code,{children:"14"}),") to the right and then check again:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"// Unsorted Section\n\n[3, 5, 8, ..., 14]\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We can see now that ",(0,i.jsx)(t.code,{children:"12"})," (",(0,i.jsx)(t.code,{children:"valueToInsert"}),") is greater than ",(0,i.jsx)(t.code,{children:"array[indexOfSortedSection]"})," (",(0,i.jsx)(t.code,{children:"8"}),"), which means we've found the right spot to insert the value!"]}),"\n",(0,i.jsx)(t.p,{children:"To actually shift values to the right, we do the following:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"let newValue = array[indexOfSortedSection];\narray[indexOfSortedSection + 1 ] = newValue;\nindexOfSortedSection--\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We set the value of the ",(0,i.jsx)(t.em,{children:"next"})," index to the current index's value \u2014 essentially shifting it one to the right. For just a moment, the current index and the next index will be the same \u2014 but the current index will soon be overwritten, either by the value we want to insert (if we've found the right place for it) or the next element that needs to be shifted to the right. Remember, the very first time this happens, the element that we grabbed ",(0,i.jsx)(t.code,{children:"valueToInsert"})," from will be overwritten. That's why we need to save its value in the variable ",(0,i.jsx)(t.code,{children:"valueToInsert"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["By the way, if the value to insert doesn't need to be moved, our algorithm will see that right away because the conditional in the while loop will be met \u2014 so the inner loop wouldn't be activated. For that reason, in the ",(0,i.jsx)(t.em,{children:"best case scenario"}),", this algorithm is actually O(n). The best case scenario is that the algorithm is sorting a fully sorted or nearly sorted array \u2014 which means the inner loop will rarely be used. Of course, we probably wouldn't be trying to sort arrays that are already sorted \u2014 so the best case scenario wouldn't happen very often."]}),"\n",(0,i.jsx)(t.p,{children:"After our while loop shifts an element to the right, it decrements the index of the sorted section:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"indexOfSortedSection--\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Here's something a little weird about our algorithm. What if we need to insert something in the first position of our array? Well, ",(0,i.jsx)(t.code,{children:"indexOfSortedSection"})," will be decremented to ",(0,i.jsx)(t.code,{children:"-1"}),". Fortunately, the following is ",(0,i.jsx)(t.code,{children:"false"}),", which will cause our while loop to end:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"undefined > valueToInsert\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This is a bit weird and we can avoid comparing it to ",(0,i.jsx)(t.code,{children:"undefined"})," by doing the following:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"...\nwhile ((indexOfSortedSection >= 0) && (array[indexOfSortedSection] > valueToInsert)) {\n...\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This would ensure that we never compare it to ",(0,i.jsx)(t.code,{children:"undefined"})," \u2014 though it ultimately amounts to the same thing."]}),"\n",(0,i.jsxs)(t.p,{children:["Finally, once we've determined where we should insert ",(0,i.jsx)(t.code,{children:"valueToInsert"}),", we do so with the following:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"array[indexOfSortedSection + 1] = valueToInsert;\n"})}),"\n",(0,i.jsxs)(t.p,{children:["That's because when we determine that ",(0,i.jsx)(t.code,{children:"valueToInsert"})," is greater than ",(0,i.jsx)(t.code,{children:"array[indexOfSortedSection]"}),", we have to put the value ",(0,i.jsx)(t.em,{children:"after"})," ",(0,i.jsx)(t.code,{children:"array[indexOfSortedSection]"})," \u2014 in other words, ",(0,i.jsx)(t.code,{children:"array[indexOfSortedSection + 1]"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Once this is all done, the array will be sorted and we can return it. While this algorithm is generally fairly slow, it is not too inefficient with smaller collections \u2014 and can be faster than better algorithms if the collection is small enough. We also don't need to worry about space because it will switch values in-place."}),"\n",(0,i.jsx)(t.p,{children:"As we mentioned earlier, this algorithm can be a bit confusing at first. If you weren't able to figure out how to write it on your own \u2014 or are still feeling confused \u2014 we recommend trying it out in a VS Code Jest environment, adding a breakpoint to step through the code so you can see what happens on each line."})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var o=n(96540);const i={},r=o.createContext(i);function s(e){const t=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:t},e.children)}},53484:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/insertion-sort-337de8c42d9777fc26d0ef1f8af1cdf0.png"}}]);