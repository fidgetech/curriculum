"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[36488],{6939:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/pivot-point-dcff9dea89ac81d87f30dd17ac4243af.png"},9480:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/second-comparison-54d77edc75b4a6821d6162e8cf1149a5.png"},28453:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>a});var n=i(96540);const o={},r=n.createContext(o);function s(e){const t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(r.Provider,{value:t},e.children)}},30964:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/quicksort-pointers-dd01f97b38e7a8f1b2ba1d1a6da0e449.png"},38504:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"capstone/capstone-week-1/quicksort","title":"\ud83d\udcd3 Quicksort","description":"In this lesson, we\'ll learn about the quicksort algorithm, which is a divide and conquer algorithm like merge sort. The quicksort algorithm is generally faster with smaller data sets, while the merge sort algorithm is faster with large data sets.","source":"@site/docs/capstone/1_capstone-week-1/quicksort.md","sourceDirName":"capstone/1_capstone-week-1","slug":"/capstone/capstone-week-1/quicksort","permalink":"/v1.2/capstone/capstone-week-1/quicksort","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":39,"frontMatter":{"title":"\ud83d\udcd3 Quicksort","id":"quicksort","slug":"quicksort","hide_table_of_contents":true,"sidebar_position":39,"day":"thursday","type":"lesson","url":"https://github.com/epicodus-curriculum/capstone/blob/main/quick_sort.md"},"sidebar":"capstone","previous":{"title":"\ud83d\udcd3 Merge Sort","permalink":"/v1.2/capstone/capstone-week-1/merge-sort"},"next":{"title":"\ud83d\udcd3 Linked Lists","permalink":"/v1.2/capstone/capstone-week-1/linked-lists"}}');var o=i(74848),r=i(28453);const s={title:"\ud83d\udcd3 Quicksort",id:"quicksort",slug:"quicksort",hide_table_of_contents:!0,sidebar_position:39,day:"thursday",type:"lesson",url:"https://github.com/epicodus-curriculum/capstone/blob/main/quick_sort.md"},a=void 0,l={},h=[{value:"Writing a Quicksort Algorithm",id:"writing-a-quicksort-algorithm",level:2},{value:"Finding the Pivot",id:"finding-the-pivot",level:3},{value:"Swapping Values",id:"swapping-values",level:3},{value:"Sorting a Partition in an Array",id:"sorting-a-partition-in-an-array",level:3},{value:"Writing a Recursive <code>quickSort()</code> Function",id:"writing-a-recursive-quicksort-function",level:3}];function c(e){const t={a:"a",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["In this lesson, we'll learn about the ",(0,o.jsx)(t.strong,{children:"quicksort algorithm"}),", which is a divide and conquer algorithm like merge sort. The quicksort algorithm is generally faster with smaller data sets, while the merge sort algorithm is faster with large data sets."]}),"\n",(0,o.jsx)(t.p,{children:"If you thought that merge sort was a bit complex, the quicksort algorithm is yet another step up in difficulty. Let's take a look at how it works \u2014 and then we'll write a modified and slightly simpler version ourselves."}),"\n",(0,o.jsx)(t.p,{children:"A quicksort algorithm randomly finds a pivot point in a collection. It then adds pointers before and after the pivot point and swaps them as needed. It's easier to show how this works with a graphic."}),"\n",(0,o.jsxs)(t.p,{children:["First, the quicksort algorithm ",(0,o.jsx)(t.em,{children:"randomly"})," finds a pivot point."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"This graphic shows a collection of 7 elements. The pivot point is the fifth element, which is 9.",src:i(6939).A+"",width:"801",height:"150"})}),"\n",(0,o.jsxs)(t.p,{children:["A good quicksort algorithm has built-in ways to intelligently determine a good random pivot point (so it's not entirely random). That is beyond the scope of this lesson, though, both because it's hard to test randomness and also because it involves a good understanding of probability theory. All you really need to know is that this randomness, if applied correctly, actually makes a quicksort algorithm ",(0,o.jsx)(t.em,{children:"faster"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["In the image above, the fifth element (which holds the value ",(0,o.jsx)(t.code,{children:"9"}),") is the pivot point. Again, this is randomly determined \u2014 it's not the middle element \u2014 nor does it even need to be near the middle. It could be the first element in the array, the last, or any other element."]}),"\n",(0,o.jsx)(t.p,{children:"Next, we add pointers to the leftmost and rightmost elements of the collection."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"The algorithm compares the value at the left and right pointers to the pivot point.",src:i(30964).A+"",width:"801",height:"150"})}),"\n",(0,o.jsxs)(t.p,{children:["The values at each pointer are compared to the value at the pivot point. The value at the left pointer is ",(0,o.jsx)(t.code,{children:"11"}),", which is greater than the pivot point's value, which is ",(0,o.jsx)(t.code,{children:"9"}),". Meanwhile, the value at the right pointer is ",(0,o.jsx)(t.code,{children:"3"}),", which is less than the pivot point's value. That means we can swap the values and move the pointers inward one spot each."]}),"\n",(0,o.jsx)(t.p,{children:"The second iteration through the algorithm, the collection looks like this:"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"The first and last values have been swapped and the pointers have moved one spot inward.",src:i(9480).A+"",width:"801",height:"150"})}),"\n",(0,o.jsxs)(t.p,{children:["As we can see, the first and last values of the collection have been swapped. The pointers have each moved inward one position. We do the same comparison again. ",(0,o.jsx)(t.code,{children:"13"})," is greater than the pivot point while ",(0,o.jsx)(t.code,{children:"7"})," is less than the pivot point. We can swap again."]}),"\n",(0,o.jsx)(t.p,{children:"The pointers will be moved inward another position. Since the right pointer is now on the pivot point \u2014 and the pivot point is neither less than or greater than itself \u2014 the pointer will skip to the next position to evaluate. So here's where we're at now:"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Once again we&#39;ve swapped values and moved the pointers inward.",src:i(83723).A+"",width:"801",height:"150"})}),"\n",(0,o.jsxs)(t.p,{children:["Now we are comparing ",(0,o.jsx)(t.code,{children:"12"})," and ",(0,o.jsx)(t.code,{children:"6"})," \u2014 since the left pointer is pointing at a value greater than the pivot point and the right pointer is pointing at a value less than the pivot point, we can swap again."]}),"\n",(0,o.jsx)(t.p,{children:"Once our pointers intersect, we are finished with our first round of sorting."}),"\n",(0,o.jsx)(t.p,{children:"Our collection is now a bit more sorted than it was. Every value on the left side of the collection (up to our left pointer) is less than the value at our pivot point. Meanwhile, every value on the right side of our collection (from our right pointer to the end of the collection) is greater than the pivot point."}),"\n",(0,o.jsx)(t.p,{children:"Now it's time for our second round of sorting. This is where the divide and conquer approach comes in. We now perform the exact same operations on our left and right sub-arrays. The illustration below demonstrates this next step."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"We are now going to sort two partitions.",src:i(59875).A+"",width:"818",height:"212"})}),"\n",(0,o.jsx)(t.p,{children:"As we can see, we now have a left array and a right array \u2014 which are divided based on where the left and right pointers met when we finished our first round of sorting."}),"\n",(0,o.jsx)(t.p,{children:"Once again, we add a pivot point and then place pointers at both the left and rightmost elements of each sub-array. Then we go through the sorting process again."}),"\n",(0,o.jsxs)(t.p,{children:["As you can see from the left sub-array in the illustration above, a swap won't always occur. The value at the left pointer (",(0,o.jsx)(t.code,{children:"3"}),") is less than the value at the pivot point (",(0,o.jsx)(t.code,{children:"7"}),") so it will not be swapped with the value at the right pointer even though the value at the right pointer (",(0,o.jsx)(t.code,{children:"6"}),") is also less than the value at the pivot point. Since both conditions aren't met, there can be no swap."]}),"\n",(0,o.jsx)(t.p,{children:"Over time, this dividing and conquering and swapping of values progressively reorganizes the array until it's fully sorted. It may still be hard to visualize how this array will be completely sorted based on where we're currently at. That's partly because on our second round of sorting, we happened to pick terrible pivot points. Each pivot point is higher than every value in its sub-array, which means that there will be no actual sorting occurring in this round. That will happen sometimes, and it's important to avoid picking bad pivot points if possible. There is no perfect way to find efficient pivot points \u2014 and as we mentioned already, it's actually more efficient to find those pivot points randomly \u2014 even though the randomness means sometimes there will be bad pivot points."}),"\n",(0,o.jsx)(t.p,{children:"Let's use TDD to write a quicksort algorithm. This will hopefully clarify any lingering questions you might have about how the algorithm works."}),"\n",(0,o.jsx)(t.h2,{id:"writing-a-quicksort-algorithm",children:"Writing a Quicksort Algorithm"}),"\n",(0,o.jsx)(t.p,{children:"We'll start by writing several smaller functions, gradually bringing them all together in a control function that we can call recursively. Because our approach is to divide and conquer, just as we did with our merge sort function, a recursive solution will be most effective. That's because we'll need to call the same function over and over on each array and partitioned sub-array."}),"\n",(0,o.jsx)(t.h3,{id:"finding-the-pivot",children:"Finding the Pivot"}),"\n",(0,o.jsxs)(t.p,{children:["First, let's write a test for a ",(0,o.jsx)(t.code,{children:"findPivot()"})," function. A more complex and efficient implementation would randomize the pivot, but we are going to keep it simple. Probably the easiest thing we could do is make the pivot point either the first or last element in an array. However, this would make our algorithm horribly inefficient if the array is already sorted. Why is that? Well, the worst possible pivot point is one where ",(0,o.jsx)(t.em,{children:"every"})," value is either greater than the pivot point (which would happen if we use the first value of a sorted array) or less than the pivot point (which would happen if we use the last value of a sorted array). While we can't assume that arrays will be sorted, sometimes they are. For that reason, we will use the middle element of an array as the pivot point."]}),"\n",(0,o.jsxs)(t.p,{children:["Before we write our test, let's take a moment to think about the parameters of our ",(0,o.jsx)(t.code,{children:"findPivot()"})," function. Obviously, we'll need to pass in an array so it can find the pivot point. However, unlike with our merge sort algorithm, we aren't actually going to split up arrays into smaller sub-arrays and then merge them again. Instead, we are going to organize the sub-arrays in place. That means we also need parameters for the first and last elements of the sub-array where we need to find a pivot. Let's take another look at the illustration from above:"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"We are now going to sort two partitions.",src:i(59875).A+"",width:"818",height:"212"})}),"\n",(0,o.jsx)(t.p,{children:"As we can see, there are pointers at the left and right element of each sub-array. We can determine where the pivot point should go based on these pointers."}),"\n",(0,o.jsxs)(t.p,{children:["Our function should take the following parameters: ",(0,o.jsx)(t.code,{children:"findPivot(array, leftPointer, rightPointer)"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"Now we're ready for a test."}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"__tests__/quicksort.test.js"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"import { findPivot } from '../src/quicksort.js';\n\ndescribe('quicksort functions', () => {\n\n  test('it will find a pivot point halfway through the array', () => {\n    const array = [1,6,9];\n    const leftPointer = 0;\n    const rightPointer = 2;\n    expect(findPivot(array, leftPointer, rightPointer)).toEqual(6);\n  });\n});\n"})}),"\n",(0,o.jsxs)(t.p,{children:["In the test above, we create an array of three elements. We also establish where the ",(0,o.jsx)(t.code,{children:"leftPointer"})," is (the first element of the array) as well as the ",(0,o.jsx)(t.code,{children:"rightPointer"})," (the last element of the array). It's a few extra lines of code to store the pointers in separate variables, but we do so to make it clear exactly what's happening here."]}),"\n",(0,o.jsxs)(t.p,{children:["When we call our ",(0,o.jsx)(t.code,{children:"findPivot()"})," function, it should determine the pivot based on these parameters. Note that we expect the function to return the ",(0,o.jsx)(t.em,{children:"value"})," of the element at the pivot point, not its ",(0,o.jsx)(t.em,{children:"position"}),". That's because we will be comparing all the other values in the array to the pivot, determining whether that value should go to the left or the right. We don't actually care about the position of the pivot itself."]}),"\n",(0,o.jsx)(t.p,{children:"Let's get this test passing:"}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"src/quicksort.js"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"export function findPivot(array, leftPointer, rightPointer) {\n  return array[Math.floor((leftPointer + rightPointer)/2)];\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This function simply finds the midpoint of the array based on the ",(0,o.jsx)(t.code,{children:"leftPointer"})," and ",(0,o.jsx)(t.code,{children:"rightPointer"})," values. Then it returns the value of the element at that position in the array."]}),"\n",(0,o.jsx)(t.h3,{id:"swapping-values",children:"Swapping Values"}),"\n",(0,o.jsx)(t.p,{children:"Now that our first test is passing, we're ready to start working on our next function. A quicksort algorithm needs to be able to swap two elements. However, in order to do so, it needs to temporarily store the value of one of the elements in a variable. Otherwise, that information will get lost during the swap. We've done the same thing with other algorithms in the past, but this time we are actually separating this out into its own little function. This will help make the bulk of our quicksort code easier to understand when we get to it."}),"\n",(0,o.jsxs)(t.p,{children:["So the next step is to write a ",(0,o.jsx)(t.code,{children:"swap()"})," function that will take the values at a ",(0,o.jsx)(t.code,{children:"leftPointer"})," and ",(0,o.jsx)(t.code,{children:"rightPointer"})," and swap them. This function won't determine whether or not two values should be swapped \u2014 it will mindlessly do its work when called. This also follows good TDD principles \u2014 we don't care yet about whether two values ",(0,o.jsx)(t.em,{children:"should"})," be swapped \u2014 just that we have the functionality so we can swap them."]}),"\n",(0,o.jsx)(t.p,{children:"Here's our next test (don't forget to import the new function):"}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"__tests__/quicksort.test.js"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"import { findPivot, swap } from '../src/quicksort.js';\n\ndescribe('quicksort functions', () => {\n\n  ...\n\n  test('it will swap two values in an array', () => {\n    let array = [6,9,3,1,5];\n    const leftPointer = 0;\n    const rightPointer = 3;\n    expect(swap(array, leftPointer, rightPointer)).toEqual([1,9,3,6,5]);\n  });\n});\n"})}),"\n",(0,o.jsxs)(t.p,{children:["In this test, we create an array along with a ",(0,o.jsx)(t.code,{children:"leftPointer"})," and ",(0,o.jsx)(t.code,{children:"rightPointer"})," value. Our ",(0,o.jsx)(t.code,{children:"swap()"})," function will simply swap the values at the two pointers."]}),"\n",(0,o.jsx)(t.p,{children:"Here's the code to get this test passing:"}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"src/quicksort.js"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"export function swap(array, leftPointer, rightPointer){\n  const valueToReplace = array[leftPointer];\n  array[leftPointer] = array[rightPointer];\n  array[rightPointer] = valueToReplace;\n  return array;\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This function should be familiar based on other algorithms we've written. We create a variable called ",(0,o.jsx)(t.code,{children:"valueToReplace"})," to temporarily store the value at the left pointer. Then we can replace the value at the left pointer with the value at the right pointer. Finally, we can update the value at the right pointer with ",(0,o.jsx)(t.code,{children:"valueToReplace"}),". Lastly, we'll return the array. This will get our test passing."]}),"\n",(0,o.jsx)(t.h3,{id:"sorting-a-partition-in-an-array",children:"Sorting a Partition in an Array"}),"\n",(0,o.jsxs)(t.p,{children:["Next, we'll write a function to sort an array or sub-array. This function will use both our ",(0,o.jsx)(t.code,{children:"swap()"})," and ",(0,o.jsx)(t.code,{children:"findPivot()"})," functions. This function will be called ",(0,o.jsx)(t.code,{children:"sortPartition()"}),". We use the term ",(0,o.jsx)(t.strong,{children:"partition"})," here because our divide and conquer approach will separate our array into smaller and smaller partitions. This is in contrast to a merge algorithm, which breaks down an array into smaller sub-arrays."]}),"\n",(0,o.jsx)(t.p,{children:"The goal of this function will simply be to sort a partition based on its pivot point. Note that we don't expect it to fully sort a partition \u2014 we just expect it to do one passthrough where it swaps values based on the pivot. For instance, let's say we have the following array:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"[5, 1, 3, 2, 7]\n"})}),"\n",(0,o.jsxs)(t.p,{children:["We'll say the pivot is ",(0,o.jsx)(t.code,{children:"3"}),". Based on that, we know we'd want to swap ",(0,o.jsx)(t.code,{children:"5"})," to the right side because it's less than the pivot. However, we wouldn't swap ",(0,o.jsx)(t.code,{children:"7"})," because it's already where it needs to be \u2014 so the right pointer would move left to ",(0,o.jsx)(t.code,{children:"2"}),", which should be swapped. The ",(0,o.jsx)(t.code,{children:"2"})," and the ",(0,o.jsx)(t.code,{children:"5"})," would then be swapped."]}),"\n",(0,o.jsx)(t.p,{children:"That would leave our array looking like this."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"[2, 1, 3, 5, 7]\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The left pointer and right pointer would then each move inward one position, meaning ",(0,o.jsx)(t.code,{children:"1"})," and ",(0,o.jsx)(t.code,{children:"3"})," would be compared. There'd be no other swaps."]}),"\n",(0,o.jsx)(t.p,{children:"Here's our new test (once again, don't forget we'll need to import an additional function):"}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"__tests__/quicksort.test.js"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"import { findPivot, swap, sortPartition } from '../src/quicksort.js';\n\ndescribe('quicksort functions', () => {\n\n  ...\n\n  test('it will sort and swap values in an array based on a pivot point', () => {\n    const array = [5, 1, 3, 2, 7];\n    const leftPointer = 0;\n    const rightPointer = 4;\n    expect(sortPartition(array, leftPointer, rightPointer)).toEqual([2, 1, 3, 5, 7]);\n  });\n});\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Our ",(0,o.jsx)(t.code,{children:"sortPartition()"})," function will sort an array (or partition in an array) based on its ",(0,o.jsx)(t.code,{children:"leftPointer"})," and ",(0,o.jsx)(t.code,{children:"rightPointer"}),". In this case, the partition is the whole array \u2014 but our function will have the flexibility to work with partitions of any size within an array."]}),"\n",(0,o.jsx)(t.p,{children:"Let's get this test passing. This function is going to do some heavy lifting."}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"src/quicksort.js"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"...\n\nexport function sortPartition(array, leftPointer, rightPointer) {\n  const pivot = findPivot(array, leftPointer, rightPointer);\n  while (leftPointer <= rightPointer) {\n    while (array[leftPointer] < pivot) {\n      leftPointer++;\n    }\n    while (array[rightPointer] > pivot) {\n        rightPointer--;\n    }\n    if (leftPointer <= rightPointer) {\n      array = swap(array, leftPointer, rightPointer);\n      leftPointer++;\n      rightPointer--;\n    }\n  }\n  return array;\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Our ",(0,o.jsx)(t.code,{children:"sortPartition()"})," function takes three parameters. The first is the full ",(0,o.jsx)(t.code,{children:"array"}),". The second and third are the pointers. These pointers will determine the beginning and the end of the partition."]}),"\n",(0,o.jsxs)(t.p,{children:["The first thing our new function will do is determine the ",(0,o.jsx)(t.code,{children:"pivot"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"const pivot = findPivot(array, leftPointer, rightPointer);\n"})}),"\n",(0,o.jsx)(t.p,{children:"Fortunately, we've already written a function to find the pivot for us!"}),"\n",(0,o.jsxs)(t.p,{children:["Next, we have a while loop that will run as long as the ",(0,o.jsx)(t.code,{children:"leftPointer <= rightPointer"}),". All this means is that the loop will keep running until the left and right pointer intersect. When the two pointers intersect, that means we've swapped all the values we can and it's time to return the array."]}),"\n",(0,o.jsx)(t.p,{children:"Within this while loop, we have two more while loops. The first while loop runs while the left pointer is less than or equal to the pivot:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"while (array[leftPointer] < pivot) {\n  leftPointer++;\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This loop will move the ",(0,o.jsx)(t.code,{children:"leftPointer"})," inward until it finds a value that is greater than or equal to the pivot. In other words, it will move the pointer until it finds a value that can be swapped because it should be on the right side of the partition, not the left. It may move one position over, or it could move thousands \u2014 all this while loop is doing is finding the next value that is eligible for a swap because it's greater than or equal to to the pivot. If the value can't be swapped, the ",(0,o.jsx)(t.code,{children:"leftPointer"})," is incremented by one."]}),"\n",(0,o.jsxs)(t.p,{children:["The next while loop does the same thing, but for the ",(0,o.jsx)(t.code,{children:"rightPointer"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"while (array[rightPointer] > pivot) {\n  rightPointer--;\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"rightPointer"})," will be moved inward until it finds a value that is eligible to be swapped. If it can't be swapped, the ",(0,o.jsx)(t.code,{children:"rightPointer"})," is decremented by one (as this pointer is moving backwards through the array)."]}),"\n",(0,o.jsx)(t.p,{children:"Finally, we have a conditional that runs after the two while loops find values that can be swapped."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"if (leftPointer <= rightPointer) {\n  array = swap(array, leftPointer, rightPointer);\n  leftPointer++;\n  rightPointer--;\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Why do we need this conditional? Well, we have an outer while loop that has the same condition: ",(0,o.jsx)(t.code,{children:"leftPointer <= rightPointer"}),". However, eventually the two while loops that run within this outer while loop will overshoot each other \u2014 and the outer while loop won't catch this until ",(0,o.jsx)(t.em,{children:"after"})," we complete a full iteration of the outer while loop. However, we are still in the ",(0,o.jsx)(t.code,{children:"outer"})," while loop \u2014 so we need to make sure ",(0,o.jsx)(t.code,{children:"leftPointer <= rightPointer"})," before we do a swap."]}),"\n",(0,o.jsxs)(t.p,{children:["If this conditional is met, we can use our ",(0,o.jsx)(t.code,{children:"swap()"})," function:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"array = swap(array, leftPointer, rightPointer);\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Technically, we could just do the following without assigning the ",(0,o.jsx)(t.code,{children:"return"})," value to the ",(0,o.jsx)(t.code,{children:"array"})," variable:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"swap(array, leftPointer, rightPointer);\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Why is that? Well, remember that JavaScript doesn't store arrays (or any other non-primitive values) in variables. It stores ",(0,o.jsx)(t.em,{children:"references"})," to arrays and other objects in variables. So even though the ",(0,o.jsx)(t.code,{children:"array"})," variable inside the ",(0,o.jsx)(t.code,{children:"swap()"})," function is a different variable with a different scope than the ",(0,o.jsx)(t.code,{children:"array"})," variable that lives outside the ",(0,o.jsx)(t.code,{children:"swap()"})," function, they are both just references to the same array. Sometimes this idiosyncrasy of JavaScript can burn us, but it will actually help us out in this algorithm, as we'll see soon."]}),"\n",(0,o.jsxs)(t.p,{children:["So that is our ",(0,o.jsx)(t.code,{children:"sortPartition()"})," function. It will take a partition in an array (which is determined by the ",(0,o.jsx)(t.code,{children:"leftPointer"})," and ",(0,o.jsx)(t.code,{children:"rightPointer"})," parameters) and swap values based on a ",(0,o.jsx)(t.code,{children:"pivot"}),"."]}),"\n",(0,o.jsxs)(t.h3,{id:"writing-a-recursive-quicksort-function",children:["Writing a Recursive ",(0,o.jsx)(t.code,{children:"quickSort()"})," Function"]}),"\n",(0,o.jsxs)(t.p,{children:["We're almost done. The next step is to create a control function \u2014 our actual ",(0,o.jsx)(t.code,{children:"quicksort()"})," function \u2014 which will call itself recursively until the collection is fully sorted."]}),"\n",(0,o.jsx)(t.p,{children:"Here's a test (once again, we need to add another import):"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"import { findPivot, swap, sortPartition, quickSort } from '../src/quicksort.js';\n\ndescribe('quicksort functions', () => {\n\n  ...\n\n  test('it will quicksort an array', () => {\n    let array = [3, 9, 7, 2, 8, 6, 5, 4];\n    expect(quickSort(array)).toEqual([2, 3, 4, 5, 6, 7, 8, 9]);\n  });\n});\n"})}),"\n",(0,o.jsx)(t.p,{children:"As we can see, our final test just checks to see whether we can correctly quicksort an array. We are in the home stretch!"}),"\n",(0,o.jsxs)(t.p,{children:["Before we go into the code, a quick note \u2014 we are going to need to make a small refactor to our ",(0,o.jsx)(t.code,{children:"sortPartition()"})," function in a moment. Our ",(0,o.jsx)(t.code,{children:"quickSort()"})," function will ",(0,o.jsx)(t.em,{children:"not"})," work yet \u2014 and the test will not pass."]}),"\n",(0,o.jsxs)(t.p,{children:["Here's the code for our ",(0,o.jsx)(t.code,{children:"quickSort()"})," function:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"...\n\nexport function quickSort(array, leftPointer = 0, rightPointer = array.length - 1) {\n  let partitionPoint;\n  if (array.length > 1) {\n    partitionPoint = sortPartition(array, leftPointer, rightPointer);\n    if (leftPointer < partitionPoint - 1) {\n      quickSort(array, leftPointer, partitionPoint - 1);\n    }\n    if (rightPointer > partitionPoint) {\n      quickSort(array, partitionPoint, rightPointer);\n    }\n  }\n  return array;\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Our ",(0,o.jsx)(t.code,{children:"quickSort()"})," function takes three parameters: the ",(0,o.jsx)(t.code,{children:"array"}),", ",(0,o.jsx)(t.code,{children:"leftPointer"}),", and ",(0,o.jsx)(t.code,{children:"rightPointer"}),". Note that we pass in default values for the ",(0,o.jsx)(t.code,{children:"leftPointer"})," and ",(0,o.jsx)(t.code,{children:"rightPointer"}),". When we initially call the function, we are going to want it to run on the entire array \u2014 however, it would be inconvenient if we had to pass in the values of the left and right pointers every time we call it. When the function recursively calls itself, it will pass in new ",(0,o.jsx)(t.code,{children:"leftPointer"})," and ",(0,o.jsx)(t.code,{children:"rightPointer"})," values."]}),"\n",(0,o.jsxs)(t.p,{children:["Next, our function will need to know where it needs to be partitioned. We will declare a variable called ",(0,o.jsx)(t.code,{children:"partitionPoint"})," but not assign a value yet. We need to declare it outside our conditionals, or it will lose its scope when we pass from one conditional to the next."]}),"\n",(0,o.jsx)(t.p,{children:"Then we have a conditional \u2014 if we have an array that is only one or zero values, there's no need to partition or sort it. This makes our code a little bit more efficient. Unlike with our merge sort algorithm, where omitting this conditional will cause an infinite loop, this one just adds a little efficiency. We could omit it here and our quick sort algorithm will still run correctly."}),"\n",(0,o.jsxs)(t.p,{children:["So what comes next? Well, we need to sort our original array and then determine the ",(0,o.jsx)(t.code,{children:"partitionPoint"}),". Without the ",(0,o.jsx)(t.code,{children:"partitionPoint"}),", we can't determine the smaller partitions we need to quicksort."]}),"\n",(0,o.jsx)(t.p,{children:"However, there's a problem. None of our methods determine where the partition should go!"}),"\n",(0,o.jsxs)(t.p,{children:["If we look at the code we've written so far, we'll see that the ",(0,o.jsx)(t.code,{children:"sortPartition()"})," function has the information we need. After all, when the ",(0,o.jsx)(t.code,{children:"leftPointer"})," and ",(0,o.jsx)(t.code,{children:"rightPointer"})," intersect, that intersection point should be our ",(0,o.jsx)(t.code,{children:"partitionPoint"}),". However, that information is stuck inside the scope of ",(0,o.jsx)(t.code,{children:"sortPartition()"}),". That function returns an array, not information about the pointer intersection that our ",(0,o.jsx)(t.code,{children:"quickSort()"})," function needs."]}),"\n",(0,o.jsxs)(t.p,{children:["Well, this is where we can take advantage of the fact that all of our ",(0,o.jsx)(t.code,{children:"array"})," variables don't actually store the array we are modifying. They are just references to an array that is being stored in memory. In other words, we don't actually need to return an ",(0,o.jsx)(t.code,{children:"array"})," from ",(0,o.jsx)(t.code,{children:"sortPartition()"}),". Instead, we can just return the value of ",(0,o.jsx)(t.code,{children:"leftPointer"})," and determine the ",(0,o.jsx)(t.code,{children:"partitionPoint"})," based on that."]}),"\n",(0,o.jsxs)(t.p,{children:["This does mean updating both our ",(0,o.jsx)(t.code,{children:"sortPartition()"})," test as well as the function itself. Even though we do have to modify this test, our original test was still very helpful \u2014 it verified that ",(0,o.jsx)(t.code,{children:"sortPartition()"})," will correctly move pointers and swap values as needed based on the pivot."]}),"\n",(0,o.jsx)(t.p,{children:"Let's start by updating our test:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"...\n  test('it will sort and swap values in an array based on a pivot point', () => {\n    const array = [5, 1, 3, 2, 7];\n    const leftPointer = 0;\n    const rightPointer = 4;\n    expect(sortPartition(array, leftPointer, rightPointer)).toEqual(3);\n  });\n...\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Thinking about how our ",(0,o.jsx)(t.code,{children:"sortPartition()"})," function works, we can determine what the value of the ",(0,o.jsx)(t.code,{children:"leftPointer"})," should be after a passthrough. The ",(0,o.jsx)(t.code,{children:"leftPointer"})," will stay at position ",(0,o.jsx)(t.code,{children:"0"})," while the ",(0,o.jsx)(t.code,{children:"rightPointer"})," will move to position ",(0,o.jsx)(t.code,{children:"3"}),". Then the values will be swapped. The ",(0,o.jsx)(t.code,{children:"leftPointer"})," will move to position ",(0,o.jsx)(t.code,{children:"1"})," while the ",(0,o.jsx)(t.code,{children:"rightPointer"})," will move to position ",(0,o.jsx)(t.code,{children:"2"}),". So the array looks like this now:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"[2, 1, 3, 5, 7];\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"leftPointer"})," is still less than or equal to the ",(0,o.jsx)(t.code,{children:"rightPointer"})," (",(0,o.jsx)(t.code,{children:"1 <= 2"}),"), so our outer while loop will run again."]}),"\n",(0,o.jsxs)(t.p,{children:["Next, we'll run through the first inner while loop. We compare the value at the ",(0,o.jsx)(t.code,{children:"leftPointer"})," (which is ",(0,o.jsx)(t.code,{children:"1"}),") to the ",(0,o.jsx)(t.code,{children:"pivot"}),", which is ",(0,o.jsx)(t.code,{children:"3"}),". So the while loop increments the ",(0,o.jsx)(t.code,{children:"leftPointer"})," by 1. Now the ",(0,o.jsx)(t.code,{children:"leftPointer"})," is at position ",(0,o.jsx)(t.code,{children:"2"}),". It's at the pivot. So the value at the ",(0,o.jsx)(t.code,{children:"leftPointer"})," is ",(0,o.jsx)(t.code,{children:"3"}),", which is the value of the ",(0,o.jsx)(t.code,{children:"pivot"}),". ",(0,o.jsx)(t.code,{children:"3 < 3"})," is not true so that while loop is finished."]}),"\n",(0,o.jsxs)(t.p,{children:["Next, the ",(0,o.jsx)(t.code,{children:"rightPointer"})," compares its current value at position ",(0,o.jsx)(t.code,{children:"2"}),", which is the pivot. ",(0,o.jsx)(t.code,{children:"3 > 3"})," is not true so that while loop doesn't end up iterating at all."]}),"\n",(0,o.jsxs)(t.p,{children:["Finally, we check if ",(0,o.jsx)(t.code,{children:"(leftPointer <= rightPointer)"}),". They are both at position ",(0,o.jsx)(t.code,{children:"2"}),", so this is true. We then do our ",(0,o.jsx)(t.code,{children:"swap()"})," function, which is needless since it's just a self-swap. We could add a conditional, so this self-swap doesn't happen, but the amount of code added wouldn't even save us much overhead."]}),"\n",(0,o.jsxs)(t.p,{children:["At that point, we increment the ",(0,o.jsx)(t.code,{children:"leftPointer"})," by 1 and decrement the ",(0,o.jsx)(t.code,{children:"rightPointer"})," by 1. The ",(0,o.jsx)(t.code,{children:"leftPointer"})," is at position 3 while the right pointer is at position 1. The condition of the outer while loop is no longer true because ",(0,o.jsx)(t.code,{children:"3 <= 2"})," returns false. So the outer while loop is finished."]}),"\n",(0,o.jsxs)(t.p,{children:["That was an extensive walkthrough just to determine where the ",(0,o.jsx)(t.code,{children:"leftPointer"})," is. But now it's clear why the expectation for our test is that ",(0,o.jsx)(t.code,{children:"sortPartition()"})," should return ",(0,o.jsx)(t.code,{children:"3"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["All we need to do to get this test passing again is update the return of our ",(0,o.jsx)(t.code,{children:"sortPartition()"})," function:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"export function sortPartition(array, leftPointer, rightPointer) {\n  const pivot = findPivot(array, leftPointer, rightPointer)\n  while (leftPointer <= rightPointer) {\n    while (array[leftPointer] < pivot) {\n        leftPointer++;\n    }\n    while (array[rightPointer] > pivot) {\n        rightPointer--;\n    }\n    if (leftPointer <= rightPointer) {\n        swap(array, leftPointer, rightPointer);\n        leftPointer++;\n        rightPointer--;\n    }\n  }\n  // All we've changed is the return statement.\n  return leftPointer;\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This will get our test passing. Incidentally, it will get our ",(0,o.jsx)(t.code,{children:"quickSort()"})," test passing, too, but we aren't done walking through that function yet. So let's return to the ",(0,o.jsx)(t.code,{children:"quickSort()"})," walkthrough."]}),"\n",(0,o.jsx)(t.p,{children:"Here's the whole function again:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"...\nexport function quickSort(array, leftPointer = 0, rightPointer = array.length - 1) {\n  let partitionPoint;\n  if (array.length > 1) {\n    partitionPoint = sortPartition(array, leftPointer, rightPointer);\n    if (leftPointer < partitionPoint - 1) {\n      quickSort(array, leftPointer, partitionPoint - 1);\n    }\n    if (rightPointer > partitionPoint) {\n      quickSort(array, partitionPoint, rightPointer);\n    }\n  }\n  return array;\n}\n...\n"})}),"\n",(0,o.jsx)(t.p,{children:"We are currently at this line of the code:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"partitionPoint = sortPartition(array, leftPointer, rightPointer);\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Our ",(0,o.jsx)(t.code,{children:"sortPartition()"})," function now returns where the ",(0,o.jsx)(t.code,{children:"leftPointer"})," is when ",(0,o.jsx)(t.code,{children:"sortPartition()"})," is complete. That will be the updated value of our ",(0,o.jsx)(t.code,{children:"partitionPoint"})," variable."]}),"\n",(0,o.jsxs)(t.p,{children:["Just to clarify once again, ",(0,o.jsx)(t.code,{children:"sortPartition()"})," is still sorting the array even though the function now returns the value of its ",(0,o.jsx)(t.code,{children:"leftPointer"}),", not the array itself. That's because regardless of the scope of any of the ",(0,o.jsx)(t.code,{children:"array"})," variables in the ",(0,o.jsx)(t.code,{children:"quickSort()"})," function, they are always referring to the same array in memory. These references will fall out of scope and new references will be created, but once again, they are always modifying the same array."]}),"\n",(0,o.jsxs)(t.p,{children:["Now that we have a ",(0,o.jsx)(t.code,{children:"partitionPoint"}),", we'll be able to divide our array into smaller and smaller partitions until the collection is fully sorted. To determine whether we'll need to run ",(0,o.jsx)(t.code,{children:"quickSort()"})," again, we have two conditionals."]}),"\n",(0,o.jsx)(t.p,{children:"Here's the first conditional:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"if (leftPointer < partitionPoint - 1) {\n  quickSort(array, leftPointer, partitionPoint - 1);\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This reference to a ",(0,o.jsx)(t.code,{children:"leftPointer"})," might be a bit confusing at first because it's a different ",(0,o.jsx)(t.code,{children:"leftPointer"})," than the one we were just referring to in ",(0,o.jsx)(t.code,{children:"sortPartition()"}),". So let's slow down a bit and walk through this."]}),"\n",(0,o.jsxs)(t.p,{children:["When we first call our ",(0,o.jsx)(t.code,{children:"quickSort()"})," function, it calls ",(0,o.jsx)(t.code,{children:"sortPartition()"}),", which does a single quicksort passthrough of our entire array. Inside ",(0,o.jsx)(t.code,{children:"sortPartition()"}),", both pointers are moving and values are being swapped until the passthrough ends. At this point, the ",(0,o.jsx)(t.code,{children:"leftPointer"})," value from inside our ",(0,o.jsx)(t.code,{children:"sortPartition()"})," is only useful to determine the ",(0,o.jsx)(t.code,{children:"partitionPoint"}),". The ",(0,o.jsx)(t.code,{children:"leftPointer"})," value from inside that function falls out of scope."]}),"\n",(0,o.jsxs)(t.p,{children:["Now we have an array that's a little bit more sorted and we have a ",(0,o.jsx)(t.code,{children:"partitionPoint"})," to determine where this array should be partitioned. But our ",(0,o.jsx)(t.code,{children:"leftPointer"})," and ",(0,o.jsx)(t.code,{children:"rightPointer"})," values are the first and last element of the array, respectively. This is fine \u2014 because these values are only going to be used to determine the boundaries of each partition. As long as the ",(0,o.jsx)(t.code,{children:"leftPointer"})," is less than the rightmost boundary of the partition, we can keep sorting. But once the ",(0,o.jsx)(t.code,{children:"leftPointer"})," overtakes ",(0,o.jsx)(t.code,{children:"partitionPoint"}),", our algorithm knows that particular partition is completely sorted."]}),"\n",(0,o.jsxs)(t.p,{children:["So as long as the conditional is true, we still have sorting to do. That means our algorithm will call ",(0,o.jsx)(t.code,{children:"quickSort()"})," on the newly-created left partition. The boundary for this partition will be the ",(0,o.jsx)(t.code,{children:"leftPointer"})," on the left side and ",(0,o.jsx)(t.code,{children:"partitionPoint - 1"})," on the right side."]}),"\n",(0,o.jsxs)(t.p,{children:["The next conditional does the same thing, but for the newly-created right partition. The boundary for this partition will be ",(0,o.jsx)(t.code,{children:"partitionPoint"})," on the left side and ",(0,o.jsx)(t.code,{children:"rightPointer"})," on the right side."]}),"\n",(0,o.jsx)(t.p,{children:"As each recursive call occurs, the partitions on each side will get smaller and smaller. When the pointers intersect with the opposite side of their boundary \u2014 which means there are no values between the boundaries \u2014 that section is done. We work our way through the stack of recursive calls until the entire array is sorted and then returned."}),"\n",(0,o.jsxs)(t.p,{children:["If this is still confusing \u2014 and we expect it might be since this is the most challenging algorithm we've covered \u2014 we recommend setting up a breakpoint in the code, intentionally breaking the test for ",(0,o.jsx)(t.code,{children:"quickSort()"}),", and then stepping through the code line by line to see exactly what's happening."]}),"\n",(0,o.jsxs)(t.p,{children:["At this point, we've learned five different sorting algorithms. There are many others but they are beyond the scope of this curriculum. You're encouraged to do further exploration on your own \u2014 and you might find this visualization interesting (not recommended for epileptics): ",(0,o.jsx)(t.a,{href:"https://www.youtube.com/watch?v=kPRA0W1kECg&ab_channel=TimoBingmann",children:"15 Sorting Algorithms in 6 Minutes"}),". It shows how each sorting algorithm actually processes and sorts collections."]})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},59875:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/partioned-arrays-9c75ad97df5f7c024090fee3972aaa91.png"},83723:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/third-comparison-d1eeeea43eef9aabc519bfe1f826feda.png"}}]);