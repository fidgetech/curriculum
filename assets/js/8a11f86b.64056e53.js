"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[54738],{28453:(e,t,r)=>{r.d(t,{R:()=>s,x:()=>i});var n=r(96540);const o={},a=n.createContext(o);function s(e){const t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(a.Provider,{value:t},e.children)}},98713:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>h,contentTitle:()=>i,default:()=>c,frontMatter:()=>s,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"introduction-to-programming/arrays-looping/1-3-0-6-array-methods","title":"\ud83d\udcd3 1.3.0.6 Array Methods","description":"Over the last two lessons, we\'ve learned the basics of how arrays work, the length property that every array has, and how we can look inside of arrays. We also learned about off-by-one errors \u2014 and there will be plenty more reminders about OBOEs throughout this section (mostly when we make the OBOE in our code) because they are so common.","source":"@site/versioned_docs/version-WIP/1_introduction-to-programming/3_arrays-looping/1-3-0-06-array-methods.md","sourceDirName":"1_introduction-to-programming/3_arrays-looping","slug":"/introduction-to-programming/arrays-looping/1-3-0-6-array-methods","permalink":"/WIP/introduction-to-programming/arrays-looping/1-3-0-6-array-methods","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 1.3.0.6 Array Methods","day":"weekend","id":"1-3-0-6-array-methods","hide_table_of_contents":true},"sidebar":"introduction-to-programming","previous":{"title":"\ud83d\udcd3 1.3.0.5 Bracket Notation","permalink":"/WIP/introduction-to-programming/arrays-looping/1-3-0-5-bracket-notation"},"next":{"title":"\ud83d\udcd3 1.3.0.7 Comparing and Cloning Arrays","permalink":"/WIP/introduction-to-programming/arrays-looping/1-3-0-7-comparing-and-cloning-arrays"}}');var o=r(74848),a=r(28453);const s={title:"\ud83d\udcd3 1.3.0.6 Array Methods",day:"weekend",id:"1-3-0-6-array-methods",hide_table_of_contents:!0},i=void 0,h={},l=[{value:"Array Methods",id:"array-methods",level:2},{value:"<code>Array.prototype.push()</code> Versus <code>Array.prototype.concat()</code>",id:"arrayprototypepush-versus-arrayprototypeconcat",level:3},{value:"Using Bracket Notation to Modify Elements in an Array",id:"using-bracket-notation-to-modify-elements-in-an-array",level:3},{value:"<code>Array.prototype.unshift()</code> Versus <code>Array.prototype.shift()</code>",id:"arrayprototypeunshift-versus-arrayprototypeshift",level:3},{value:"<code>Array.prototype.pop()</code>",id:"arrayprototypepop",level:3},{value:"<code>Array.prototype.join()</code>",id:"arrayprototypejoin",level:3},{value:"<code>Array.prototype.slice()</code>",id:"arrayprototypeslice",level:3},{value:"Other Array Methods",id:"other-array-methods",level:3}];function d(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["Over the last two lessons, we've learned the basics of how arrays work, the ",(0,o.jsx)(t.code,{children:"length"})," property that every array has, and how we can look inside of arrays. We also learned about off-by-one errors \u2014 and there will be plenty more reminders about OBOEs throughout this section (mostly when we make the OBOE in our code) because they are so common."]}),"\n",(0,o.jsxs)(t.p,{children:["In this lesson, we'll learn about some of the most common array methods. In the process, we'll make an important distinction because some methods ",(0,o.jsx)(t.strong,{children:"mutate"})," the arrays they are called on while some don't. When a method mutates an array, it is permanently changed, while methods that don't mutate arrays actually create (and return) brand new arrays."]}),"\n",(0,o.jsx)(t.p,{children:"As you read through this lesson, optionally use the DevTools console to try out the new code."}),"\n",(0,o.jsx)(t.h2,{id:"array-methods",children:"Array Methods"}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsxs)(t.h3,{id:"arrayprototypepush-versus-arrayprototypeconcat",children:[(0,o.jsx)(t.code,{children:"Array.prototype.push()"})," Versus ",(0,o.jsx)(t.code,{children:"Array.prototype.concat()"})]}),"\n",(0,o.jsxs)(t.p,{children:["Let's look at an example of a method that mutates an array versus one that doesn't. We'll start by returning to ",(0,o.jsx)(t.code,{children:"Array.prototype.push()"}),". Yes, we've already learned this method \u2014 however, it's so important that it's worth reviewing it. It's also a key example of a method that mutates the array it's called on. These kinds of methods are also known as ",(0,o.jsx)(t.strong,{children:"destructive methods"})," because they change the receiver (the thing the method is called on)."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"> let numArr = [1,2,3];\n> numArr.push(4);\n4\n> numArr;\n[1,2,3,4]\n"})}),"\n",(0,o.jsxs)(t.p,{children:["As we can see in this example, ",(0,o.jsx)(t.code,{children:"numArr"})," has been mutated. ",(0,o.jsx)(t.code,{children:"Array.prototype.push()"})," only returns the length of the array (",(0,o.jsx)(t.code,{children:"4"}),"), and not a new array like non-destructive methods do."]}),"\n",(0,o.jsxs)(t.p,{children:["Let's compare this to the ",(0,o.jsx)(t.code,{children:"Array.prototype.concat()"})," method, which is a non-destructive method."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"> const originalArray = [1,2,3];\n> const modifiedArray = originalArray.concat(4);\n> originalArray;\n[1,2,3]\n> modifiedArray;\n[1,2,3,4]\n"})}),"\n",(0,o.jsxs)(t.p,{children:["First, note that we used ",(0,o.jsx)(t.code,{children:"const"})," here instead of ",(0,o.jsx)(t.code,{children:"let"}),". This is because ",(0,o.jsx)(t.code,{children:"originalArray"})," isn't being modified when we call ",(0,o.jsx)(t.code,{children:"Array.prototype.concat()"})," on it. This method returns a new array, which is what all ",(0,o.jsx)(t.strong,{children:"non-destructive"})," methods do. The value of this new array is the original array plus the arguments passed into ",(0,o.jsx)(t.code,{children:"Array.prototype.concat()"}),". In this case, it's doing the same thing as if we just used ",(0,o.jsx)(t.code,{children:"Array.prototype.push()"}),", right? So what's the difference?"]}),"\n",(0,o.jsxs)(t.p,{children:["Well, it's a pretty big deal that our original array isn't modified. What if we want to use the original array for another operation later? It would be better to use ",(0,o.jsx)(t.code,{children:"Array.prototype.concat()"}),". Also, we really need to make sure we store the return of ",(0,o.jsx)(t.code,{children:"Array.prototype.concat()"})," in a variable (because it won't be saved otherwise) while we don't need to do so with ",(0,o.jsx)(t.code,{children:"Array.prototype.push()"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["There's also a whole school of thought that we should ",(0,o.jsx)(t.em,{children:"never"})," modify arrays or other objects \u2014 only create new ones. This is a central concept of a programming style called ",(0,o.jsx)(t.strong,{children:"functional programming"})," which we will learn about once we reach the React course."]}),"\n",(0,o.jsx)(t.p,{children:"For now, we aren't making distinctions about one being better or worse. It's just important to know both of these methods \u2014 and to know which methods mutate the array they are called on and which don't."}),"\n",(0,o.jsx)(t.h3,{id:"using-bracket-notation-to-modify-elements-in-an-array",children:"Using Bracket Notation to Modify Elements in an Array"}),"\n",(0,o.jsx)(t.p,{children:"In the last lesson, we learned how to use bracket notation to see the value of an array. For example:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"> let array = [1,2,3];\n> array[0];\n1\n"})}),"\n",(0,o.jsx)(t.p,{children:"We can also use bracket notation to modify elements in an array:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:'> let array = [1,2,3]\n> array[0] = "We just modified the array at position zero.";\n> array;\n["We just modified the array at position zero.",2,3];\n'})}),"\n",(0,o.jsxs)(t.p,{children:["In this example, we assigned a new value to ",(0,o.jsx)(t.code,{children:"array[0]"}),": ",(0,o.jsx)(t.code,{children:'"We just modified the array at position zero."'}),"."]}),"\n",(0,o.jsx)(t.p,{children:"Modifying elements in arrays like this is super useful. Make a mental note of this now so you can add this to your JS toolbox right away."}),"\n",(0,o.jsxs)(t.p,{children:["As you can probably guess, you can reassign elements in an array even if it's a ",(0,o.jsx)(t.code,{children:"const"}),". If an array is a ",(0,o.jsx)(t.code,{children:"const"}),", it's only the array ",(0,o.jsx)(t.em,{children:"itself"})," that can't be reassigned."]}),"\n",(0,o.jsxs)(t.p,{children:["We can also use bracket notation to add an element to an array. Be careful, though \u2014 it's not as effective as using ",(0,o.jsx)(t.code,{children:"Array.prototype.push()"})," or other methods. Here's why:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"> let array = [1,2,3];\n> array[5] = 4;\n4\n> array;\n[1, 2, 3, , , 4]\n"})}),"\n",(0,o.jsxs)(t.p,{children:["In the example above, we assign the number ",(0,o.jsx)(t.code,{children:"4"})," to ",(0,o.jsx)(t.code,{children:"array"})," at an index of ",(0,o.jsx)(t.code,{children:"5"}),". There is no index at ",(0,o.jsx)(t.code,{children:"5"}),", though. JavaScript is happy to expand our array so it can insert this value  at the 5th index \u2014 but that means it has to add some empty elements (the DevTools console will display this as ",(0,o.jsx)(t.code,{children:"[1, 2, 3, empty \xd7 2, 4]"}),"). Yuck! In general, we don't want to have empty spots in an array, though there is a use case for just about everything in JavaScript. It would certainly work to do the following (and have the exact same effect as ",(0,o.jsx)(t.code,{children:"Array.prototype.push()"}),"):"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"> array[array.length] = 4;\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Since the length of an array would be one element ",(0,o.jsx)(t.em,{children:"past"})," the final element in the current array, this works correctly. It's a convoluted approach to adding an element in an array, though, and you'll probably never see it in the real world. As always, though, it's good to see the flexibility and power of each tool we have in our toolbox."]}),"\n",(0,o.jsxs)(t.h3,{id:"arrayprototypeunshift-versus-arrayprototypeshift",children:[(0,o.jsx)(t.code,{children:"Array.prototype.unshift()"})," Versus ",(0,o.jsx)(t.code,{children:"Array.prototype.shift()"})]}),"\n",(0,o.jsx)(t.p,{children:"Okay, the difference between these two methods is confusing \u2014 and don't worry... lots of developers feel this way."}),"\n",(0,o.jsxs)(t.p,{children:["We use ",(0,o.jsx)(t.code,{children:"Array.prototype.unshift()"})," to add an element to the beginning of an array. It's like ",(0,o.jsx)(t.code,{children:"Array.prototype.push()"}),", except for the beginning of the array instead of the end."]}),"\n",(0,o.jsx)(t.p,{children:"Here's an example:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"> let numberArray = [2,3,4];\n> numberArray.unshift(1);\n> numberArray;\n[1,2,3,4]\n"})}),"\n",(0,o.jsxs)(t.p,{children:["On the other hand, ",(0,o.jsx)(t.code,{children:"Array.prototype.shift()"})," ",(0,o.jsx)(t.em,{children:"removes"})," the first element of the array:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"> let numberArray = [2,3,4];\n> numberArray.shift();\n> numberArray;\n[3,4]\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Yes, the common sentiment out there is that this is backwards and confusing. When you ",(0,o.jsx)(t.em,{children:"shift"})," something over, shouldn't that mean adding something to the beginning because we are shifting over what's already there? And when you ",(0,o.jsx)(t.em,{children:"unshift"})," it, shouldn't that mean taking something away from the beginning?"]}),"\n",(0,o.jsxs)(t.p,{children:["Nope, it's the opposite. The best way to remember how ",(0,o.jsx)(t.code,{children:"Array.prototype.shift()"})," and ",(0,o.jsx)(t.code,{children:"Array.prototype.unshift()"})," work is that their effect seems counter-intuitive to how they are named. There is actually a good reason they are named this way \u2014 it's based on binary shifting. That's not something you need to look up, though, unless you are curious to learn about something completely tangential."]}),"\n",(0,o.jsx)(t.p,{children:"Also, it's worth noting \u2014 both of these methods are destructive. They change the receiver."}),"\n",(0,o.jsx)(t.h3,{id:"arrayprototypepop",children:(0,o.jsx)(t.code,{children:"Array.prototype.pop()"})}),"\n",(0,o.jsxs)(t.p,{children:["Here's an easy one to remember! Don't want to ",(0,o.jsx)(t.em,{children:"push"})," something onto the end of an array? ",(0,o.jsx)(t.em,{children:"Pop"})," it off. ",(0,o.jsx)(t.code,{children:"Array.prototype.pop()"})," removes the last element of an array:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:'> let arrayToPop = ["a", "b", "c", "d"];\n> arrayToPop.pop();\n"d"\n> arrayToPop;\n["a", "b", "c"]\n'})}),"\n",(0,o.jsx)(t.p,{children:"A couple of things to note here. One, this method is destructive. Secondly, when we call this method, the return is the value of the element that was popped. Pay close attention here! Sometimes we'll want to do something with this value."}),"\n",(0,o.jsx)(t.h3,{id:"arrayprototypejoin",children:(0,o.jsx)(t.code,{children:"Array.prototype.join()"})}),"\n",(0,o.jsxs)(t.p,{children:["In this section, we'll work on some projects where we want to do things to different characters in a string. This means turning a string into an array. Once we are done doing all the things, we may want the final thing to once again be a string. That's where ",(0,o.jsx)(t.code,{children:"Array.prototype.join()"})," comes in. It will take an array and turn it into a string. We can also pass in a separator as an argument. The examples below should make this clear:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:'> const epicodus = ["e","p","i","c"];\n> const epic = epicodus.join();\n> epic;\n"e,p,i,c"\n> const epicWithoutCommas = epicodus.join("");\n> epicWithoutCommas;\n"epic"\n> const reallyEpic = epicodus.join("...");\n> reallyEpic;\n"e...p...i...c"\n'})}),"\n",(0,o.jsxs)(t.p,{children:["If we call ",(0,o.jsx)(t.code,{children:"Array.prototype.join()"})," without arguments, the array will be turned into a string with commas as separators between each element from the array. That's usually not what we'll want. More commonly, we'll want to do away with the commas, which means passing in ",(0,o.jsx)(t.code,{children:'""'})," as an argument. This just means the separator should be no spaces. If we passed in ",(0,o.jsx)(t.code,{children:'" "'}),", the separator between each element would be a space. We can pass anything we want as a separator \u2014 especially if we want to be really epic and add ",(0,o.jsx)(t.code,{children:"..."})," between each character."]}),"\n",(0,o.jsx)(t.p,{children:"Note that this is a non-destructive method \u2014 so we need to save the return value to a variable."}),"\n",(0,o.jsx)(t.h3,{id:"arrayprototypeslice",children:(0,o.jsx)(t.code,{children:"Array.prototype.slice()"})}),"\n",(0,o.jsxs)(t.p,{children:["We'll cover one more common array method. We can use ",(0,o.jsx)(t.code,{children:"Array.prototype.slice()"})," to literally slice off parts of an array. It's kind of like ",(0,o.jsx)(t.code,{children:"Array.prototype.shift()"})," and ",(0,o.jsx)(t.code,{children:"Array.prototype.pop()"})," mixed together in one, but more flexible and powerful."]}),"\n",(0,o.jsx)(t.p,{children:"We can pass in one or two arguments. We have to slice from the beginning of the array \u2014 and we can optionally slice from the end."}),"\n",(0,o.jsx)(t.p,{children:"The first argument denotes the index we should slice up to:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:'> const fruits = ["rambutan", "durian", "kiwi", "guava", "mangosteen"];\n> const slicedFruits = fruits.slice(2);\n> slicedFruits;\n["kiwi", "guava", "mangosteen"]\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Here, we are slicing ",(0,o.jsx)(t.em,{children:"everything up to but not including"})," an index of 2 \u2014 so everything before ",(0,o.jsx)(t.code,{children:'"kiwi"'}),". Note that ",(0,o.jsx)(t.code,{children:"Array.prototype.slice()"})," isn't destructive and we have to save its return (a sliced copy of the array) in a variable. That's probably for the best \u2014 too much slicing and dicing going on!"]}),"\n",(0,o.jsx)(t.p,{children:"Now let's slice our fruits a different way \u2014 and also remove some fruits from the end of our array."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:'> const dicedFruits = fruits.slice(1,3);\n["durian", "kiwi"]\n'})}),"\n",(0,o.jsxs)(t.p,{children:["We are slicing ",(0,o.jsx)(t.em,{children:"up to"})," an index of 1 \u2014 so ",(0,o.jsx)(t.code,{children:'"rambutan"'})," gets sliced off. Then we are slicing ",(0,o.jsx)(t.em,{children:"everything past and including"})," an index of 3. So the second argument handles things a little differently than the first because the slicing starts ",(0,o.jsx)(t.em,{children:"when"})," the index is reached, not ",(0,o.jsx)(t.em,{children:"after"}),". Be careful or you might slice more fruits than your codebase can handle."]}),"\n",(0,o.jsx)(t.h3,{id:"other-array-methods",children:"Other Array Methods"}),"\n",(0,o.jsx)(t.p,{children:"This is just the tip of the iceberg in terms of what we can do with arrays. There are a lot of other array methods \u2014 and later in this section we'll learn how to use looping to really enhance what we can do with arrays. We'll also learn some other powerful array methods throughout the remainder of the program."}),"\n",(0,o.jsxs)(t.p,{children:["To see a list of array methods, check the ",(0,o.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",children:"Mozilla array documentation"}),". Scroll down the page a bit and you'll see a list of methods in the left-hand pane. You don't need to memorize them \u2014 after all, that's what documentation is for. However, take some time to acquaint yourself with the methods available. All the methods we've covered in this lesson are on that list."]})]})}function c(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);