"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[79796],{28453:(e,t,a)=>{a.d(t,{R:()=>o,x:()=>r});var s=a(96540);const n={},i=s.createContext(n);function o(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),s.createElement(i.Provider,{value:t},e.children)}},98811:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"c-and-net/database-basics/3-3-0-11-testing-for-an-empty-database","title":"\ud83d\udcd3 3.3.0.11 Testing for an Empty Database","description":"Now that we have both ClearAll() and GetAll() methods that interact with our database, let\'s begin writing tests for our methods. As always, we begin by testing the simplest possible behavior. In this case, we\'ll start with a test to make sure the database is empty.","source":"@site/docs/3_c-and-net/3_database-basics/3-3-0-11-testing-for-an-empty-database.md","sourceDirName":"3_c-and-net/3_database-basics","slug":"/c-and-net/database-basics/3-3-0-11-testing-for-an-empty-database","permalink":"/v1.2/c-and-net/database-basics/3-3-0-11-testing-for-an-empty-database","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 3.3.0.11 Testing for an Empty Database","day":"weekend","id":"3-3-0-11-testing-for-an-empty-database","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.3.0.10 Deleting Objects in the Database","permalink":"/v1.2/c-and-net/database-basics/3-3-0-10-deleting-objects-in-the-database"},"next":{"title":"\ud83d\udcd3 3.3.0.12 Overriding Equals and GetHashCode","permalink":"/v1.2/c-and-net/database-basics/3-3-0-12-overriding-equals-and-gethashcode"}}');var n=a(74848),i=a(28453);const o={title:"\ud83d\udcd3 3.3.0.11 Testing for an Empty Database",day:"weekend",id:"3-3-0-11-testing-for-an-empty-database",hide_table_of_contents:!0},r=void 0,l={},d=[{value:"Refactoring to Begin Testing Database Functionality",id:"refactoring-to-begin-testing-database-functionality",level:2},{value:"Testing Database-Backed Functionality",id:"testing-database-backed-functionality",level:2}];function c(e){const t={code:"code",div:"div",em:"em",h2:"h2",hr:"hr",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["Now that we have both ",(0,n.jsx)(t.code,{children:"ClearAll()"})," and ",(0,n.jsx)(t.code,{children:"GetAll()"})," methods that interact with our database, let's begin writing tests for our methods. As always, we begin by testing the simplest possible behavior. In this case, we'll start with a test to make sure the database is empty."]}),"\n",(0,n.jsx)(t.h2,{id:"refactoring-to-begin-testing-database-functionality",children:"Refactoring to Begin Testing Database Functionality"}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsxs)(t.p,{children:["Before we get started, we'll need to comment out all of our tests. Because we are in the process of changing our application's functionality, we will have to go through tests one by one to get them passing again. We won't go through the \"Red, Green, Refactor\" process because we've already written our method. Make sure that you don't comment out the code for ",(0,n.jsx)(t.code,{children:"Dispose()"}),", the ",(0,n.jsx)(t.code,{children:"Configuration"})," property, or ",(0,n.jsx)(t.code,{children:"ItemTests()"})," in the process."]}),"\n",(0,n.jsx)(t.h2,{id:"testing-database-backed-functionality",children:"Testing Database-Backed Functionality"}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.p,{children:"Let's begin testing our new database-backed functionality. We'll write a test confirming that we begin with an empty database. As discussed at the beginning of this lesson, this is the simplest possible behavior our database will exhibit."}),"\n",(0,n.jsxs)(t.p,{children:["We already have a commented out test that confirms ",(0,n.jsx)(t.code,{children:"GetAll()"})," returns an empty list. We can simply update its name and reuse the test:"]}),"\n",(0,n.jsx)(t.div,{className:"filename",children:"ToDoList.Tests/ModelTests/ItemsTest.cs"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-csharp",children:"...\n\n[TestMethod]\npublic void GetAll_ReturnsEmptyListFromDatabase_ItemList()\n{\n  //Arrange\n  List<Item> newList = new List<Item> { };\n\n  //Act\n  List<Item> result = Item.GetAll();\n\n  //Assert\n  CollectionAssert.AreEqual(newList, result);\n}\n\n...\n"})}),"\n",(0,n.jsxs)(t.p,{children:["If we run our test, it will pass. This is because all of our code to make a database connection isn't actually adding anything to ",(0,n.jsx)(t.code,{children:"allItems"}),". We could comment out every line other than the first line ",(0,n.jsx)(t.code,{children:"List<Item> allItems = new List<Item> { };"})," and the last line of ",(0,n.jsx)(t.code,{children:"return allItems;"})," of the ",(0,n.jsx)(t.code,{children:"GetAll()"})," method and it would still pass. Either way, our method is returning an empty list. However, it's still important that we have this test in place because it's possible that other tests and methods we add will break this test. In fact, this test ",(0,n.jsx)(t.em,{children:"will"})," break if we don't make sure that we clear our database between each run, so it will provide assurance that our database is correctly clearing between tests."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}}}]);