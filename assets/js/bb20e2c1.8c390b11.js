"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[38804],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var o=t(96540);const a={},s=o.createContext(a);function i(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),o.createElement(s.Provider,{value:n},e.children)}},48128:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"c-and-net/lessons-19-31-basic-console-apps/3-0-0-19-expectations-and-game-plan-for-building-a-c-console-app","title":"\ud83d\udcd3 3.0.0.19 Expectations and Game Plan for Building a C# Console App","description":"So far we\'ve experimented with C# by typing basic code into the REPL. If we want to write entire programs, we\'ll need to save our code in files. Well, in this next section of the C# .NET pre-work, we\'re going to learn how to do exactly that by creating C# console applications. A console application is a program that is run within our terminal, or command line interface.","source":"@site/versioned_docs/version-v1_3/3_c-and-net/0_lessons-19-31-basic-console-apps/3-0-0-19-expectations-and-game-plan-for-building-a-c-console-app.md","sourceDirName":"3_c-and-net/0_lessons-19-31-basic-console-apps","slug":"/c-and-net/lessons-19-31-basic-console-apps/3-0-0-19-expectations-and-game-plan-for-building-a-c-console-app","permalink":"/v1.3/c-and-net/lessons-19-31-basic-console-apps/3-0-0-19-expectations-and-game-plan-for-building-a-c-console-app","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 3.0.0.19 Expectations and Game Plan for Building a C# Console App","day":"weekend","id":"3-0-0-19-expectations-and-game-plan-for-building-a-c-console-app","hide_table_of_contents":true,"pagination_prev":null},"sidebar":"c-and-net","next":{"title":"\ud83d\udcd3 3.0.0.20 Hello World! Compiling and Executing C# Programs","permalink":"/v1.3/c-and-net/lessons-19-31-basic-console-apps/3-0-0-20-hello-world-compiling-and-executing-c-programs"}}');var a=t(74848),s=t(28453);const i={title:"\ud83d\udcd3 3.0.0.19 Expectations and Game Plan for Building a C# Console App",day:"weekend",id:"3-0-0-19-expectations-and-game-plan-for-building-a-c-console-app",hide_table_of_contents:!0,pagination_prev:null},r=void 0,l={},c=[{value:"Commonalities Between JavaScript and C#",id:"commonalities-between-javascript-and-c",level:2},{value:"The Process of Building the C# Shape Tracker",id:"the-process-of-building-the-c-shape-tracker",level:2},{value:"Testing and Debugging in the Next Pre-Work Section",id:"testing-and-debugging-in-the-next-pre-work-section",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["So far we've experimented with C# by typing basic code into the REPL. If we want to write entire programs, we'll need to save our code in files. Well, in this next section of the C# .NET pre-work, we're going to learn how to do exactly that by creating C# console applications. A ",(0,a.jsx)(n.strong,{children:"console application"})," is a program that is run within our terminal, or command line interface."]}),"\n",(0,a.jsxs)(n.p,{children:["For this pre-work, we're going to recreate ",(0,a.jsx)(n.a,{href:"https://github.com/epicodus-lessons/section-5-shape-tracker/tree/3_multiple_business_logic_files",children:"the Shape Tracker application"})," that we created in the Intermediate JavaScript course as a C# console application. If you don't remember, the Shape Tracker app has a Triangle class that calculates the type of triangle given three sides, as well as a Rectangle class that calculates the area of a rectangle given two sides."]}),"\n",(0,a.jsx)(n.p,{children:"As we'll see, there are a lot of concepts and best practices in common between writing clean, maintainable code in JavaScript and C#. Let's review those now."}),"\n",(0,a.jsx)(n.h2,{id:"commonalities-between-javascript-and-c",children:"Commonalities Between JavaScript and C#"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Separation of UI and Business Logic."})," We'll continue to separate code that deals with our business logic and code that handles our user interface logic."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Separation of Concerns."})," We'll continue to separate our code into multiple methods (and classes) that focus on one purpose, instead of doing multiple things."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Test-Driven Development."})," We'll continue to use Test-Driven Development (TDD) and the Red-Green-Refactor workflow to test our C# code. In this case, we'll use a testing framework called MSTest for C#. With JavaScript, we used Jest. This pre-work section will focus on creating console apps, and the next pre-work section will focus on TDD."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"We'll use a package manager and download packages from a shared registry."})," We used node package manager (",(0,a.jsx)(n.code,{children:"npm"}),") in JavaScript and downloaded libraries from ",(0,a.jsx)(n.a,{href:"https://www.npmjs.com/",children:"the npm registry"}),". With C#, we'll use the ",(0,a.jsx)(n.code,{children:"dotnet"})," project manager and install packages from ",(0,a.jsx)(n.a,{href:"https://www.nuget.org/",children:"the NuGet package registry"}),". There are some differences between the tooling, but the basic concepts are the same."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsxs)(n.strong,{children:["We use a ",(0,a.jsx)(n.code,{children:".gitignore"})," to manage which files are saved to our remote repos."]})," We'll continue to have files that we want to ignore. These files are auto-generated project dependencies, similar to the ",(0,a.jsx)(n.code,{children:"node_modules/"})," directory that contain all of our JavaScript project's dependencies that ",(0,a.jsx)(n.code,{children:"npm"})," installs for us."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsxs)(n.strong,{children:["We use a ",(0,a.jsx)(n.code,{children:"README.md"})," to describe our applications."]})," This is a standby, and crucial to get other developers to run your app and give yourself credit for the work that you've done."]}),"\n",(0,a.jsxs)(n.p,{children:["We'll also notice other similarities between the two languages. For example, ",(0,a.jsx)(n.strong,{children:"classes and constructors"})," are much the same."]}),"\n",(0,a.jsx)(n.h2,{id:"the-process-of-building-the-c-shape-tracker",children:"The Process of Building the C# Shape Tracker"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:"When we're done creating our C# Shape Tracker, our project directory will look like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"ShapeTracker.Solution/\n|_ Models/\n|   |_ Triangle.cs\n|_ Program.cs\n|_ ShapeTracker.csproj\n|_ README.md\n|_ .gitignore\n"})}),"\n",(0,a.jsx)(n.p,{children:"But how will we get there? We'll start with our business logic, and then move onto our user interface logic:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:'We\'ll start by creating a simple "Hello World" application that has nothing to do with our Shape Tracker app. This will give us the opportunity to understand how C# compiles and executes programs.'}),"\n",(0,a.jsx)(n.li,{children:"Then we'll start creating our Shape Tracker project. We'll first create the structure and learn about the namespaces in our project."}),"\n",(0,a.jsxs)(n.li,{children:["Then, we'll create our business logic model. We'll learn how to create custom classes, constructors, methods, properties, and more by creating a ",(0,a.jsx)(n.code,{children:"Triangle"})," class. In the process, we'll learn about new C# concepts."]}),"\n",(0,a.jsx)(n.li,{children:"Finally, we'll build out our user interface. This will handle asking the user for three lengths and tell the user what type of triangle they have."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"We'll end this pre-work section with a review of C# conventions, a more in depth look at compilation, and taking a look at debugging tools."}),"\n",(0,a.jsx)(n.h3,{id:"testing-and-debugging-in-the-next-pre-work-section",children:"Testing and Debugging in the Next Pre-Work Section"}),"\n",(0,a.jsx)(n.p,{children:"In the next pre-work section we'll learn about some debugging tools as well as how to use MSTest to write and run tests. We'll recreate our Triangle business logic following the Red-Green-Refactor workflow. This will be a combination of a refresher of Test-Driven Development concepts and learning new tools with MSTest."})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);