"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[99456],{28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(96540);const a={},i=s.createContext(a);function o(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:t},e.children)}},82860:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>l,frontMatter:()=>o,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-7-semantic-versioning","title":"\ud83d\udcd3 2.2.0.7 Semantic Versioning","description":"When we install a JavaScript package, it will include a version number that looks something like this:","source":"@site/docs/2_intermediate-javascript/2_test-driven-development-and-environments-with-javascript/2-2-0-07-semantic-versioning.md","sourceDirName":"2_intermediate-javascript/2_test-driven-development-and-environments-with-javascript","slug":"/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-7-semantic-versioning","permalink":"/v1.2/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-7-semantic-versioning","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 2.2.0.7 Semantic Versioning","day":"weekend","id":"2-2-0-7-semantic-versioning","hide_table_of_contents":true},"sidebar":"intermediate-javascript","previous":{"title":"\ud83d\udcd3 2.2.0.6 Creating a package.json with npm","permalink":"/v1.2/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-6-creating-a-package-json-with-npm"},"next":{"title":"\ud83d\udcd3 2.2.0.8 Installing Dependencies with npm: webpack and webpack-cli","permalink":"/v1.2/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-8-installing-dependencies-with-npm-webpack-and-webpack-cli"}}');var a=n(74848),i=n(28453);const o={title:"\ud83d\udcd3 2.2.0.7 Semantic Versioning",day:"weekend",id:"2-2-0-7-semantic-versioning",hide_table_of_contents:!0},r=void 0,c={},h=[];function d(e){const t={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"When we install a JavaScript package, it will include a version number that looks something like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"4.46.0\n"})}),"\n",(0,a.jsx)(t.p,{children:"In fact, this is the version of webpack we'll be installing in future lessons."}),"\n",(0,a.jsx)(t.p,{children:"But what do these numbers even mean? Why are there multiple decimal points?"}),"\n",(0,a.jsxs)(t.p,{children:["This convention is used for ",(0,a.jsx)(t.strong,{children:"semantic versioning"}),". Semantic versioning just means that we are specifying the ",(0,a.jsx)(t.strong,{children:"major"})," version, the ",(0,a.jsx)(t.strong,{children:"minor"})," version, and the ",(0,a.jsx)(t.strong,{children:"patch"})," number. Semantic versioning is used in all sorts of software, not just npm packages."]}),"\n",(0,a.jsx)(t.p,{children:"It's important to understand these differences because you can run into a lot of trouble with your development environment otherwise."}),"\n",(0,a.jsxs)(t.p,{children:["The first number ",(0,a.jsx)(t.code,{children:"4"})," is the ",(0,a.jsx)(t.strong,{children:"major"}),' version. Major versions represent "breaking" changes to software. This doesn\'t mean the software is broken \u2014 it just means that the package is no longer backwards compatible. If you are using version ',(0,a.jsx)(t.code,{children:"3"})," and you upgrade to version ",(0,a.jsx)(t.code,{children:"4"}),' without actually updating your code to account for the changes, it will probably break your code. That\'s what "breaking changes" means. This is why software companies often use older ',(0,a.jsx)(t.strong,{children:"legacy"})," code. Legacy code just means the code isn't using the latest versions of all packages \u2014 and in some cases, the legacy code may be very old indeed. If a software company has a lot of code that's reliant on a specific package, they might not want to update to the latest version, even if it has great new features, because making that update will break the existing code."]}),"\n",(0,a.jsx)(t.p,{children:"In short, major versions mean major changes."}),"\n",(0,a.jsxs)(t.p,{children:["The second number (after the first decimal) is the ",(0,a.jsx)(t.strong,{children:"minor"})," version. In the number above, the minor version is ",(0,a.jsx)(t.code,{children:"46"}),". Minor version changes aren't breaking changes \u2014 and they are backwards compatible with other minor versions in that major version number. In other words, ",(0,a.jsx)(t.code,{children:"4.46"})," should be backwards compatible with ",(0,a.jsx)(t.code,{children:"4.01"})," because they have the same major version number. However, ",(0,a.jsx)(t.code,{children:"4.46"})," wouldn't be backwards compatible with ",(0,a.jsx)(t.code,{children:"3.99"})," because they have a different major version number."]}),"\n",(0,a.jsx)(t.p,{children:"Minor versions can still have updates or new functionality \u2014 it's just that they'll be backwards compatible with other minor versions in that major version. Keep in mind that minor versions can potentially introduce new bugs (as can new major versions), so having the latest version doesn't automatically mean that everything will be \"better\" \u2014 it just means updates have been made."}),"\n",(0,a.jsxs)(t.p,{children:["Finally, the third number (after the second decimal) is the ",(0,a.jsx)(t.strong,{children:"patch number"}),'. This is the number of patches that\'s been done on this minor version. A patch is something that "patches up" a bug or problem in the code.']}),"\n",(0,a.jsx)(t.p,{children:"Let's look at the number above again:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"4.46.0\n"})}),"\n",(0,a.jsx)(t.p,{children:"The major version is 4, the minor version is 46, and there have been 0 patches to this minor version."}),"\n",(0,a.jsxs)(t.p,{children:["As we mentioned before, this version number is for webpack, one of the most popular packages for JavaScript, React, and other JavaScript frameworks. It is well-funded and a large chunk of the JavaScript development community depends on it. Even so, it is ",(0,a.jsx)(t.em,{children:"constantly"})," being updated and changed \u2014 and even though it's a great piece of software, it has plenty of bugs, too."]}),"\n",(0,a.jsx)(t.p,{children:"At this point, you might wonder how semantic versioning applies to you. If you aren't building your own software and packages, why does it matter?"}),"\n",(0,a.jsx)(t.p,{children:"Well, software packages don't always play nicely with each other. Let's say that the makers of package A make a major version change. In the process, they think about compatibility with package B and package C because they are both widely used and industry standard. However, they don't think about compatibility with package Z, which is instrumental to your project. If we update package A in our project and it doesn't play nicely with package Z, our project will break. We may get an instructive error message or we might not \u2014 after all, the makers of package Z might not even know about this breaking change yet \u2014 or they might be open source and not have the resources to address the issue quickly. To make matters worse, there's often very little documentation (or none at all) about conflicts between package versions, especially if it's a very recent issue or it involves a less common combination of packages."}),"\n",(0,a.jsx)(t.p,{children:"This can even happen with minor versions or patch numbers. A change to the minor version or patch number just ensures that the changes are backwards compatible with itself \u2014 not every other package you might be using. That means even a change to a minor version or patch number in one package could cause an issue with another package we're working with, breaking our application. In fact, the more packages we work with, the more likely this becomes. We'll discuss how we can avoid these issues soon."}),"\n",(0,a.jsx)(t.p,{children:"It's important to remember that developing software is an iterative process \u2014 software is constantly changing, which means new bugs are being introduced (and fixed). Sometimes that process is exciting, sometimes it's frustrating, and sometimes it's overwhelming. In fact, if a product is no longer being changed, it's probably not because it's stable and finished. More likely, it's obsolete and no longer being maintained!"}),"\n",(0,a.jsx)(t.p,{children:"Also, before we move on \u2014 keep in mind that LearnHowToProgram.com follows the same iterative process. We, too, are constantly updating lessons to keep up with changes. In the process, we introduce (and fix) bugs. We also keep some legacy lessons and code because it doesn't always make sense to update to the latest, hottest version."}),"\n",(0,a.jsx)(t.p,{children:"As a developer, your job is to solve problems and overcome these challenges. Look at any bugs or issues you might run into as part of the process, whether they come from external projects, your own code, or even from LearnHowToProgram.com. We find that students do best when they keep their growth mindset and look at any issues they run into as positive challenges to learn from. After all, these are the exact challenges you'll run into the industry as well."})]})}function l(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);