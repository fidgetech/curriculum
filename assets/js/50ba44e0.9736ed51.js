"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[76112],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(96540);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}},67395:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"react/functional-programming-with-javascript/4-1-0-10-currying","title":"\ud83d\udcd3 4.1.0.10 Currying","description":"Currying is an essential functional programming concept named after the mathematician Haskell Curry.","source":"@site/docs/4_react/1_functional-programming-with-javascript/4-1-0-10-currying.md","sourceDirName":"4_react/1_functional-programming-with-javascript","slug":"/react/functional-programming-with-javascript/4-1-0-10-currying","permalink":"/v1.2/react/functional-programming-with-javascript/4-1-0-10-currying","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 4.1.0.10 Currying","day":"weekend","id":"4-1-0-10-currying","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 4.1.0.9 Closures","permalink":"/v1.2/react/functional-programming-with-javascript/4-1-0-9-closures"},"next":{"title":"\ud83d\udcd3 4.1.0.11 Map, Reduce and Filter","permalink":"/v1.2/react/functional-programming-with-javascript/4-1-0-11-map-reduce-and-filter"}}');var r=t(74848),o=t(28453);const s={title:"\ud83d\udcd3 4.1.0.10 Currying",day:"weekend",id:"4-1-0-10-currying",hide_table_of_contents:!0},a=void 0,c={},l=[];function u(e){const n={code:"code",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Currying"})," is an essential functional programming concept named after the mathematician Haskell Curry."]}),"\n",(0,r.jsxs)(n.p,{children:["When we ",(0,r.jsx)(n.strong,{children:"curry"})," a function, we take a function with multiple arguments and then rewrite it as a series of functions, each with one argument. A function with only one argument is also known as an ",(0,r.jsx)(n.strong,{children:"unary function"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Let's use currying to write a function to display our favorite (and not-so-favorite) things."}),"\n",(0,r.jsx)(n.p,{children:"Here's how the uncurried function might look:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function aThingIMaybeLike(howMuchILikeIt, thing, reason) {\n  return `I ${howMuchILikeIt} ${thing} because ${reason}.`;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"We could then call it like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'aThingIMaybeLike("really like", "functional programming", "it\'s cool");\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This will return ",(0,r.jsx)(n.code,{children:'"I really like functional programming because it\'s cool."'})]}),"\n",(0,r.jsxs)(n.p,{children:["We can curry this function by creating a series of nested anonymous functions inside the ",(0,r.jsx)(n.code,{children:"aThingIMaybeLike()"})," function:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function aThingIMaybeLike(howMuchILikeIt) {\n  return function(thing) {\n    return function(reason) {\n      return `I ${howMuchILikeIt} ${thing} because ${reason}.`;\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Each of these functions now take a single argument. In order to use this code, we need to do the following:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'aThingIMaybeLike("really like")("functional programming") ("it\'s cool")\n'})}),"\n",(0,r.jsx)(n.p,{children:"In the snippet above:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Our outer function ",(0,r.jsx)(n.code,{children:"aThingIMaybeLike(howMuchILikeIt)"})," takes ",(0,r.jsx)(n.code,{children:'"really like"'})," as an argument. When the function is invoked, it calls the first inner function ",(0,r.jsx)(n.code,{children:"function(thing)"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Our first inner function ",(0,r.jsx)(n.code,{children:"function(thing)"})," is then invoked with the second argument ",(0,r.jsx)(n.code,{children:'"functional programming"'}),". It, too, returns a function: the innermost anonymous ",(0,r.jsx)(n.code,{children:"function(reason)"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Finally, our innermost function returns the string ",(0,r.jsx)(n.code,{children:'"I really like functional programming because it\'s cool."'})]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"However, what's the point? Didn't we just write additional code to essentially do the same thing?"}),"\n",(0,r.jsx)(n.p,{children:"In the short term, yes. However, our curried function has additional powers: it's both more reusable and more flexible."}),"\n",(0,r.jsx)(n.p,{children:"For instance, we can do the following:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const thingsThatBugMe = aThingIMaybeLike("do not like");\n'})}),"\n",(0,r.jsx)(n.p,{children:"Now we can call this with the inner two arguments:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'thingsThatBugMe("global variables")("they are a code smell");\n> \'I do not like global variables because they are a code smell.\'\nthingsThatBugMe("functions with side effects")("they break code");\n> \'I do not like functions with side effects because they break code.\'\n'})}),"\n",(0,r.jsx)(n.p,{children:"We have additional flexibility to do this with multiple arguments as well:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const reasonILoveCoding = aThingIMaybeLike("love")("coding");\n'})}),"\n",(0,r.jsx)(n.p,{children:"If we try this out in the REPL, we'll see we can call our new function with just a single argument."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"> reasonILoveCoding(\"it is fun\");\n'I love coding because it is fun.'\n> reasonILoveCoding(\"I enjoy problem-solving\");\n'I love coding because I enjoy problem-solving.'\n"})}),"\n",(0,r.jsx)(n.p,{children:"Let's briefly return to our original function that takes three arguments:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function aThingIMaybeLike(howMuchILikeIt, thing, reason) {\n  return `I ${howMuchILikeIt} ${thing} because ${reason}.`;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This method may be fewer lines but it doesn't have nearly as much flexibility as our curried version. It has no reusability while we were able to use our curried function to create new functions that use 1, 2 or 3 arguments."}),"\n",(0,r.jsx)(n.p,{children:"Over the next few class sessions, try writing unary functions. Because each function should take only one argument, you will need to curry functions that would otherwise take multiple arguments. Note that you won't always be able to create a unary function. However, if a function takes too many arguments, that may also be a sign that it's trying to do too much."}),"\n",(0,r.jsx)(n.p,{children:"Currying is another complex concept that often takes some time to absorb. Don't worry \u2014 you will get more practice and we will cover more use cases in upcoming lessons."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}}}]);