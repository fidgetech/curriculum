"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[59300],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var o=n(96540);const s={},i=o.createContext(s);function a(e){const t=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(i.Provider,{value:t},e.children)}},49043:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/dynamic-id-in-dom-a8b914845c6fdd68c0d7422110e6973a.gif"},63617:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>r});const o=JSON.parse('{"id":"intermediate-javascript/object-oriented-javascript/2-1-1-4-address-book-adding-interactivity","title":"\ud83d\udcd3 2.1.1.4 Address Book: Adding Interactivity","description":"Now that we know how to loop through an object\'s keys (properties), let\'s update our user interface code so we can display all of the Contacts on our site.","source":"@site/versioned_docs/version-WIP/2_intermediate-javascript/1_object-oriented-javascript/2-1-1-04-address-book-adding-interactivity.md","sourceDirName":"2_intermediate-javascript/1_object-oriented-javascript","slug":"/intermediate-javascript/object-oriented-javascript/2-1-1-4-address-book-adding-interactivity","permalink":"/WIP/intermediate-javascript/object-oriented-javascript/2-1-1-4-address-book-adding-interactivity","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 2.1.1.4 Address Book: Adding Interactivity","day":"monday","id":"2-1-1-4-address-book-adding-interactivity","hide_table_of_contents":true},"sidebar":"intermediate-javascript","previous":{"title":"\ud83d\udcd3 2.1.1.3 Looping Through Objects and Prototypal Inheritance","permalink":"/WIP/intermediate-javascript/object-oriented-javascript/2-1-1-3-looping-through-objects-and-prototypal-inheritance"},"next":{"title":"\ud83d\udcd3 2.1.1.5 Address Book: Event Bubbling, Event Delegation, and the Event Object","permalink":"/WIP/intermediate-javascript/object-oriented-javascript/2-1-1-5-address-book-event-bubbling-event-delegation-and-the-event-object"}}');var s=n(74848),i=n(28453);const a={title:"\ud83d\udcd3 2.1.1.4 Address Book: Adding Interactivity",day:"monday",id:"2-1-1-4-address-book-adding-interactivity",hide_table_of_contents:!0},c=void 0,d={},r=[{value:"Displaying Dynamic <code>Contact</code> Data",id:"displaying-dynamic-contact-data",level:2},{value:"A Best Practice: Limiting How Many Times We Update the DOM",id:"a-best-practice-limiting-how-many-times-we-update-the-dom",level:3},{value:"Calling the <code>listContacts()</code> Function",id:"calling-the-listcontacts-function",level:3},{value:"Best Practices Review",id:"best-practices-review",level:2}];function l(e){const t={a:"a",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",hr:"hr",i:"i",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["Now that we know how to loop through an object's keys (properties), let's update our user interface code so we can display all of the ",(0,s.jsx)(t.code,{children:"Contact"}),"s on our site."]}),"\n",(0,s.jsxs)(t.h2,{id:"displaying-dynamic-contact-data",children:["Displaying Dynamic ",(0,s.jsx)(t.code,{children:"Contact"})," Data"]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsxs)(t.p,{children:["We'll start by writing an empty ",(0,s.jsx)(t.code,{children:"listContacts()"})," function below our global variable but above our ",(0,s.jsx)(t.code,{children:"handleFormSubmission()"})," function:"]}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"js/scripts.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:'...\n\n// User Interface Logic ---------\nlet addressBook = new AddressBook();\n\nfunction listContacts(addressBookToDisplay) {\n\n}\n\nfunction handleFormSubmission(event) {\n  event.preventDefault();\n  const inputtedFirstName = document.querySelector("input#new-first-name").value;\n  const inputtedLastName = document.querySelector("input#new-last-name").value;\n  const inputtedPhoneNumber = document.querySelector("input#new-phone-number").value;\n  let newContact = new Contact(inputtedFirstName, inputtedLastName, inputtedPhoneNumber);\n  addressBook.addContact(newContact);\n  console.log(addressBook);\n}\n\nwindow.addEventListener("load", function (){\n  document.querySelector("form#new-contact").addEventListener("submit", handleFormSubmission);\n});\n'})}),"\n",(0,s.jsxs)(t.p,{children:["As the function name states, this method will handle listing our contacts on the webpage. It takes an ",(0,s.jsx)(t.code,{children:"AddressBook"})," object as an argument. Also notice that we're creating a new function to handle displaying contacts in the DOM instead of adding onto our existing functions. This is a best practice. By separating our code into different functions distinct purposes, our code is cleaner, easier to read, and easier to debug and refactor."]}),"\n",(0,s.jsx)(t.p,{children:"Now let's actually write the code that goes in this method. We'll apply a new best practice along the way:"}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"js/scripts.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:'...\n\nfunction listContacts(addressBookToDisplay) {\n  let contactsDiv = document.querySelector("div#contacts");\n  contactsDiv.innerText =  null;\n  const ul = document.createElement("ul");\n  Object.keys(addressBookToDisplay.contacts).forEach(function(key) {\n    const contact = addressBookToDisplay.findContact(key);\n    const li = document.createElement("li");\n    li.append(contact.fullName());\n    li.setAttribute("id", contact.id);\n    ul.append(li);\n  });\n  contactsDiv.append(ul);\n}\n\n...\n'})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["First we save the div that will contain our contacts in a variable called ",(0,s.jsx)(t.code,{children:"contactsDiv"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["Next, we clear the ",(0,s.jsx)(t.code,{children:"innerText"})," of the ",(0,s.jsx)(t.code,{children:"contactsDiv"}),". This clears our list of contacts ",(0,s.jsx)(t.em,{children:"before"})," we populate it. We need to do this because our code is set up to loop through all contacts and print each one, not just newly added contacts. So, this ensures that the user can submit the form to create a new contact over and over and no duplicate contacts will be listed."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Next, we create an empty unordered list element. During each iteration of the loop, we'll add new list items to this unordered list."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["Then, we use ",(0,s.jsx)(t.code,{children:"Object.keys()"})," to get all the keys from ",(0,s.jsx)(t.code,{children:"addressBookToDisplay.contacts"})," so we can iterate through them. Remember, ",(0,s.jsx)(t.code,{children:"Object.keys()"})," returns an array, so we can call any array method on the returned value."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["Then, we use ",(0,s.jsx)(t.code,{children:"Array.prototype.forEach()"})," to loop through the object keys."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"In our loop, we do a few things to populate our unordered list with list items for each contact in our address book:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["We grab a ",(0,s.jsx)(t.code,{children:"contact"})," object by using our ",(0,s.jsx)(t.code,{children:"AddressBook.prototype.findContact()"})," method."]}),"\n",(0,s.jsxs)(t.li,{children:["We create a new list item element for the contact. The text of the list item is set to the contact's full name, and we add an ",(0,s.jsx)(t.code,{children:"id"})," attribute that is equal to the contact's ",(0,s.jsx)(t.code,{children:"id"})," property."]}),"\n",(0,s.jsx)(t.li,{children:"Then we add the newly created list item to the unordered list."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["After the loop is finished and our unordered list is populated, we update the DOM by appending the unordered list to the ",(0,s.jsx)(t.code,{children:"contactsDiv"})," element."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Take note that it is very important that each contact list item is being created with an ",(0,s.jsx)(t.code,{children:"id"})," attribute matching the ",(0,s.jsx)(t.code,{children:"Contact"}),"'s ",(0,s.jsx)(t.code,{children:"id"})," property. We can later retrieve the value of the ",(0,s.jsx)(t.code,{children:"id"})," attribute to use with our ",(0,s.jsx)(t.code,{children:"AddressBook.prototype.findContact()"})," method to locate an entire ",(0,s.jsx)(t.code,{children:"Contact"})," object. If we didn't attach this information to the list element, our application would have no way to easily get the ID."]}),"\n",(0,s.jsx)(t.h3,{id:"a-best-practice-limiting-how-many-times-we-update-the-dom",children:"A Best Practice: Limiting How Many Times We Update the DOM"}),"\n",(0,s.jsxs)(t.p,{children:["One thing to note in the design of the ",(0,s.jsx)(t.code,{children:"listContacts()"})," function is that we purposefully wrote our code to update the DOM just once. Querying the DOM takes time, whether we're simply accessing elements from it, or adding and removing elements. It's a best practice to design your code to access the DOM only when it's needed."]}),"\n",(0,s.jsxs)(t.p,{children:["To understand this, let's look at a different design for the ",(0,s.jsx)(t.code,{children:"listContacts()"})," function that is not as efficient as the one we currently have. In this alternate design, we don't use a div in our HTML to locate our contacts. Instead, we directly use a UL tag like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:'...\n    <h2>Contacts:</h2>\n    <ul id="contacts">\n    </ul>\n...\n'})}),"\n",(0,s.jsxs)(t.p,{children:["With this, we can update our ",(0,s.jsx)(t.code,{children:"listContacts()"})," function to look like the following. Notably this alternative version of ",(0,s.jsx)(t.code,{children:"listContacts()"})," takes fewer lines of code to achieve the same functionality:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'function listContacts(addressBookToDisplay) {\n  let contactsList = document.querySelector("ul#contacts");\n  Object.keys(addressBookToDisplay.contacts).forEach(function(key) {\n    const contact = addressBookToDisplay.findContact(key);\n    const li = document.createElement("li");\n    li.append(contact.fullName());\n    li.setAttribute("id", contact.id);\n    contactsList.append(li);\n  });\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"So what's different? Well, in each iteration of the loop we still create a list item that's set to the name of the contact. We also continue to add the contact to the unordered list. But now that unordered list is located in the DOM and not an element that we've newly created in our scripts. This means that every iteration of the loop we are querying the DOM to add a new list item to it."}),"\n",(0,s.jsxs)(t.p,{children:["Now let's say that our address book has one hundred contacts. This means that ",(0,s.jsx)(t.code,{children:"listContacts()"})," will query the DOM 100 times. That can really slow down the webpage, especially if there are many users on our address book application with lots of address books and contacts."]}),"\n",(0,s.jsxs)(t.p,{children:["Now contrast that to the current setup of ",(0,s.jsx)(t.code,{children:"listContacts()"}),":"]}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"js/scripts.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'function listContacts(addressBookToDisplay) {\n  let contactsDiv = document.querySelector("div#contacts");\n  contactsDiv.innerText =  null;\n  const ul = document.createElement("ul");\n  Object.keys(addressBookToDisplay.contacts).forEach(function(key) {\n    const contact = addressBookToDisplay.findContact(key);\n    const li = document.createElement("li");\n    li.append(contact.fullName());\n    li.setAttribute("id", contact.id);\n    ul.append(li);\n  });\n  contactsDiv.append(ul);\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"There's more lines of code, but this code is way more efficient because we only update the DOM with our list of contacts once, after it is completely populated and ready to go. So whether we have one contact or 100 contacts, we still only update the DOM a single time with the populated list of contacts."}),"\n",(0,s.jsx)(t.p,{children:"Limiting how many times you query the DOM is a best practice that you should work towards. That said, don't worry about getting it right 100% of the time, just start considering this when you are designing your UI logic."}),"\n",(0,s.jsxs)(t.h3,{id:"calling-the-listcontacts-function",children:["Calling the ",(0,s.jsx)(t.code,{children:"listContacts()"})," Function"]}),"\n",(0,s.jsxs)(t.p,{children:["Let's call this new ",(0,s.jsx)(t.code,{children:"listContacts"})," function whenever we add a new ",(0,s.jsx)(t.code,{children:"Contact"}),". All we have to do is remove our ",(0,s.jsx)(t.code,{children:"console.log()"})," and replace it with this new function."]}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"js/scripts.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:'...\nfunction handleFormSubmission(event) {\n  event.preventDefault();\n  const inputtedFirstName = document.querySelector("input#new-first-name").value;\n  const inputtedLastName = document.querySelector("input#new-last-name").value;\n  const inputtedPhoneNumber = document.querySelector("input#new-phone-number").value;\n  let newContact = new Contact(inputtedFirstName, inputtedLastName, inputtedPhoneNumber);\n  addressBook.addContact(newContact);\n  listContacts(addressBook);  // <--- This is the new line!\n}\n\nwindow.addEventListener("load", function (){\n  document.querySelector("form#new-contact").addEventListener("submit", handleFormSubmission);\n});\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Now each time we add a new ",(0,s.jsx)(t.code,{children:"Contact"}),", the page will update and add the contact's first and last names to the list of contacts. Try it out for yourself in the browser."]}),"\n",(0,s.jsxs)(t.p,{children:["If we open Chrome Developer Tools and inspect elements on the page (right-click and then select ",(0,s.jsx)(t.em,{children:"Inspect"}),") we'll see each ",(0,s.jsx)(t.code,{children:"Contact"}),"'s ",(0,s.jsx)(t.code,{children:"<li>"})," entry has a unique ",(0,s.jsx)(t.code,{children:"id"})," corresponding to the ",(0,s.jsx)(t.code,{children:"Contact"})," object's automatically-assigned ",(0,s.jsx)(t.code,{children:"id"})," property. The GIF below demonstrates this:"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"In the image, we can see that both of the contacts created have an ID.",src:n(49043).A+"",width:"500",height:"639"})}),"\n",(0,s.jsx)(t.p,{children:"While this ID isn't doing anything yet, we'll soon be adding functionality so that we can click on a contact and get additional information based on its ID."}),"\n",(0,s.jsxs)(t.p,{children:["After following along, our updated ",(0,s.jsx)(t.code,{children:"scripts.js"})," file looks like this:"]}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"js/scripts.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:'// Business Logic for AddressBook ---------\nfunction AddressBook() {\n  this.contacts = {};\n  this.currentId = 0;\n}\n\nAddressBook.prototype.addContact = function(contact) {\n  contact.id = this.assignId();\n  this.contacts[contact.id] = contact;\n};\n\nAddressBook.prototype.assignId = function() {\n  this.currentId += 1;\n  return this.currentId;\n};\n\nAddressBook.prototype.findContact = function(id) {\n  if (this.contacts[id] !== undefined) {\n    return this.contacts[id];\n  }\n  return false;\n};\n\nAddressBook.prototype.deleteContact = function(id) {\n  if (this.contacts[id] === undefined) {\n    return false;\n  }\n  delete this.contacts[id];\n  return true;\n};\n\n// Business Logic for Contacts ---------\nfunction Contact(firstName, lastName, phoneNumber) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n  this.phoneNumber = phoneNumber;\n}\n\nContact.prototype.fullName = function() {\n  return this.firstName + " " + this.lastName;\n};\n\n// User Interface Logic ---------\nlet addressBook = new AddressBook();\n\nfunction listContacts(addressBookToDisplay) {\n  let contactsDiv = document.querySelector("div#contacts");\n  contactsDiv.innerText =  null;\n  const ul = document.createElement("ul");\n  Object.keys(addressBookToDisplay.contacts).forEach(function(key) {\n    const contact = addressBookToDisplay.findContact(key);\n    const li = document.createElement("li");\n    li.append(contact.fullName());\n    li.setAttribute("id", contact.id);\n    ul.append(li);\n  });\n  contactsDiv.append(ul);\n}\n\nfunction handleFormSubmission(event) {\n  event.preventDefault();\n  const inputtedFirstName = document.querySelector("input#new-first-name").value;\n  const inputtedLastName = document.querySelector("input#new-last-name").value;\n  const inputtedPhoneNumber = document.querySelector("input#new-phone-number").value;\n  let newContact = new Contact(inputtedFirstName, inputtedLastName, inputtedPhoneNumber);\n  addressBook.addContact(newContact);\n  listContacts(addressBook);\n}\n\nwindow.addEventListener("load", function (){\n  document.querySelector("form#new-contact").addEventListener("submit", handleFormSubmission);\n});\n'})}),"\n",(0,s.jsx)(t.h2,{id:"best-practices-review",children:"Best Practices Review"}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.p,{children:"Let's recap some of the best practices we just used:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["We created a ",(0,s.jsx)(t.strong,{children:"separate UI function"})," instead of adding the code to an existing function, like our ",(0,s.jsx)(t.code,{children:"handleFormSubmission()"})," function. This allows us to focus on writing one function at a time, and helps keep code modular."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["We create a list of all elements we want to append to the DOM, and add them ",(0,s.jsx)(t.strong,{children:"all at once"})," instead of one a time. This is faster and more efficient."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"You aren't expected to master these best practices just yet, but you should consider them and practice integrating them in your code throughout the course. These kinds of details separate beginning coders from more experienced ones."}),"\n",(0,s.jsx)(t.p,{children:"In addition to these best practices, we also applied our new knowledge of looping through object keys."}),"\n",(0,s.jsx)(t.p,{children:"In the next lesson, we'll add UI functions that will allow us to display the detailed information of an individual contact onscreen."}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:(0,s.jsxs)(t.a,{href:"https://github.com/epicodus-lessons/oop-address-book-v2/tree/6_adding_interactivity",children:[(0,s.jsx)(t.i,{className:"glyphicon glyphicon-folder-open"}),"  Example GitHub Repo for the Address Book"]})})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);