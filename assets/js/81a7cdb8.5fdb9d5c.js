"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[76461],{13820:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"capstone/capstone-week-1/memoization","title":"\ud83d\udcd3 Memoization","description":"In this lesson, we\'ll cover an important dynamic programming technique known as memoization. Dynamic programming is the process of writing and executing code at runtime. Meanwhile, memoization is the process of caching the return values of time-consuming function calls, which then allows us to then just quickly grab the return value of the function from the cache instead of calling the function again. This can save a lot of time in a recursive function and is a powerful optimization technique.","source":"@site/versioned_docs/version-WIP/capstone/1_capstone-week-1/memoization.md","sourceDirName":"capstone/1_capstone-week-1","slug":"/capstone/capstone-week-1/memoization","permalink":"/WIP/capstone/capstone-week-1/memoization","draft":false,"unlisted":false,"tags":[],"version":"WIP","sidebarPosition":45,"frontMatter":{"title":"\ud83d\udcd3 Memoization","id":"memoization","slug":"memoization","hide_table_of_contents":true,"sidebar_position":45,"day":"thursday","type":"lesson","url":"https://github.com/epicodus-curriculum/capstone/blob/main/memoization.md"},"sidebar":"capstone","previous":{"title":"\ud83d\udcd3 Memory Basics","permalink":"/WIP/capstone/capstone-week-1/memory-basics"},"next":{"title":"\u270f\ufe0f Updating Your Portfolio","permalink":"/WIP/capstone/capstone-week-1/updating-your-portfolio"}}');var i=t(74848),a=t(28453);const s={title:"\ud83d\udcd3 Memoization",id:"memoization",slug:"memoization",hide_table_of_contents:!0,sidebar_position:45,day:"thursday",type:"lesson",url:"https://github.com/epicodus-curriculum/capstone/blob/main/memoization.md"},r=void 0,l={},c=[];function h(e){const n={a:"a",code:"code",em:"em",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["In this lesson, we'll cover an important dynamic programming technique known as ",(0,i.jsx)(n.strong,{children:"memoization"}),". Dynamic programming is the process of writing and executing code at runtime. Meanwhile, memoization is the process of caching the return values of time-consuming function calls, which then allows us to then just quickly grab the return value of the function from the cache instead of calling the function again. This can save a lot of time in a recursive function and is a powerful optimization technique."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's look at how memoization works. Imagine that you are in an unusual mathematic situation. Someone comes up to you and asks what ",(0,i.jsx)(n.code,{children:"349 * 719"})," is equal to. That's strange enough, right? But you oblige and work out the answer using pencil and paper. The answer is ",(0,i.jsx)(n.code,{children:"250931"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"A few minutes later, the situation gets even more unusual. Another person comes by and asks the same question \u2014 but you've forgotten the answer so you have to write it out again. That takes time since you've already recycled the piece of paper that had your previous solution."}),"\n",(0,i.jsxs)(n.p,{children:["After this happens several more times, you realize that it would be much more efficient to just memorize the answer instead of solving it every time someone asks about the product of ",(0,i.jsx)(n.code,{children:"349 * 719"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["While this kind of scenario would be very strange if it happened to humans, it happens all the time with computers. A function might ask, over and over again, for the answer to the exact same problem. If the function keeps asking for the answer to ",(0,i.jsx)(n.code,{children:"2*2"}),", that's no big deal. The answer to that can be computed so quickly that there's no need to memoize. However, if the function keeps asking for the answer to an extremely time-consuming problem, it would be better to save that answer \u2014 just as we'd do the same if people kept asking us over and over for the solution to the same complex problem."]}),"\n",(0,i.jsxs)(n.p,{children:["So how do we memoize a function? Well, we can store an expensive function call in a data structure like a Map. For instance, we know it takes a really long time to compute the ",(0,i.jsx)(n.code,{children:"answerToEverything()"}),". So once our supercomputers figure out the answer, we could do the following:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function answerToEverything() {\n  let computation = 0;\n  // Lots of computations!\n  return computation;\n};\nlet map = new Map();\nmap.set(answerToEverything, 42);\n"})}),"\n",(0,i.jsx)(n.p,{children:"In order to retrieve the answer, we just need to do the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"> map.get(answerToEverything);\n42\n"})}),"\n",(0,i.jsx)(n.p,{children:"We can also use memos to store the results of function calls with different arguments \u2014 and we'll get into that more in a moment."}),"\n",(0,i.jsx)(n.p,{children:"As we can see, we can store the results of a function call in a Map. But that's just one part of how memoization works. We don't just compute the value of a function call and then store it permanently."}),"\n",(0,i.jsxs)(n.p,{children:["Instead, memoization is only useful when there are ",(0,i.jsx)(n.em,{children:"repeated"})," function calls. After all, on that weird day when everyone wanted to know the answer to ",(0,i.jsx)(n.code,{children:"349 * 719"}),", we had to solve the problem first. And then, after people stopped asking us about ",(0,i.jsx)(n.code,{children:"349 * 719"}),", we forgot all about it. Which meant that when people started asking us the same question a year later, we had to solve the problem all over and then memorize it again."]}),"\n",(0,i.jsxs)(n.p,{children:["It's the same for a memoized function. A function call determines the answer and ",(0,i.jsx)(n.em,{children:"then"})," the call is memoized so that if the same function call with the same arguments happens again, there's no need for additional computation \u2014 the answer is already stored."]}),"\n",(0,i.jsx)(n.p,{children:"For this reason, memoization tends to be most useful for pure recursive functions. Functions need to be pure because memoization can't account for side effects. After all, how can you save side effects from somewhere else in an application in a memo's key-value pair? And it should be clear why memoization works so well for recursive functions. When the recursive function calls itself, it can just check the memo to see if it's already computed the return of that function instead of doing the computations all over again."}),"\n",(0,i.jsxs)(n.p,{children:["Let's build out a ",(0,i.jsx)(n.code,{children:"sillyCounterAdder()"})," function to demonstrate how this works. This is going to be a very silly example with clunky code but it will demonstrate how memoization works. Then, after we understand the basics, we can learn how to use memoization more elegantly."]}),"\n",(0,i.jsx)(n.p,{children:"The function below includes no memoization."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function sillyCounterAdder() {\n  let totalCalls = 0;\n  const hardComputation = function(counter) {\n    totalCalls++;\n    console.log(`totalCalls: ${totalCalls}`); \n    return (counter * counter + counter)/ counter;\n  }\n  let counter1 = 1;\n  let counter2 = 100;\n  let finalAnswer = 0;\n  while (counter1 <= 100) {\n    finalAnswer = finalAnswer + hardComputation(counter1);\n    counter1++;\n  }\n  while (counter2 > 0) {\n    finalAnswer = finalAnswer + hardComputation(counter2);\n    counter2--;\n  }\n  return finalAnswer;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This function holds another function called ",(0,i.jsx)(n.code,{children:"hardComputation"})," which is written as a function literal. The code here really isn't a very hard computation at all \u2014 at least not for our machines \u2014 but it's fine for our example. Just imagine that it's a much more complex computation that takes lots of time. We've also added a counter for ",(0,i.jsx)(n.code,{children:"totalCalls"})," that will be incremented each time it's called. We'll also log the total number of calls to the console so we can see exactly how many times we actually call the ",(0,i.jsx)(n.code,{children:"hardComputation"})," function."]}),"\n",(0,i.jsxs)(n.p,{children:["Next, we have two while loops summing a ",(0,i.jsx)(n.code,{children:"finalAnswer"}),". The first while loop goes from one to 100, calling ",(0,i.jsx)(n.code,{children:"hardComputation()"})," based on the counter's value. The second does the same all over again, but this time counting down from 100 to one instead."]}),"\n",(0,i.jsxs)(n.p,{children:["If we run this function in the console, we'll see that ",(0,i.jsx)(n.code,{children:"hardComputation()"})," is called 200 times. However, we can see that the function gets called with the exact same argument twice. For instance, ",(0,i.jsx)(n.code,{children:"hardComputation(50)"})," is called twice, once in the first while loop as the counter is incrementing and then again in the second while loop when the second counter is decrementing. Because ",(0,i.jsx)(n.code,{children:"hardComputation()"})," actually isn't that complex, the duplicate calls are trivial. But imagine that the computation was so hard that it would take a computer a full second to compute each time. In that case, the ",(0,i.jsx)(n.code,{children:"sillyAdderCounter()"})," function will take 200 seconds to run. Instead, we can use memoization to remove the duplicate calls and make our function much more efficient."]}),"\n",(0,i.jsx)(n.p,{children:"Let's see how. The code is going to get even more clunky \u2014 but again, that's to illustrate how memoization works."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'function sillyCounterAdder() {\n  // Add memo object.\n  let memo = new Map();\n  let totalCalls = 0;\n  const hardComputation = function(counter) {\n    totalCalls++;\n    console.log(`totalCalls: ${totalCalls}`); \n    return (counter * counter + counter)/ counter;\n  }\n  let counter1 = 1;\n  let counter2 = 100;\n  let finalAnswer = 0;\n  while (counter1 <= 100) {\n    // Check to see if value is in memo.\n    if (memo.has(counter1)) {\n      // If it\'s in memo, grab the value from the memo instead of calling the function.\n      finalAnswer = finalAnswer + memo.get(counter1);\n      console.log("Value retrieved from memo in first while loop!");\n    } else {\n      // If it\'s not in memo, compute the function call and also add it to the memo.\n      const computation = hardComputation(counter1);\n      memo.set(counter1, computation);\n      finalAnswer = finalAnswer + computation;\n      console.log("Memoized in first while loop!");\n    }\n    counter1++;\n  }\n  while (counter2 > 1) {\n    // Check to see if value is in memo.\n    if (memo.has(counter2)) {\n      // If it\'s in memo, grab the value from the memo instead of calling the function.\n      finalAnswer = finalAnswer + memo.get(counter2);\n      console.log("Value retrieved from memo in second while loop!");\n    } else {\n      // If it\'s not in memo, compute the function call and also add it to the memo.\n      const computation = hardComputation(counter2);\n      memo.set(counter2, computation);\n      finalAnswer = finalAnswer + computation;\n      console.log("Memoized in second while loop!");\n    }\n    counter2--;\n  }\n  return finalAnswer;\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Let's take a closer look at how memoization is working in this code."}),"\n",(0,i.jsxs)(n.p,{children:["First we create a new ",(0,i.jsx)(n.code,{children:"memo"})," object:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let memo = new Map();\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Next, in both while loops, we check to see if the memo has a key for the specific argument we're passing into ",(0,i.jsx)(n.code,{children:"hardComputation()"}),". Let's take a look at what's happening in the first while loop."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'if (memo.has(counter1)) {\n  finalAnswer = finalAnswer + memo.get(counter1);\n  console.log("Value retrieved from memo in first while loop!");\n} else {\n  const computation = hardComputation(counter1);\n  memo.set(counter1, computation);\n  finalAnswer = finalAnswer + computation;\n  console.log("Memoized in first while loop!");\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["First, the conditional checks if the memo has a key for the value of ",(0,i.jsx)(n.code,{children:"counter1"}),". If it does, we can just grab the value associated with that key from the memo."]}),"\n",(0,i.jsxs)(n.p,{children:["Otherwise, we need to call that function, set the key-value pair for that argument and its return in the memo, and then add it to the ",(0,i.jsx)(n.code,{children:"finalAnswer"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The exact same thing happens in the second while loop as well. The code isn't DRY but the purpose here is to see when the function call is memoized and when we can skip the function call and just get the result from the memo instead."}),"\n",(0,i.jsx)(n.p,{children:"Before running this function in the console, try to figure out the answer to the following questions. Don't worry, there are no trick questions here. The answers are straightforward."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["How many times will ",(0,i.jsx)(n.code,{children:'"value retrieved from memo in first while loop!"'})," be logged to the console?"]}),"\n",(0,i.jsxs)(n.li,{children:["How many times will ",(0,i.jsx)(n.code,{children:'"memoized in first while loop!"'})," be logged to the console?"]}),"\n",(0,i.jsxs)(n.li,{children:["How many times will ",(0,i.jsx)(n.code,{children:'"value retrieved from memo in second while loop!"'})," be logged to the console?"]}),"\n",(0,i.jsxs)(n.li,{children:["How many times will ",(0,i.jsx)(n.code,{children:'"memoized in second while loop!"'})," be logged to the console?"]}),"\n",(0,i.jsxs)(n.li,{children:["How many total calls will be made to ",(0,i.jsx)(n.code,{children:"hardComputation()"}),"?"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Go ahead and try the ",(0,i.jsx)(n.code,{children:"sillyCounterAdder()"})," function in the console and see if your answers are correct."]}),"\n",(0,i.jsxs)(n.p,{children:["You'll see that the first while loop never retrieves values from the memo. Instead, every value gets memoized. The ",(0,i.jsx)(n.code,{children:"hardComputation()"})," function needs to be called for every argument from one to 100 \u2014 and each of these values will be memoized in a key-value pair where the key corresponds to the argument and the value corresponds to the result of the function. So the answer to the first question is 0 while the answer to the second question is 100."]}),"\n",(0,i.jsxs)(n.p,{children:["Then, in the second while loop, we need to grab all the values of ",(0,i.jsx)(n.code,{children:"hardComputation()"})," from 100 all the way down to one. Well, all of these values were memoized in the first while loop. That means the value will be retrieved from the memo 100 times while memoization will happen zero times in the second while loop."]}),"\n",(0,i.jsxs)(n.p,{children:["The total number of calls to ",(0,i.jsx)(n.code,{children:"hardComputation()"})," will be 100 instead of 200 \u2014 so we've cut our calls in half. If each of these calls took one second, we are cutting down the total time it takes to run the ",(0,i.jsx)(n.code,{children:"sillyCounterAdder()"})," from nearly three and a half minutes to under two minutes."]}),"\n",(0,i.jsx)(n.p,{children:"Obviously, this is a very contrived example \u2014 but the purpose of the code above is to show how memoization works. If the value of a time-consuming function call doesn't exist in the memo, it is memoized. If the value does exist, it's grabbed from the memo, which is much faster than calling the time-consuming function all over again. Memoization is such a powerful technique that it can be one of the biggest time-savers in a recursive function. Imagine, for instance, a recursive function that has to call itself with a specific argument thousands of times. If that value already exists in a map, you are reducing all those function calls down to a single function call \u2014 plus however many times you need to look up a key-value pair in the map, which is an extremely fast process."}),"\n",(0,i.jsxs)(n.p,{children:["The example above works perfectly fine when it comes to explaining how memoization works. However, it's not reusable at all. Wouldn't it be so much nicer if we could just write a ",(0,i.jsx)(n.code,{children:"memoize()"})," function that we could apply to any recursive function?"]}),"\n",(0,i.jsxs)(n.p,{children:["Well, we can use some of the functional programming techniques we've learned in the past to do exactly that. Specifically, we'll need to use a closure and take advantage of the fact that JavaScript functions are first-class citizens that can be passed around as arguments. Let's write a ",(0,i.jsx)(n.code,{children:"memoize()"})," function that works for functions that take a single argument."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function memoize(func) {\n  let memo = new Map();\n  return function(argument) {\n    if (memo.has(argument)) {\n      return memo.get(argument);\n    } else {\n      const value = func(argument);\n      memo.set(argument, value);\n      return value;\n    }\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now let's take a closer look at what's happening here. Our ",(0,i.jsx)(n.code,{children:"memoize()"})," function takes a function (",(0,i.jsx)(n.code,{children:"func"}),") as an argument. When it's called, it will create a new map for that specific function called ",(0,i.jsx)(n.code,{children:"memo"}),". So we can do the following inside our ",(0,i.jsx)(n.code,{children:"sillyCounterAdder()"})," function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let memo = memoize(hardComputation);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This will create a closure. Whenever we call ",(0,i.jsx)(n.code,{children:"memo(argument)"}),", this function will be called:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"\nfunction(argument) {\n  if (memo.has(argument)) {\n    return memo.get(argument);\n  } else {\n    const value = func(argument);\n    memo.set(argument, value);\n    return value;\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["So when we create a closure with ",(0,i.jsx)(n.code,{children:"let memo = memoize(hardComputation)"}),", the value of ",(0,i.jsx)(n.code,{children:"func"})," will always be ",(0,i.jsx)(n.code,{children:"hardComputation"})," for this particular closure."]}),"\n",(0,i.jsxs)(n.p,{children:["So let's say that we want to memoize or grab the value of ",(0,i.jsx)(n.code,{children:"hardComputation(1)"}),". Well, we call ",(0,i.jsx)(n.code,{children:"memo(1)"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If the memo contains the key of 1 (",(0,i.jsx)(n.code,{children:"memo.has(argument)"}),"), it will return the value associated with that key (",(0,i.jsx)(n.code,{children:"memo.get(argument)"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["However, if it doesn't, our ",(0,i.jsx)(n.code,{children:"memo()"})," function will call the function with that specific argument and store that in ",(0,i.jsx)(n.code,{children:"const value"}),"). It will memoize that key-value pair (",(0,i.jsx)(n.code,{children:"memo.set(argument, value)"}),") and then it will return the ",(0,i.jsx)(n.code,{children:"value"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Either way, this function returns the correct value. If the key exists, it just grabs the value from the map we've created. Super fast. If it doesn't, it calls the function, memoizes it, and returns the value \u2014 so it will be super fast the next time we call the function with the same argument."}),"\n",(0,i.jsxs)(n.p,{children:["Let's refactor our ",(0,i.jsx)(n.code,{children:"sillyCounterAdder()"})," function to use our new ",(0,i.jsx)(n.code,{children:"memoize()"})," function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function sillyCounterAdder() {\n  let totalCalls = 0;\n  const hardComputation = function(counter) {\n    totalCalls++;\n    console.log(`totalCalls: ${totalCalls}`); \n    return (counter * counter + counter)/ counter;\n  }\n  // Here's where we create our closure.\n  let memo = memoize(hardComputation);\n  let counter1 = 1;\n  let counter2 = 100;\n  let finalAnswer = 0;\n  while (counter1 <= 100) {\n    finalAnswer = finalAnswer + memo(counter1);\n    counter1++;\n  }\n  while (counter2 > 1) {\n    finalAnswer = finalAnswer + memo(counter2);\n    counter2--;\n  }\n  return finalAnswer;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Here's what's changed in the code."}),"\n",(0,i.jsx)(n.p,{children:"First, we create a closure with the following line:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let memo = memoize(hardComputation);\n"})}),"\n",(0,i.jsx)(n.p,{children:"We've already explained how this works so let's skip ahead to where it's used:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"finalAnswer = finalAnswer + memo(counter1);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["There's no longer any need for conditionals. Our new ",(0,i.jsx)(n.code,{children:"memo()"})," function (created from our ",(0,i.jsx)(n.code,{children:"memoize()"})," function) simply has to take the current argument and either memoize the function result and return it or, if the key-value pair already exists in the memo, just grab it and return that value without making the function call."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"sillyCounterAdder()"})," is still quite silly but the ",(0,i.jsx)(n.code,{children:"memoize()"})," function is an excellent, concise solution for adding memoization to ",(0,i.jsx)(n.em,{children:"any"})," function we like (provided it has one argument). If you try out the code above, you'll see that just 100 function calls are made instead of 200. We've effectively used memoization to reduce the number of function calls by half."]}),"\n",(0,i.jsx)(n.p,{children:"The next step is for you to do some practice on your own."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["First, update the ",(0,i.jsx)(n.code,{children:"memoize()"})," function so it can take any number of arguments."]}),"\n",(0,i.jsxs)(n.li,{children:["Next, write a recursive function called ",(0,i.jsx)(n.code,{children:"fibonacci()"})," that determines a value at a specific position in the ",(0,i.jsx)(n.a,{href:"https://www.mathsisfun.com/numbers/fibonacci-sequence.html",children:"Fibonacci sequence"}),". The Fibonacci sequence is a very popular programming problem to use with memoization. Your first solution shouldn't use memoization yet, though."]}),"\n",(0,i.jsxs)(n.li,{children:["Finally, use the ",(0,i.jsx)(n.code,{children:"memoize()"})," function to make your ",(0,i.jsx)(n.code,{children:"fibonacci()"})," function more efficient."]}),"\n",(0,i.jsx)(n.li,{children:"Have you solved any other problems recursively that could use memoization? Look back at some of these solutions and determine whether they can benefit from memoization. If so, try to incorporate memoization into your solution. If not, write up your reasons why not \u2014 or share them with a pair."}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var o=t(96540);const i={},a=o.createContext(i);function s(e){const n=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);