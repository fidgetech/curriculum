"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[86226],{28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>d});var s=n(96540);const i={},a=s.createContext(i);function o(e){const t=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:t},e.children)}},93645:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>d,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"c-and-net/database-basics/3-3-0-14-finding-objects-in-the-database","title":"\ud83d\udcd3 3.3.0.14 Finding Objects in the Database","description":"Now that we can successfully save Items to the database, we\'re ready to update our Find() method to so that we can retrieve specific Items by their ID.","source":"@site/versioned_docs/version-v1_3/3_c-and-net/3_database-basics/3-3-0-14-finding-objects-in-the-database.md","sourceDirName":"3_c-and-net/3_database-basics","slug":"/c-and-net/database-basics/3-3-0-14-finding-objects-in-the-database","permalink":"/v1.3/c-and-net/database-basics/3-3-0-14-finding-objects-in-the-database","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 3.3.0.14 Finding Objects in the Database","day":"weekend","id":"3-3-0-14-finding-objects-in-the-database","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.3.0.13 Saving Objects in the Database","permalink":"/v1.3/c-and-net/database-basics/3-3-0-13-saving-objects-in-the-database"},"next":{"title":"\ud83d\udcd3 3.3.0.15 More SQL Queries","permalink":"/v1.3/c-and-net/database-basics/3-3-0-15-more-sql-queries"}}');var i=n(74848),a=n(28453);const o={title:"\ud83d\udcd3 3.3.0.14 Finding Objects in the Database",day:"weekend",id:"3-3-0-14-finding-objects-in-the-database",hide_table_of_contents:!0},d=void 0,r={},c=[{value:"Writing a Test for <code>Find()</code>",id:"writing-a-test-for-find",level:2},{value:"Writing a <code>Find()</code> Method",id:"writing-a-find-method",level:2},{value:"Repository Reference",id:"repository-reference",level:3}];function l(e){const t={a:"a",code:"code",div:"div",h2:"h2",h3:"h3",hr:"hr",i:"i",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["Now that we can successfully save ",(0,i.jsx)(t.code,{children:"Item"}),"s to the database, we're ready to update our ",(0,i.jsx)(t.code,{children:"Find()"})," method to so that we can retrieve specific ",(0,i.jsx)(t.code,{children:"Item"}),"s by their ID."]}),"\n",(0,i.jsxs)(t.h2,{id:"writing-a-test-for-find",children:["Writing a Test for ",(0,i.jsx)(t.code,{children:"Find()"})]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsxs)(t.p,{children:["Our current ",(0,i.jsx)(t.code,{children:"Find()"})," method just returns a placeholder item so we won't have compiler errors. We also have a commented-out test for our ",(0,i.jsx)(t.code,{children:"Find()"})," method as well. We only have to make a few small changes to our test to get it working again. Specifically, our test needs to ",(0,i.jsx)(t.code,{children:"Save()"})," ",(0,i.jsx)(t.code,{children:"Item"}),"s now. Here's our updated test:"]}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ToDoList.Tests/ModelTests/ItemTests.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'    [TestMethod]\n    public void Find_ReturnsCorrectItemFromDatabase_Item()\n    {\n      //Arrange\n      Item newItem = new Item("Mow the lawn");\n      newItem.Save();\n      Item newItem2 = new Item("Wash dishes");\n      newItem2.Save();\n\n      //Act\n      Item foundItem = Item.Find(newItem.Id);\n      //Assert\n      Assert.AreEqual(newItem, foundItem);\n    }\n'})}),"\n",(0,i.jsxs)(t.p,{children:["We simply ",(0,i.jsx)(t.code,{children:"Save()"})," two items and then ",(0,i.jsx)(t.code,{children:"Find()"})," one of them by its ",(0,i.jsx)(t.code,{children:"Id"}),". The test will fail because our ",(0,i.jsx)(t.code,{children:"Find()"})," method currently returns a placeholder item."]}),"\n",(0,i.jsxs)(t.h2,{id:"writing-a-find-method",children:["Writing a ",(0,i.jsx)(t.code,{children:"Find()"})," Method"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsxs)(t.p,{children:["Let's add code to ",(0,i.jsx)(t.code,{children:"Find()"})," to make this test pass. Just as we've done with our ",(0,i.jsx)(t.code,{children:"GetAll()"})," and ",(0,i.jsx)(t.code,{children:"Save()"})," methods, we'll start with the whole method. We've added comments to the method to emphasize that its parts are very similar to the database-backed methods we've created already."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'public static Item Find(int id)\n{\n  // We open a connection.\n  MySqlConnection conn = new MySqlConnection(DBConfiguration.ConnectionString);\n  conn.Open();\n\n  // We create MySqlCommand object and add a query to its CommandText property. \n  // We always need to do this to make a SQL query.\n  MySqlCommand cmd = conn.CreateCommand() as MySqlCommand;\n  cmd.CommandText = "SELECT * FROM items WHERE id = @ThisId;";\n\n  // We have to use parameter placeholders @ThisId and a `MySqlParameter` object to \n  // prevent SQL injection attacks. \n  // This is only necessary when we are passing parameters into a query. \n  // We also did this with our Save() method.\n  MySqlParameter param = new MySqlParameter();\n  param.ParameterName = "@ThisId";\n  param.Value = id;\n  cmd.Parameters.Add(param);\n\n  // We use the ExecuteReader() method because our query will be returning results and \n  // we need this method to read these results. \n  // This is in contrast to the ExecuteNonQuery() method, which \n  // we use for SQL commands that don\'t return results like our Save() method.\n  MySqlDataReader rdr = cmd.ExecuteReader() as MySqlDataReader;\n  int itemId = 0;\n  string itemDescription = "";\n  while (rdr.Read())\n  {\n    itemId = rdr.GetInt32(0);\n    itemDescription = rdr.GetString(1);\n  }\n  Item foundItem = new Item(itemDescription, itemId);\n\n  // We close the connection.\n  conn.Close();\n  if (conn != null)\n  {\n    conn.Dispose();\n  }\n  return foundItem;\n}\n'})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Our method takes a parameter ",(0,i.jsx)(t.code,{children:"id"})," of type ",(0,i.jsx)(t.code,{children:"int"}),". This is the ID of the record we want to retrieve from the database. Note that it's a static method called on the class itself."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["We open a connection and create a ",(0,i.jsx)(t.code,{children:"MySqlCommand"})," object. We've covered this with our other database methods."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["We set the ",(0,i.jsx)(t.code,{children:"commandText"})," equal to the query ",(0,i.jsx)(t.code,{children:'"SELECT * FROM items WHERE id = @ThisId;"'}),". Just as we did with our ",(0,i.jsx)(t.code,{children:"Save()"})," method, we use a parameter placeholder ",(0,i.jsx)(t.code,{children:"@ThisId"}),". Then we instantiate a new ",(0,i.jsx)(t.code,{children:"MySqlParameter"})," object, assign ",(0,i.jsx)(t.code,{children:"@ThisId"})," as it's ",(0,i.jsx)(t.code,{children:"ParameterName"})," and ",(0,i.jsx)(t.code,{children:"id"})," as it's ",(0,i.jsx)(t.code,{children:"Value"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Note that we do the following: ",(0,i.jsx)(t.code,{children:'int itemId = 0; string itemDescription = "";'})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["This is because our ",(0,i.jsx)(t.code,{children:"Find()"})," method may not return a result. For instance, if we were to try ",(0,i.jsx)(t.code,{children:"Item.find(23453)"}),", our application would break if we didn't include the above default values."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"We convert the found record into a C# object and then close the connection."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["We've gone through this method fairly quickly because most of its parts are already familiar from our ",(0,i.jsx)(t.code,{children:"GetAll()"})," and ",(0,i.jsx)(t.code,{children:"Save()"})," methods."]}),"\n",(0,i.jsxs)(t.p,{children:["At this point we can uncomment all of our ",(0,i.jsx)(t.code,{children:"Item"})," tests and they should pass, and our application will now work again in the browser. We can now have all the code we need for the CR part of CRUD functionality. We can create new ",(0,i.jsx)(t.code,{children:"Item"}),"s, view a list of ",(0,i.jsx)(t.code,{children:"Item"}),"s, or use our ",(0,i.jsx)(t.code,{children:"Find()"})," method to help us view a single ",(0,i.jsx)(t.code,{children:"Item"}),"'s detail."]}),"\n",(0,i.jsx)(t.p,{children:"We'll save update and delete functionality for working with Entity Framework Core, but you are welcome to explore and try adding this functionality into your own applications before then."}),"\n",(0,i.jsx)(t.h3,{id:"repository-reference",children:"Repository Reference"}),"\n",(0,i.jsx)(t.p,{children:"Follow the link below to view the completed To Do List project that uses MySqlConnector and custom database methods to communicate with a MySQL database."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:(0,i.jsxs)(t.a,{href:"https://github.com/epicodus-lessons/section-3-to-do-list-with-mysqlconnector-csharp-net6",children:[(0,i.jsx)(t.i,{className:"glyphicon glyphicon-folder-open"})," Example GitHub Repo for To Do List with MySqlConnector"]})})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);