"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[98814],{8664:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"capstone/capstone-week-1/selection-sort","title":"\ud83d\udcd3 Selection Sort","description":"A selection sort algorithm is one of the simplest sort algorithms we can learn. In fact, if you tried to implement a sort algorithm on your own, there\'s a decent chance that it is a selection sort. In a selection sort algorithm, we start by looping through our array. We then take the current index and loop through every remaining element in the array, swapping as needed until the index is the lowest remaining value.","source":"@site/docs/capstone/1_capstone-week-1/selection-sort.md","sourceDirName":"capstone/1_capstone-week-1","slug":"/capstone/capstone-week-1/selection-sort","permalink":"/v1.2/capstone/capstone-week-1/selection-sort","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":36,"frontMatter":{"title":"\ud83d\udcd3 Selection Sort","id":"selection-sort","slug":"selection-sort","hide_table_of_contents":true,"sidebar_position":36,"day":"thursday","type":"lesson","url":"https://github.com/epicodus-curriculum/capstone/blob/main/selection_sort.md"},"sidebar":"capstone","previous":{"title":"\ud83d\udcd3 Insertion Sort","permalink":"/v1.2/capstone/capstone-week-1/insertion-sort"},"next":{"title":"\ud83d\udcd3 Bubble Sort","permalink":"/v1.2/capstone/capstone-week-1/bubble-sort"}}');var o=n(74848),a=n(28453);const i={title:"\ud83d\udcd3 Selection Sort",id:"selection-sort",slug:"selection-sort",hide_table_of_contents:!0,sidebar_position:36,day:"thursday",type:"lesson",url:"https://github.com/epicodus-curriculum/capstone/blob/main/selection_sort.md"},s=void 0,l={},h=[{value:"Clues",id:"clues",level:3},{value:"Final Solution",id:"final-solution",level:3}];function c(e){const t={code:"code",em:"em",h3:"h3",p:"p",pre:"pre",strong:"strong",sup:"sup",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["A ",(0,o.jsx)(t.strong,{children:"selection sort"})," algorithm is one of the simplest sort algorithms we can learn. In fact, if you tried to implement a sort algorithm on your own, there's a decent chance that it is a selection sort. In a selection sort algorithm, we start by looping through our array. We then take the current index and loop through every ",(0,o.jsx)(t.em,{children:"remaining"})," element in the array, swapping as needed until the index is the lowest remaining value."]}),"\n",(0,o.jsx)(t.p,{children:"Let's walk through a simple example which should make this clearer. Here's an unsorted array:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"let array = [3,2,1];\n"})}),"\n",(0,o.jsxs)(t.p,{children:["We need to loop through this array. On the first iteration through the loop, the index is ",(0,o.jsx)(t.code,{children:"3"}),". Now we need to compare that to every remaining element in the array by looping through the remaining elements."]}),"\n",(0,o.jsxs)(t.p,{children:["Is ",(0,o.jsx)(t.code,{children:"3"})," greater than ",(0,o.jsx)(t.code,{children:"2"}),"? It is. So we swap. Now the array looks like this:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"array = [2,3,1];\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The first element in the array has changed \u2014 but we are still comparing it to remaining elements in the array. There is only one element left in the array to compare to: is ",(0,o.jsx)(t.code,{children:"2"})," greater than ",(0,o.jsx)(t.code,{children:"1"}),"? Yes, it is. So we swap again. Our array now looks like this:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"array = [1,3,2];\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The end result of all that swapping is that the first element in the array is now the element with the lowest value. It's been sorted \u2014 though as you can probably imagine, in a very large array, we'd probably need to do a ",(0,o.jsx)(t.em,{children:"lot"})," of swapping to do this."]}),"\n",(0,o.jsxs)(t.p,{children:["So now it's time for our second iteration through the outer loop. The value at the second position is ",(0,o.jsx)(t.code,{children:"3"}),". We only need to compare it against the ",(0,o.jsx)(t.em,{children:"remaining"})," elements in the array \u2014 all elements that come before it have already been sorted. So now we just need to compare it to the last element in the array. Remember, this is our inner loop \u2014 but because there is only one element left in the array, our inner loop will only perform one more iteration."]}),"\n",(0,o.jsxs)(t.p,{children:["Is the element at the current index (",(0,o.jsx)(t.code,{children:"3"}),") greater than the element we are comparing it to (",(0,o.jsx)(t.code,{children:"2"}),")? Yes, it is. So we swap. Here's the array now:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"array = [1,2,3];\n"})}),"\n",(0,o.jsx)(t.p,{children:"We then go to the final element in the array \u2014 but there are no remaining values to compare it to so we are finished."}),"\n",(0,o.jsx)(t.p,{children:"The next step is to try to implement the selection sort on your own. Go ahead and try to do this. We recommend implementing TDD though you can also try to whiteboard the solution as well."}),"\n",(0,o.jsx)(t.p,{children:"If you are stumped, read a clue and then continue trying to solve the problem. This is what would happen in an actual technical interview \u2014 an interviewer might prompt you, which could help you get to the next step."}),"\n",(0,o.jsx)(t.p,{children:"If the clue isn't helpful because you've already solved that part of the equation, go to the next clue."}),"\n",(0,o.jsx)(t.h3,{id:"clues",children:"Clues"}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Clue #1:"})," You need to loop through each element in the array. Your first step is to add an outer loop that iterates through the current index. That can be a simple ",(0,o.jsx)(t.code,{children:"for"})," loop:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"for (let i = 0; i < array.length; i ++) {\n  // Code for comparing will go here.\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Clue #2:"})," You are going to need to iterate through every ",(0,o.jsx)(t.em,{children:"remaining"})," element in the array. In other words, from the element ",(0,o.jsx)(t.em,{children:"after"})," the current index until the end of the array. We can do this with another ",(0,o.jsx)(t.code,{children:"for"})," loop:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"for (let i = 0; i < array.length; i ++) {\n  for (let j = i+1; j < array.length; j++) {\n    // Here's where we need to compare the element at position i to the element at position j.\n  }\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Clue #3:"})," We need a conditional that compares the array at position ",(0,o.jsx)(t.code,{children:"i"})," to the array at position ",(0,o.jsx)(t.code,{children:"j"}),". And if the value at position ",(0,o.jsx)(t.code,{children:"i"})," is ",(0,o.jsx)(t.em,{children:"greater"})," than the value at position ",(0,o.jsx)(t.code,{children:"j"}),", we need to swap the two values \u2014 because we always want the ",(0,o.jsx)(t.em,{children:"lowest"})," value at position ",(0,o.jsx)(t.code,{children:"i"})," (the element we are currently trying to sort)."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"if (array[i] > array[j]) {\n  // If this is the case, we need to swap the values!\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Clue #4:"})," It's time to swap. But be careful! We can't just do the following:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"array[i] = array[j]\narray[j] = array[i]\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Can you see why not? Well, if we update ",(0,o.jsx)(t.code,{children:"array[i]"})," to the value of ",(0,o.jsx)(t.code,{children:"array[j]"}),", we'll lose the former value of ",(0,o.jsx)(t.code,{children:"array[i]"})," \u2014 and we won't be able to correctly reassign the value of ",(0,o.jsx)(t.code,{children:"array[j]"})," to what ",(0,o.jsx)(t.code,{children:"array[i]"})," used to be. So we need to assign it in a variable. For instance, we could do this:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"let higherValue = array[i];\narray[i] = array[j]\narray[j] = higherValue;\n"})}),"\n",(0,o.jsx)(t.h3,{id:"final-solution",children:"Final Solution"}),"\n",(0,o.jsxs)(t.p,{children:["As we discussed in the clues, we need an outer and an inner loop. The outer loop iterates through the entire array while the inner loop compares the current index with each element that comes ",(0,o.jsx)(t.em,{children:"after"})," the current index, swapping the current index with the index to compare as needed. Here's the final code:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"function selectionSort(array) {\n  for (let currentIndex = 0; currentIndex < array.length; currentIndex++) {\n    for (let indexToCompare = currentIndex+1; indexToCompare < array.length; indexToCompare++) {\n      if (array[currentIndex] > array[indexToCompare]) {\n        const higherValue = array[currentIndex];\n        array[currentIndex] = array[indexToCompare];\n        array[indexToCompare] = higherValue;\n      }\n    }\n  }\n  return array;\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["As we can see, the inner loop iterates from ",(0,o.jsx)(t.code,{children:"currentIndex + 1"})," to less than the ",(0,o.jsx)(t.code,{children:"array.length"})," \u2014 that's all the remaining elements in the array!"]}),"\n",(0,o.jsxs)(t.p,{children:["Then it checks if the array at the ",(0,o.jsx)(t.code,{children:"currentIndex"})," position is greater than the array at ",(0,o.jsx)(t.code,{children:"indexToCompare"}),". If it is, we need to swap!"]}),"\n",(0,o.jsx)(t.p,{children:"We need to store one of the two values before swapping \u2014 otherwise, it will get lost. We store the higher value \u2014 though it could just as easily be the other way around. Then we swap the values."}),"\n",(0,o.jsx)(t.p,{children:"Once we've completely iterated through both loops, we're done and the array will be fully sorted."}),"\n",(0,o.jsx)(t.p,{children:"So what's the Big O of this algorithm? It should be obvious..."}),"\n",(0,o.jsxs)(t.p,{children:["If you guess O(n",(0,o.jsx)(t.sup,{children:"2"}),"), you're right. While the inner array does get smaller and smaller over time, that's still a lot of iteration, especially for large unsorted arrays. On the other hand, we don't have to worry about memory constraints \u2014 no temporary arrays are created and values are swapped in-place. It's also a simple algorithm to implement. That being said, if you were asked to implement an efficient sorting algorithm in either a technical interview or in an application, this one would not be the way to go."]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var r=n(96540);const o={},a=r.createContext(o);function i(e){const t=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);