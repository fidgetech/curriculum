"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[92852],{16780:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"react/functional-programming-with-javascript/3-1-1-9-building-a-functional-application-part-1","title":"\ud83d\udcd3 3.1.1.9 Building a Functional Application (Part 1)","description":"Let\'s use all the concepts we\'ve learned so far to build a simple application. In this application, a user is growing a plant. The plant needs water, soil, and sunshine. The user may increment a plant\'s values through the functions hydrate(), feed(), and giveLight().","source":"@site/versioned_docs/version-WIP/3_react/1_functional-programming-with-javascript/3-1-1-09-building-a-functional-application-part-1.md","sourceDirName":"3_react/1_functional-programming-with-javascript","slug":"/react/functional-programming-with-javascript/3-1-1-9-building-a-functional-application-part-1","permalink":"/WIP/react/functional-programming-with-javascript/3-1-1-9-building-a-functional-application-part-1","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 3.1.1.9 Building a Functional Application (Part 1)","day":"monday","id":"3-1-1-9-building-a-functional-application-part-1","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 3.1.1.8 Storing State in Closures","permalink":"/WIP/react/functional-programming-with-javascript/3-1-1-8-storing-state-in-closures"},"next":{"title":"\ud83d\udcd3 3.1.1.10 Building a Functional Application (Part 2)","permalink":"/WIP/react/functional-programming-with-javascript/3-1-1-10-building-a-functional-application-part-2"}}');var i=t(74848),o=t(28453);const r={title:"\ud83d\udcd3 3.1.1.9 Building a Functional Application (Part 1)",day:"monday",id:"3-1-1-9-building-a-functional-application-part-1",hide_table_of_contents:!0},s=void 0,l={},c=[{value:"An Object-Oriented Approach",id:"an-object-oriented-approach",level:2},{value:"Problems With Our Object-Oriented Approach",id:"problems-with-our-object-oriented-approach",level:3},{value:"A Functional Approach",id:"a-functional-approach",level:2},{value:"Abstracting Our Methods Into a Single Function",id:"abstracting-our-methods-into-a-single-function",level:3}];function h(e){const n={code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Let's use all the concepts we've learned so far to build a simple application. In this application, a user is growing a plant. The plant needs water, soil, and sunshine. The user may increment a plant's values through the functions ",(0,i.jsx)(n.code,{children:"hydrate()"}),", ",(0,i.jsx)(n.code,{children:"feed()"}),", and ",(0,i.jsx)(n.code,{children:"giveLight()"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"an-object-oriented-approach",children:"An Object-Oriented Approach"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"Before we take a functional approach, let's take a quick look at how we might implement this small program from an object-oriented perspective:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"class Plant {\n  constructor() {\n    this.water = 0;\n    this.soil = 0;\n    this.light = 0;\n  }\n\n  hydrate() {\n    this.water ++\n  }\n\n  feed() {\n    this.soil ++\n  }\n\n  giveLight() {\n    this.light ++\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"To create and hydrate a plant, we'd do the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"> let plant = new Plant();\n> plant.hydrate()\n> plant\nPlant {water: 1, soil: 0, light: 0}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The program above is simple and easy to read. However, from a functional perspective, there are several problems with this approach. Let's discuss these issues. As we do, keep in mind that both functional programming and object-oriented programming have many advantages. We are not advocating for one approach over the other \u2014 the most important thing is to use the right tool for the job. Many developers incorporate aspects of both object-oriented and functional programming."}),"\n",(0,i.jsx)(n.h3,{id:"problems-with-our-object-oriented-approach",children:"Problems With Our Object-Oriented Approach"}),"\n",(0,i.jsx)(n.p,{children:"From a functional perspective, though, this application is not very flexible and may be prone to bugs. Let's look at why:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["All methods must be called on instances of the ",(0,i.jsx)(n.code,{children:"Plant"})," class."]})," While these methods are nicely encapsulated, they aren't very reusable. If we wanted instances of other classes to have the same functionality, we'd need to use inheritance \u2014 or have repeated code elsewhere."]}),"\n",(0,i.jsx)(n.p,{children:"From a functional approach, we'll want to use composition instead. That means we won't use a class. It also means that our methods will be more modular and reusable."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Our methods have side effects."})," Remember that pure functions can't have side effects. Our methods definitely have side effects \u2014 they are altering the state of a plant object!"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Our methods mutate state."})," Not only do our methods have side effects \u2014 they are directly mutating state. While this is common in object-oriented programming, it's a no-no in functional programming."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Our functions don't return anything."})," Pure functions also need to return something. However, none of our methods return anything."]}),"\n",(0,i.jsx)(n.p,{children:"So how should we refactor our application to have a more functional approach?"}),"\n",(0,i.jsx)(n.h2,{id:"a-functional-approach",children:"A Functional Approach"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["Let's start by creating a reusable function that we can use to ",(0,i.jsx)(n.code,{children:"hydrate()"}),", ",(0,i.jsx)(n.code,{children:"feed()"})," and ",(0,i.jsx)(n.code,{children:"giveLight()"})," to a plant. Specifically, we will create a pure function that isn't in a class. This will solve the problems with the methods above all at once. Because it will be pure, it will have:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No side effects;"}),"\n",(0,i.jsx)(n.li,{children:"No state mutation;"}),"\n",(0,i.jsx)(n.li,{children:"A return value."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Let's do that now."}),"\n",(0,i.jsx)(n.h3,{id:"abstracting-our-methods-into-a-single-function",children:"Abstracting Our Methods Into a Single Function"}),"\n",(0,i.jsxs)(n.p,{children:["Let's start by rewriting our ",(0,i.jsx)(n.code,{children:"hydrate()"})," method."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const hydrate = (plant) => {\n  return {\n    ...plant,\n    water: (plant.water || 0) + 1\n  }\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the example above, we create a function literal. The function takes a ",(0,i.jsx)(n.code,{children:"plant"})," as an argument. It will not mutate state. Instead, it will return a new object that represents the plant's new state. We will use the spread operator to return the new state of the plant. The value of ",(0,i.jsx)(n.code,{children:"plant.water"})," will be set to ",(0,i.jsx)(n.code,{children:"(plant.water || 0) + 1"}),". Note that we use the ",(0,i.jsx)(n.code,{children:"||"})," operator here \u2014 if an object doesn't contain a ",(0,i.jsx)(n.code,{children:"water"})," property, then ",(0,i.jsx)(n.code,{children:"plant.water"})," will equal ",(0,i.jsx)(n.code,{children:"NaN"}),". This way, the value default to ",(0,i.jsx)(n.code,{children:"0"})," if there is no ",(0,i.jsx)(n.code,{children:"water"})," property."]}),"\n",(0,i.jsx)(n.p,{children:"In theory, the function isn't mutating state because we are returning a new object. (Unfortunately, in reality, JavaScript is still referencing \u2014 and mutating \u2014 the original object because it creates a shallow clone, not a deep clone. But we'd need to use a special library to ensure we have a deep clone, so we won't worry about that right now!)"}),"\n",(0,i.jsxs)(n.p,{children:["Just like that, we've addressed the primary issues with our ",(0,i.jsx)(n.code,{children:"hydrate()"})," function!"]}),"\n",(0,i.jsxs)(n.p,{children:["We could then do the same thing for our other two functions. For instance, here's a new ",(0,i.jsx)(n.code,{children:"feed()"})," function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const feed = (plant) => {\n  return {\n    ...plant,\n    soil: (plant.soil || 0) + 1\n  }\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This function pretty much looks the same as the previous one. Also, it doesn't seem very reusable. It can only take an object that has a ",(0,i.jsx)(n.code,{children:"soil"})," property and then increment that ",(0,i.jsx)(n.code,{children:"soil"})," property by 1. Because the methods look so similar, we clearly have a chance to refactor here."]}),"\n",(0,i.jsx)(n.p,{children:"Remember that functional programming is an attempt to make our code more abstract and reusable. This is in contrast to object-oriented programming, which is often about making our code more concrete and encapsulated."}),"\n",(0,i.jsxs)(n.p,{children:["So how can we refactor this method to take in and alter ",(0,i.jsx)(n.code,{children:"soil"}),", ",(0,i.jsx)(n.code,{children:"water"}),", or ",(0,i.jsx)(n.code,{children:"light"}),"? We could do the following:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const changePlantState = (plant, property) => {\n  return {\n    ...plant,\n    [property]: (plant[property] || 0) + 1\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now we are passing in both a ",(0,i.jsx)(n.code,{children:"plant"})," and the specific ",(0,i.jsx)(n.code,{children:"property"})," that we want to change. Note that we can use square brackets to pass the value of a variable into an object key or property. This is a piece of functionality from ES6."]}),"\n",(0,i.jsx)(n.p,{children:"Now we can call this function like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'> let plant = { soil: 0, light: 0, water: 0 }\n> changePlantState(plant, "soil")\n{soil: 1, light: 0, water: 0}\n'})}),"\n",(0,i.jsx)(n.p,{children:"And just like that, we've reduced three functions into one."}),"\n",(0,i.jsx)(n.p,{children:"While this is a good first step in terms of refactoring, we can do more to make this function reusable and flexible. Here's how our function is still limited:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"It's still specific to plants when we could technically use it to increment any property of any object by 1. We can rename the variables to be more abstract."}),"\n",(0,i.jsx)(n.li,{children:"Why should we limit ourselves to just incrementing a plant property by 1? If we were going to turn this into a game, we'd probably want ways to increment (or decrement) different properties in different ways. Our function would be much more flexible if it could do this."}),"\n",(0,i.jsx)(n.li,{children:"Finally, this function takes multiple arguments, so it might be nice to turn this into an unary function with just one argument. (Hint: we will need to curry our function to do this.)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Let's handle this one step at a time."}),"\n",(0,i.jsx)(n.p,{children:"First, we'll make our variables more abstract:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const changeState = (state, prop) => {\n  return {\n    ...state,\n    [prop]: (state[prop] || 0) + 1\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now our function is no longer limited to just working with plants. It could increment any property of state by 1. Note that we call the property passed in ",(0,i.jsx)(n.code,{children:"prop"}),". ",(0,i.jsx)(n.code,{children:"prop"})," or ",(0,i.jsx)(n.code,{children:"props"})," is a common name for this variable and you'll see it frequently in React."]}),"\n",(0,i.jsxs)(n.p,{children:["Our function is gradually improving but it could still be a lot better. Why would we want to limit ourselves to just incrementing a property by 1? Let's refactor our function again. Now it will also accept a ",(0,i.jsx)(n.code,{children:"value"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const changeState = (state, prop, value) => ({\n  ...state,\n  [prop] : (state[prop] || 0) + value\n})\n"})}),"\n",(0,i.jsx)(n.p,{children:"This is a very small change but it makes our function even more flexible. In the process, though, we've created another problem. We went from having an unary function with just one argument to a function with three arguments."}),"\n",(0,i.jsx)(n.p,{children:"How can we solve this problem, too? It's time to curry this function! Our outer function will take just one argument. This outer function will return a second function which takes another argument. Finally, this inner function will return yet another inner function that will take the final argument. Here's how our curried function looks:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const changeState = (prop) => {\n  return (value) => {\n    return (state) => ({\n      ...state,\n      [prop] : (state[prop] || 0) + value\n    })\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"You may be wondering if there's any value in currying this function. Don't we still have to pass in three arguments? Well, there is a method to our madness \u2014 or rather, a function to our funny business. Now we can create some function factories!"}),"\n",(0,i.jsxs)(n.p,{children:["Note that ",(0,i.jsx)(n.code,{children:"prop"})," is passed into the outer function, then ",(0,i.jsx)(n.code,{children:"value"})," is passed to the inner function, and finally, ",(0,i.jsx)(n.code,{children:"state"})," is passed to the innermost function. We could pass in those arguments in any order we like. However, our current setup isn't accidental. We can now use this function to make some smaller, more specific functions. Here are some examples:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const feed = changeState("soil");\nconst hydrate = changeState("water");\nconst giveLight = changeState("light");\n'})}),"\n",(0,i.jsx)(n.p,{children:"We just used our function to easily create more specific functions for each kind of property. We could add 5 to the soil of a plant by doing the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"feed(5)(plant)\n"})}),"\n",(0,i.jsx)(n.p,{children:"We could theoretically drill down and get even more specific:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const blueFood = changeState("soil")(5)\nconst greenFood = changeState("soil")(10)\nconst yuckyFood = changeState("soil")(-5)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Now we can do the following with a plant:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"blueFood(plant)\n"})}),"\n",(0,i.jsx)(n.p,{children:"This will increase a plant's food level by 5."}),"\n",(0,i.jsx)(n.p,{children:"None of this flexibility would've been possible without currying!"}),"\n",(0,i.jsx)(n.p,{children:"We've now incorporated the following:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Our function is pure, does not mutate state, and has no side effects;"}),"\n",(0,i.jsx)(n.li,{children:"Our function is unary and takes only one argument;"}),"\n",(0,i.jsx)(n.li,{children:"Our function uses currying, which allows us to reuse it as a function factory;"}),"\n",(0,i.jsx)(n.li,{children:"Our function takes advantage of closures (because we wouldn't be able to curry without it);"}),"\n",(0,i.jsx)(n.li,{children:"Our function is sufficiently abstracted that it could be used with other types of objects that could be incremented or decremented as well."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"That's a lot of extra power that we didn't have with our object-oriented methods!"}),"\n",(0,i.jsx)(n.p,{children:"At this point, we have a solid start on our first functional application. However, we still don't have any way to store state. In the next lesson, we'll use closures to store state in our application."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var a=t(96540);const i={},o=a.createContext(i);function r(e){const n=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);