"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[9806],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var o=n(96540);const r={},s=o.createContext(r);function i(e){const t=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:t},e.children)}},48751:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"introduction-to-programming/arrays-looping/1-3-2-3-text-analyzer-with-tdd-wordcounter","title":"\ud83d\udcd3 1.3.2.3 Text Analyzer with TDD: wordCounter()","description":"In the last lesson, we wrote a very basic function for counting words in a paragraph. It doesn\'t work very well. It doesn\'t care about the difference between numbers and words in a string. It returns 1 even when we pass in an empty string. So let\'s keep working on this function and make it better. We\'re ready to actually start building our application.","source":"@site/versioned_docs/version-WIP/1_introduction-to-programming/3_arrays-looping/1-3-2-03-text-analyzer-with-tdd-wordcounter.md","sourceDirName":"1_introduction-to-programming/3_arrays-looping","slug":"/introduction-to-programming/arrays-looping/1-3-2-3-text-analyzer-with-tdd-wordcounter","permalink":"/WIP/introduction-to-programming/arrays-looping/1-3-2-3-text-analyzer-with-tdd-wordcounter","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 1.3.2.3 Text Analyzer with TDD: wordCounter()","day":"tuesday","id":"1-3-2-3-text-analyzer-with-tdd-wordcounter","hide_table_of_contents":true},"sidebar":"introduction-to-programming","previous":{"title":"\ud83d\udcd3 1.3.2.2 Overview of Test-Driven Development (TDD) with Text Analyzer","permalink":"/WIP/introduction-to-programming/arrays-looping/1-3-2-2-overview-of-test-driven-development-tdd-with-text-analyzer"},"next":{"title":"\ud83d\udcd3 1.3.2.4 Text Analyzer with TDD: numberOfOccurrencesInText()","permalink":"/WIP/introduction-to-programming/arrays-looping/1-3-2-4-text-analyzer-with-tdd-numberofoccurrencesintext"}}');var r=n(74848),s=n(28453);const i={title:"\ud83d\udcd3 1.3.2.3 Text Analyzer with TDD: wordCounter()",day:"tuesday",id:"1-3-2-3-text-analyzer-with-tdd-wordcounter",hide_table_of_contents:!0},a=void 0,d={},l=[{value:"Setting Up the &quot;Text Analyzer&quot; Example Project",id:"setting-up-the-text-analyzer-example-project",level:2},{value:"Our Third <code>wordCounter()</code> Test",id:"our-third-wordcounter-test",level:3},{value:"Our Fourth <code>wordCounter()</code> Test",id:"our-fourth-wordcounter-test",level:3},{value:"Our Fifth <code>wordCounter()</code> Test",id:"our-fifth-wordcounter-test",level:3}];function c(e){const t={a:"a",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["In the last lesson, we wrote a very basic function for counting words in a paragraph. It doesn't work very well. It doesn't care about the difference between numbers and words in a string. It returns ",(0,r.jsx)(t.code,{children:"1"})," even when we pass in an empty string. So let's keep working on this function and make it better. We're ready to actually start building our application."]}),"\n",(0,r.jsxs)(t.p,{children:["In this lesson, we'll complete the tests and functionality for the Text Analyzer's ",(0,r.jsx)(t.code,{children:"wordCounter()"})," function. Then, in the next lesson, we'll create a new function for our Text Analyzer project using TDD. The goal of these lessons is to demonstrate the TDD process, including all of the decisions we need to make along the way."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"You should code along with this and the following lessons that build out the Text Analyzer project. In the upcoming practice lesson, you'll be tasked with adding more functionality to this project."})}),"\n",(0,r.jsx)(t.h2,{id:"setting-up-the-text-analyzer-example-project",children:'Setting Up the "Text Analyzer" Example Project'}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsxs)(t.p,{children:["Create a directory called ",(0,r.jsx)(t.code,{children:"text-analyzer"})," with two files: a ",(0,r.jsx)(t.code,{children:"README.md"})," and a directory called ",(0,r.jsx)(t.code,{children:"js"})," that includes a ",(0,r.jsx)(t.code,{children:"scripts.js"})," file. Over the next several lessons, you'll follow along with building the ",(0,r.jsx)(t.code,{children:"text-analyzer"})," application."]}),"\n",(0,r.jsxs)(t.p,{children:["If you're wondering why there is no ",(0,r.jsx)(t.code,{children:"index.html"})," file or ",(0,r.jsx)(t.code,{children:"css"})," directory, it's because we aren't ready for them yet. ",(0,r.jsx)(t.strong,{children:"Test-driven development is all about building your business logic first."})," It doesn't necessarily mean that ",(0,r.jsx)(t.em,{children:"all"})," business logic has to be created before a user interface. However, if we start mingling business logic and user interface right now, we'll probably run into problems. We'll likely have issues with separation of logic. We might also end up with bugs in our code that are hard to track. For instance, if something isn't working, we might not be able to tell whether the error is in our business logic or user interface logic because everything is mixed up and we haven't tested it."]}),"\n",(0,r.jsxs)(t.p,{children:["Here's our ",(0,r.jsx)(t.code,{children:"scripts.js"})," file so far based on the code we covered in the last lesson:"]}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"js/scripts.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'// Business Logic\n\nfunction wordCounter(text) {\n  let wordCount = 0;\n  const textArray = text.split(" ");\n  textArray.forEach(function(word) {\n    wordCount++;\n  });\n  return wordCount;\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["A quick reminder: as we stated in the last lesson, we are going back to using a loop because we need the practice. We've also added the comment ",(0,r.jsx)(t.code,{children:"// Business Logic"})," to make it easier to see how our business and UI logic are separated because they are in the same file. We're just using this comment for clarity and organization \u2014 it's not something you'll see in real-world code bases. In Intermediate JavaScript, we'll learn to separate our code into different files and we won't need these comments anymore."]}),"\n",(0,r.jsxs)(t.p,{children:["We mentioned this in the last lesson, but you may have missed it: all of our pseudocode tests should go in our README. Here's what the tests in our ",(0,r.jsx)(t.code,{children:"README.md"})," should look like so far:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'Describe: wordCounter()\n\nTest: "It should return 1 if a passage has just one word."\nCode:\nconst text = "hello";\nwordCounter(text);\nExpected Output: 1\n\nTest: "It should return 2 if a passage has two words."\nCode:\nconst text = "hello there";\nwordCounter(text);\nExpected Output: 2\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Note that this ",(0,r.jsx)(t.em,{children:"isn't"})," a complete README. It's just the two pseudocode tests we have created so far for the ",(0,r.jsx)(t.code,{children:"wordCounter()"})," function. You are still responsible for adding any other README information for your projects."]}),"\n",(0,r.jsxs)(t.h3,{id:"our-third-wordcounter-test",children:["Our Third ",(0,r.jsx)(t.code,{children:"wordCounter()"})," Test"]}),"\n",(0,r.jsx)(t.p,{children:"Let's deal with the next simplest behavior. There are actually several different behaviors we could tackle next, so don't get too caught up on whether one behavior is simpler to implement than another if the distinction is not obvious. There is no preset route to building an application with TDD. Just do your best to implement one small behavior at a time."}),"\n",(0,r.jsxs)(t.p,{children:["We'll start by dealing with the fact our function will return ",(0,r.jsx)(t.code,{children:"1"})," for an empty string. Here's the pseudocode test:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'Test: "It should return 0 for an empty string."\nCode: wordCounter("");\nExpected Output: 0\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Note that this test still belongs to the group of tests we've written so far, which means it doesn't have a separate line for ",(0,r.jsx)(t.strong,{children:"Describe"}),". Also, we've put the code inline because there's just one line of code. How you format your own pseudocode tests is up to you. Just make sure they are easy to read."]}),"\n",(0,r.jsx)(t.p,{children:"Now let's update the code. We encourage you to write the solution yourself."}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"js/scripts.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'// Business Logic\n\nfunction wordCounter(text) {\n  if (text.length === 0) {\n    return 0;\n  }\n  let wordCount = 0;\n  const textArray = text.split(" ");\n  textArray.forEach(function(word) {\n    wordCount++;\n  });\n  return wordCount;\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["All we need to do is write a conditional that checks if the length of ",(0,r.jsx)(t.code,{children:"text"})," is equal to ",(0,r.jsx)(t.code,{children:"0"}),". If it is, the function will return ",(0,r.jsx)(t.code,{children:"0"}),". If we try ",(0,r.jsx)(t.code,{children:'wordCounter("");'})," in the console, it will return ",(0,r.jsx)(t.code,{children:"0"})," as expected."]}),"\n",(0,r.jsxs)(t.h3,{id:"our-fourth-wordcounter-test",children:["Our Fourth ",(0,r.jsx)(t.code,{children:"wordCounter()"})," Test"]}),"\n",(0,r.jsx)(t.p,{children:"So now we're ready to move on. Or are we? Think carefully. Have we solved the empty string problem fully yet?"}),"\n",(0,r.jsx)(t.p,{children:"Try this:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'> wordCounter("            ");\n'})}),"\n",(0,r.jsx)(t.p,{children:"According to our function, that's 13 words. Not good. We could update our empty string test or write a new one. To be thorough and practice, we'll write a new test. Again, we are taking baby steps here."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'Test: "It should return 0 for a string that is only spaces."\nCode: wordCounter("            ");\nExpected Output: 0\n'})}),"\n",(0,r.jsx)(t.p,{children:"It's a quick fix:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"js/scripts.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'// Business Logic\n\nfunction wordCounter(text) {\n  if (text.trim().length === 0) {\n    return 0;\n  }\n  let wordCount = 0;\n  const textArray = text.split(" ");\n  textArray.forEach(function(word) {\n    wordCount++;\n  });\n  return wordCount;\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["We can use ",(0,r.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim",children:(0,r.jsx)(t.code,{children:"String.prototype.trim()"})})," to trim all whitespace from both ends of a string. Since the string is all whitespace, that will reduce it to ",(0,r.jsx)(t.code,{children:'""'}),", which has a length of ",(0,r.jsx)(t.code,{children:"0"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"Another test passing! These little details can lead to big bugs down the road if we don't think about them early on."}),"\n",(0,r.jsxs)(t.h3,{id:"our-fifth-wordcounter-test",children:["Our Fifth ",(0,r.jsx)(t.code,{children:"wordCounter()"})," Test"]}),"\n",(0,r.jsxs)(t.p,{children:["Next, let's think about words. What is a word exactly? We aren't going to enforce whether something is legally a word or not. And nor would Google Docs. If we were to write a fantasy novel with Xoeo and Myxtmidia as the main characters, Google Docs is more than happy to call those words. Google Docs also counts numbers as words but we are going to be more precise than that. A spelled number (",(0,r.jsx)(t.code,{children:'"seven"'}),") is a word but the number ",(0,r.jsx)(t.code,{children:"7"})," is a number so we won't add it in the word count. So let's get started with a test."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'Test: "It should not count numbers as words."\nCode: wordCounter("hi there 77 19");\nExpected Output: 2\n'})}),"\n",(0,r.jsxs)(t.p,{children:["In our test, we mix together words and numbers. Our function should properly count the words but ignore the numbers in the count. If we actually test ",(0,r.jsx)(t.code,{children:'wordCounter("hi there 77 19");'})," in the console right now, it will return 4. That's not what we want. However, we will acknowledge that we could have characters named Epsilon72 and Eri9er in our upcoming science fiction novel. (We don't know how to pronounce Eri9er, but it's the future and they've figured that kind of thing out.)"]}),"\n",(0,r.jsx)(t.p,{children:"So let's update the function to get this test passing."}),"\n",(0,r.jsx)(t.p,{children:"Once again, see if you can do this on your own."}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"js/scripts.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'// Business Logic\n\nfunction wordCounter(text) {\n  if (text.trim().length === 0) {\n    return 0;\n  }\n  let wordCount = 0;\n  const textArray = text.split(" ");\n  textArray.forEach(function(element) {\n    if (!Number(element)) {\n      wordCount++;\n    }\n  });\n  return wordCount;\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["The change above will get the result we want. All we have to do is add a conditional. The ",(0,r.jsxs)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number#description",children:["built-in JavaScript ",(0,r.jsx)(t.code,{children:"Number()"})," function"]})," either returns a number or ",(0,r.jsx)(t.code,{children:"NaN"}),". ",(0,r.jsx)(t.code,{children:'Number("16")'})," will return 16 while ",(0,r.jsx)(t.code,{children:'Number("hi")'})," returns ",(0,r.jsx)(t.code,{children:"NaN"}),". So if something's not a number (",(0,r.jsx)(t.code,{children:"NaN"}),"), we will increment our ",(0,r.jsx)(t.code,{children:"wordCount"}),". If it is a number, we won't increment it."]}),"\n",(0,r.jsxs)(t.p,{children:["Note also that we changed the callback function's parameter to ",(0,r.jsx)(t.code,{children:"element"})," because it might not always be a word. It's a good practice to rename variable names if you realize they more accurately communicate your code."]}),"\n",(0,r.jsx)(t.p,{children:"Once again, this was a pretty small change. It's much easier to do this incrementally."}),"\n",(0,r.jsx)(t.p,{children:"There's another thing we haven't thought about: punctuation. Dealing with punctuation is easier to handle with a regular expression. However, we haven't learned about regular expressions yet and they are a further exploration topic, so won't worry about them right now. Even though we could do more to make this function robust, for the purposes of demonstrating how to use TDD practices, this is robust enough. Let's move on to the next function!"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsxs)(t.strong,{children:["To view all of the tests we wrote for the ",(0,r.jsx)(t.code,{children:"wordCounter()"})," function, view the cheat sheet."]})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);