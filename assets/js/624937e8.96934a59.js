"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[19435],{15672:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/binary_tree-7141fc9fcfe43f50b22d32efac20f7f7.png"},28453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>o});var n=a(96540);const r={},s=n.createContext(r);function i(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(s.Provider,{value:t},e.children)}},59689:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/left_and_right_child-5600982925ce9e1a2eb11ec173d0bf7c.png"},90014:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>h,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"capstone/capstone-week-1/binary-search-trees-introduction","title":"\ud83d\udcd3 Binary Search Trees Introduction","description":"In this lesson, we\'ll give an overview of two data structures: the binary tree and the binary search tree. They are quite similar \u2014 the main difference is that a binary search tree has additional restraints that make it better for searching.","source":"@site/versioned_docs/version-WIP/capstone/1_capstone-week-1/binary-search-trees-introduction.md","sourceDirName":"capstone/1_capstone-week-1","slug":"/capstone/capstone-week-1/binary-search-trees-introduction","permalink":"/WIP/capstone/capstone-week-1/binary-search-trees-introduction","draft":false,"unlisted":false,"tags":[],"version":"WIP","sidebarPosition":12,"frontMatter":{"title":"\ud83d\udcd3 Binary Search Trees Introduction","id":"binary-search-trees-introduction","slug":"binary-search-trees-introduction","hide_table_of_contents":true,"sidebar_position":12,"day":"monday","type":"lesson","url":"https://github.com/epicodus-curriculum/capstone/blob/main/2_binary_tree_data_structure.md"},"sidebar":"capstone","previous":{"title":"\ud83d\udcd3 Introduction to Trees","permalink":"/WIP/capstone/capstone-week-1/introduction-to-trees"},"next":{"title":"\ud83d\udcd3 Binary Search Trees Part 1","permalink":"/WIP/capstone/capstone-week-1/binary-search-trees-part-1"}}');var r=a(74848),s=a(28453);const i={title:"\ud83d\udcd3 Binary Search Trees Introduction",id:"binary-search-trees-introduction",slug:"binary-search-trees-introduction",hide_table_of_contents:!0,sidebar_position:12,day:"monday",type:"lesson",url:"https://github.com/epicodus-curriculum/capstone/blob/main/2_binary_tree_data_structure.md"},o=void 0,h={},c=[{value:"Binary Tree",id:"binary-tree",level:2},{value:"Binary Search Tree",id:"binary-search-tree",level:2}];function l(e){const t={em:"em",h2:"h2",img:"img",p:"p",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["In this lesson, we'll give an overview of two data structures: the ",(0,r.jsx)(t.strong,{children:"binary tree"})," and the ",(0,r.jsx)(t.strong,{children:"binary search tree"}),". They are quite similar \u2014 the main difference is that a binary search tree has additional restraints that make it better for searching."]}),"\n",(0,r.jsx)(t.h2,{id:"binary-tree",children:"Binary Tree"}),"\n",(0,r.jsx)(t.p,{children:"A binary tree is a type of general tree structure. As the name suggests, it's a structure where each node can have no more than two child nodes. (We can infer this from the name because binary can be defined as something that has two parts.)"}),"\n",(0,r.jsx)(t.p,{children:"Here's an example of a binary tree:"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"Image of a binary tree.",src:a(15672).A+"",width:"611",height:"441"})}),"\n",(0,r.jsx)(t.p,{children:"In the diagram above, each parent node has at most two child nodes. However, it's also fine if a parent has one or zero nodes. (In the latter case, it's technically not a parent.) By the way, don't worry about how the keys line up on the nodes. They do not need to be ordered in a specific fashion in a binary tree."}),"\n",(0,r.jsxs)(t.p,{children:["When a parent has two child nodes in a binary tree, the child nodes are referred to as the ",(0,r.jsx)(t.strong,{children:"left child"})," and the ",(0,r.jsx)(t.strong,{children:"right child"})," based on whether the node is on the left or right."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"When a parent has two nodes, the nodes are referred to as the left and right child.",src:a(59689).A+"",width:"271",height:"221"})}),"\n",(0,r.jsxs)(t.p,{children:["Binary trees have many uses. In fact, compilers often use them to build what is known as an ",(0,r.jsx)(t.strong,{children:"abstract syntax tree"})," (or AST) \u2014 an intermediate representation of the code that is not yet fully compiled. The JavaScript parser uses an AST as well, though it's a general tree, not a binary tree."]}),"\n",(0,r.jsx)(t.h2,{id:"binary-search-tree",children:"Binary Search Tree"}),"\n",(0,r.jsx)(t.p,{children:"A binary search tree is very similar to a binary tree but also has a few additional restrictions. Let's take a look at an example."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"An example of a binary search tree.",src:a(94733).A+"",width:"1244",height:"898"})}),"\n",(0,r.jsxs)(t.p,{children:["In the example above, you'll see that all child nodes ",(0,r.jsx)(t.em,{children:"to the left"})," of the root node have a value ",(0,r.jsx)(t.em,{children:"less than"})," the root node. Meanwhile, all child nodes ",(0,r.jsx)(t.em,{children:"to the right"})," of the root node have a value ",(0,r.jsx)(t.em,{children:"greater than"})," the root node. This pattern continues all the way down the tree. The left-hand child always has a value ",(0,r.jsx)(t.em,{children:"less than"})," its parent while the right-hand child always has a value ",(0,r.jsx)(t.em,{children:"greater than"})," its parent. Based on this pattern, we automatically know a few things about a few values in a binary search tree. The bottom left leaf node will be the lowest value in the tree while the bottom right leaf node will be the greatest value in the tree."]}),"\n",(0,r.jsxs)(t.p,{children:["Duplicate keys aren't allowed in a binary search tree. This should make intuitive sense \u2014 because each child node must be either ",(0,r.jsx)(t.em,{children:"less than"})," or ",(0,r.jsx)(t.em,{children:"greater than"})," its parent node's key, there is no possibility of repeat keys."]}),"\n",(0,r.jsx)(t.p,{children:"Over the next several lessons, we'll create a small application that makes a binary search tree from scratch. In the process, we'll also learn how to search a binary search tree."})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},94733:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/binary_search_tree-877c715fd7c3f29f912942d9ed8f4820.png"}}]);