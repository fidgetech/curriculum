"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[11321],{11210:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-5-git-best-practices-and-adding-a--gitignore-file","title":"\ud83d\udcd3 2.2.0.5 Git Best Practices and Adding a .gitignore File","description":"The very first step in creating any project that uses multiple JS dependencies that are managed by node package manager (npm) is to create a .gitignore file, and we\'ll do just that in this lesson. We\'ll also take the opportunity to review a few additional Git best practices. You are expected to incorporate all of these best practices into your projects for the remainder of the Intermediate JavaScript course.","source":"@site/versioned_docs/version-WIP/2_intermediate-javascript/2_test-driven-development-and-environments-with-javascript/2-2-0-05-git-best-practices-and-adding-a--gitignore-file.md","sourceDirName":"2_intermediate-javascript/2_test-driven-development-and-environments-with-javascript","slug":"/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-5-git-best-practices-and-adding-a--gitignore-file","permalink":"/WIP/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-5-git-best-practices-and-adding-a--gitignore-file","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 2.2.0.5 Git Best Practices and Adding a .gitignore File","day":"weekend","id":"2-2-0-5-git-best-practices-and-adding-a--gitignore-file","hide_table_of_contents":true},"sidebar":"intermediate-javascript","previous":{"title":"\ud83d\udcd3 2.2.0.4 Future Project Structure","permalink":"/WIP/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-4-future-project-structure"},"next":{"title":"\ud83d\udcd3 2.2.0.6 Creating a package.json with npm","permalink":"/WIP/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-6-creating-a-package-json-with-npm"}}');var o=i(74848),s=i(28453);const r={title:"\ud83d\udcd3 2.2.0.5 Git Best Practices and Adding a .gitignore File",day:"weekend",id:"2-2-0-5-git-best-practices-and-adding-a--gitignore-file",hide_table_of_contents:!0},d=void 0,a={},l=[{value:"Adding a <code>.gitignore</code> File",id:"adding-a-gitignore-file",level:2},{value:"Removing a Committed File that Should Be Ignored",id:"removing-a-committed-file-that-should-be-ignored",level:3},{value:"Git Best Practices",id:"git-best-practices",level:2},{value:"Checking Changes with <code>$ git diff</code>",id:"checking-changes-with--git-diff",level:3}];function c(e){const t={a:"a",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["The very first step in creating any project that uses multiple JS dependencies that are managed by node package manager (npm) is to create a ",(0,o.jsx)(t.code,{children:".gitignore"})," file, and we'll do just that in this lesson. We'll also take the opportunity to review a few additional Git best practices. You are expected to incorporate all of these best practices into your projects for the remainder of the Intermediate JavaScript course."]}),"\n",(0,o.jsxs)(t.h2,{id:"adding-a-gitignore-file",children:["Adding a ",(0,o.jsx)(t.code,{children:".gitignore"})," File"]}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsxs)(t.p,{children:["We briefly discussed ",(0,o.jsx)(t.code,{children:".gitignore"})," files in ",(0,o.jsx)(t.a,{href:"../../pre-work/getting-started-with-intro-to-programming/1-0-0-21-git-configurations",children:"Git Configurations"}),". That lesson discussed setting up a ",(0,o.jsx)(t.code,{children:".gitignore_global"})," file which we can use to ensure that git ignores files we don't want to commit to GitHub."]}),"\n",(0,o.jsxs)(t.p,{children:["Just like with ",(0,o.jsx)(t.code,{children:".gitignore_global"}),", ",(0,o.jsx)(t.code,{children:".gitignore"})," files aren't specific to project written in JavaScript. In general, they should be included in all projects being pushed to GitHub, and we'll continue to use ",(0,o.jsx)(t.code,{children:".gitignore"})," files for the remained of the program."]}),"\n",(0,o.jsxs)(t.p,{children:["A ",(0,o.jsx)(t.code,{children:".gitignore"})," file lists all of the files that are ",(0,o.jsx)(t.em,{children:"local"})," to a project that Git should not push to GitHub. A ",(0,o.jsx)(t.code,{children:".gitignore"})," always goes in the top level of the project directory, which is also called the project's 'root'. The ",(0,o.jsx)(t.strong,{children:"root"})," of a project is the folder that is the parent for all the project files and subfolders."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsxs)(t.strong,{children:["In order for a ",(0,o.jsx)(t.code,{children:".gitignore"})," file to work correctly, it ",(0,o.jsx)(t.em,{children:"must"})," be committed ",(0,o.jsx)(t.em,{children:"before"})," we commit (by accident) any code we don't want in our Git history."]})}),"\n",(0,o.jsxs)(t.p,{children:["Let's create a ",(0,o.jsx)(t.code,{children:".gitignore"})," file now and list a few files and folders in it. When file(s) or folder(s) are listed in the ",(0,o.jsx)(t.code,{children:".gitignore"}),", then that directs Git to ignore them when you make commits."]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:".gitignore"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"node_modules/\n.DS_Store // only include this if you are on a Mac\ndist/\n"})}),"\n",(0,o.jsxs)(t.p,{children:["We add the ",(0,o.jsx)(t.code,{children:"node_modules/"})," and ",(0,o.jsx)(t.code,{children:"dist/"})," folders to ",(0,o.jsx)(t.code,{children:".gitignore"})," because these are both automatically generated by npm and webpack, respectively. Since we've only just been introduced to these folders in the last lesson, we'll revisit why we add these folders to the ",(0,o.jsx)(t.code,{children:".gitignore"})," when we learn how they are generated."]}),"\n",(0,o.jsxs)(t.p,{children:["As previously mentioned, Git will only ignore the files and folders inside of the ",(0,o.jsx)(t.code,{children:".gitignore"})," if we commit ",(0,o.jsx)(t.code,{children:".gitignore"})," to our project's Git history ",(0,o.jsx)(t.strong,{children:(0,o.jsx)(t.em,{children:"before"})})," we add those folders/files inside of the ",(0,o.jsx)(t.code,{children:".gitignore"})," to our project."]}),"\n",(0,o.jsx)(t.p,{children:"Let's go ahead and make a commit. Set up the repository on your own if you haven't ready. Now we'll make our commit:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-shell",children:'$ git add .gitignore\n$ git commit -m "add .gitignore file to project"\n$ git push origin main\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Note that we didn't do ",(0,o.jsx)(t.code,{children:"$ git add ."}),". That's because our project directory has other files already. And if our project already had a ",(0,o.jsx)(t.code,{children:"node_modules"})," and ",(0,o.jsx)(t.code,{children:"dist"})," folder when we went to commit our ",(0,o.jsx)(t.code,{children:".gitignore"}),", then we'd be adding those files to GitHub along with our ",(0,o.jsx)(t.code,{children:".gitignore"})," file. This will cause Git to not be able to ignore those files."]}),"\n",(0,o.jsxs)(t.p,{children:['This is like putting up a sign that says "Wet Paint" on a bench ',(0,o.jsx)(t.em,{children:"after"})," someone has already sat on the bench by accident. Then we'd have a mess to clean up. GitHub absolutely needs to know what files should be ignored ",(0,o.jsx)(t.em,{children:"before"})," they (usually accidentally) get pushed."]}),"\n",(0,o.jsxs)(t.p,{children:["That's why we need to be diligent about setting up the ",(0,o.jsx)(t.code,{children:".gitignore"})," first thing, and also committing ",(0,o.jsx)(t.code,{children:".gitignore"})," without any other file with ",(0,o.jsx)(t.code,{children:"$ git add .gitignore"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Once our ",(0,o.jsx)(t.code,{children:".gitignore"})," file has been pushed to GitHub, we can make further commits without worrying about accidentally pushing files that are listed in our ",(0,o.jsx)(t.code,{children:".gitignore"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsxs)(t.strong,{children:["From now on, you should always include a ",(0,o.jsx)(t.code,{children:".gitignore"})," file in the top level directory of your projects, not just in this JavaScript course but in future courses as well."]})," This goes for C#, Ruby, and React projects, too. Your first commit should generally include your ",(0,o.jsx)(t.code,{children:".gitignore"})," file. Once again, make sure to avoid pushing any files that you want to ignore when you make that first commit \u2014 because GitHub won't know they should be ignored yet."]}),"\n",(0,o.jsx)(t.h3,{id:"removing-a-committed-file-that-should-be-ignored",children:"Removing a Committed File that Should Be Ignored"}),"\n",(0,o.jsxs)(t.p,{children:["If you do accidentally add a file that should be ignored to your repository, you'll need to remove it. You can do so by running ",(0,o.jsx)(t.code,{children:"$ git rm -r --cached [FILE-NAME]"}),", where ",(0,o.jsx)(t.code,{children:"[FILE-NAME]"})," is the name of the file that shouldn't be tracked. Git will no longer track the file."]}),"\n",(0,o.jsxs)(t.p,{children:["However, this won't entirely fix the problem if you are working with sensitive data. We won't be working with that kind of data in this section, but we will do so once we start working with APIs in the next section. Sensitive data often includes a private key that should never be shared with others. (It's similar to a password.) Just running ",(0,o.jsx)(t.code,{children:"$ git rm -r --cached [FILE-NAME]"})," won't fix the issue. While GitHub will stop tracking the file, it won't remove the file from your Git history. That's a big problem \u2014 a hacker could still get that information."]}),"\n",(0,o.jsxs)(t.p,{children:["If you find yourself needing to remove a file from a repository's history, see ",(0,o.jsx)(t.a,{href:"https://help.github.com/en/github/managing-large-files/removing-files-from-a-repositorys-history",children:"Removing Files from a Repository's History"})," on GitHub's documentation."]}),"\n",(0,o.jsxs)(t.p,{children:["In future lessons, we will specify which files and directories shouldn't be tracked. These files should be added to the local ",(0,o.jsx)(t.code,{children:".gitignore"})," file for all future projects."]}),"\n",(0,o.jsxs)(t.p,{children:["While you could add these files to your ",(0,o.jsx)(t.code,{children:".gitignore_global"})," file, it's still important to have the local ",(0,o.jsx)(t.code,{children:".gitignore"})," file. If other developers push to the project later, or if you push to it from a different machine, you'll automatically use the local ",(0,o.jsx)(t.code,{children:".gitignore"})," file."]}),"\n",(0,o.jsx)(t.h2,{id:"git-best-practices",children:"Git Best Practices"}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsxs)(t.p,{children:["Let's take another look at our commit above. Instead of using ",(0,o.jsx)(t.code,{children:"$ git add ."}),", we specified the name of the file we wanted to commit. In the real world, using ",(0,o.jsx)(t.code,{children:"$ git add ."})," is often a bad idea. It's generally better to add files one at a time and push code that's both ready to be committed (in other words, working, not broken code) that's relevant to the commit you're working on."]}),"\n",(0,o.jsxs)(t.p,{children:["Let's demonstrate why with an example. In the snippet below, we run ",(0,o.jsx)(t.code,{children:"$ git status"})," to look at an imaginary file."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-shell",children:'$ git status\nOn branch main\nChanges not staged for commit:\n  (use "git add <file>..." to update what will be committed)\n  (use "git checkout -- <file>..." to discard changes in working directory)\n\n\tmodified:   ready-to-commit.js\n  modified:   really-yucky-code.js\n  modified:   most-embarrassing-elementary-school-secrets.md\n\nno changes added to commit (use "git add" and/or "git commit -a")\n'})}),"\n",(0,o.jsx)(t.p,{children:"Here we have three files:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["The first, ",(0,o.jsx)(t.code,{children:"ready-to-commit.js"}),", is ready to be committed and pushed."]}),"\n",(0,o.jsxs)(t.li,{children:["The second, ",(0,o.jsx)(t.code,{children:"really-yucky-code.js"}),", isn't ready yet and shouldn't be committed."]}),"\n",(0,o.jsxs)(t.li,{children:["The third should ",(0,o.jsx)(t.em,{children:"never"})," be pushed to GitHub. You'd never live it down!"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Obviously, ",(0,o.jsx)(t.code,{children:"$ git add ."})," isn't the answer here. Instead, we should just run ",(0,o.jsx)(t.code,{children:"$ git add ready-to-commit.js"}),". And if we want to commit multiple files, we could do so by passing in multiple file names like this: ",(0,o.jsx)(t.code,{children:"$ git add file1 file2 file3"}),"."]}),"\n",(0,o.jsxs)(t.h3,{id:"checking-changes-with--git-diff",children:["Checking Changes with ",(0,o.jsx)(t.code,{children:"$ git diff"})]}),"\n",(0,o.jsxs)(t.p,{children:["We could also verify all the changes we've made in ",(0,o.jsx)(t.code,{children:"ready-to-commit.js"})," since our last commit by using the ",(0,o.jsx)(t.code,{children:"$ git diff"})," command. If we run ",(0,o.jsx)(t.code,{children:"$ git diff ready-to-commit.js"}),", we'll see a list of these changes. It's generally a good idea to do a quick ",(0,o.jsx)(t.code,{children:"git diff"})," before committing files. That way, we can verify we're committing the right code."]}),"\n",(0,o.jsxs)(t.p,{children:["If we want to be thorough and follow best practices, we should do the following when we commit ",(0,o.jsx)(t.em,{children:"instead"})," of using ",(0,o.jsx)(t.code,{children:"$ git add ."}),":"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["First, get the ",(0,o.jsx)(t.code,{children:"$ git status"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["Use ",(0,o.jsx)(t.code,{children:"$ git diff [FILE-NAME]"})," to verify that the changes look correct."]}),"\n",(0,o.jsxs)(t.li,{children:["Use ",(0,o.jsx)(t.code,{children:"$ git add [FILE-NAME]"})," to select a file to commit. Multiple files can be committed at once ",(0,o.jsx)(t.em,{children:"if"})," they are related to the same feature \u2014 but should be added one by one by doing ",(0,o.jsx)(t.code,{children:"$ git add file1 file2 etc"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["Run ",(0,o.jsx)(t.code,{children:"$ git commit"})," and add a great commit message."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["While it's often convenient to run ",(0,o.jsx)(t.code,{children:"$ git add ."}),", especially for learning projects, we recommend practicing good habits with your git workflow now."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>d});var n=i(96540);const o={},s=n.createContext(o);function r(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);