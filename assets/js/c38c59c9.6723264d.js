"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[75344],{28453:(e,s,n)=>{n.d(s,{R:()=>c,x:()=>i});var a=n(96540);const o={},r=a.createContext(o);function c(e){const s=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),a.createElement(r.Provider,{value:s},e.children)}},54341:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>t,contentTitle:()=>i,default:()=>h,frontMatter:()=>c,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"c-and-net/lessons-19-31-basic-console-apps/3-0-0-30-console-app-project-structure-how-to-add-more-code-files","title":"\ud83d\udcd3 3.0.0.30 Console App Project Structure: How to Add More Code Files","description":"In this lesson, we\'ll go over how to add more code files to our Shape Tracker project, and what namespaces we might add them to. We\'ll also learn that classes in the same namespace are in the same scope and therefore have access to each other without the need of a using directive.","source":"@site/versioned_docs/version-v1_3/3_c-and-net/0_lessons-19-31-basic-console-apps/3-0-0-30-console-app-project-structure-how-to-add-more-code-files.md","sourceDirName":"3_c-and-net/0_lessons-19-31-basic-console-apps","slug":"/c-and-net/lessons-19-31-basic-console-apps/3-0-0-30-console-app-project-structure-how-to-add-more-code-files","permalink":"/v1.3/c-and-net/lessons-19-31-basic-console-apps/3-0-0-30-console-app-project-structure-how-to-add-more-code-files","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 3.0.0.30 Console App Project Structure: How to Add More Code Files","day":"weekend","id":"3-0-0-30-console-app-project-structure-how-to-add-more-code-files","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.0.0.29 Simplifying Business Logic with Properties","permalink":"/v1.3/c-and-net/lessons-19-31-basic-console-apps/3-0-0-29-simplifying-business-logic-with-properties"},"next":{"title":"\ud83d\udcd3 3.0.0.31 Configuration Reference and Review of C# Conventions","permalink":"/v1.3/c-and-net/lessons-19-31-basic-console-apps/3-0-0-31-configuration-reference-and-review-of-c-conventions"}}');var o=n(74848),r=n(28453);const c={title:"\ud83d\udcd3 3.0.0.30 Console App Project Structure: How to Add More Code Files",day:"weekend",id:"3-0-0-30-console-app-project-structure-how-to-add-more-code-files",hide_table_of_contents:!0},i=void 0,t={},l=[{value:"Adding More Business Logic Files",id:"adding-more-business-logic-files",level:2},{value:"Adding More UI Logic Files",id:"adding-more-ui-logic-files",level:2},{value:"Verbatim String Literals",id:"verbatim-string-literals",level:3},{value:"Ascii Banners",id:"ascii-banners",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const s={a:"a",code:"code",div:"div",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(s.p,{children:["In this lesson, we'll go over how to add more code files to our Shape Tracker project, and what namespaces we might add them to. We'll also learn that classes in the same namespace are in the same ",(0,o.jsx)(s.strong,{children:"scope"})," and therefore have access to each other without the need of a using directive."]}),"\n",(0,o.jsx)(s.h2,{id:"adding-more-business-logic-files",children:"Adding More Business Logic Files"}),"\n",(0,o.jsx)(s.hr,{}),"\n",(0,o.jsxs)(s.p,{children:["Let's say we want to expand our Shape Tracker project to add a class for ",(0,o.jsx)(s.code,{children:"Ellipse"})," (which includes circles) and ",(0,o.jsx)(s.code,{children:"Rectangle"})," (which includes squares). We might add functionality that will allow users to calculate the area of an ellipse or rectangle, but we're not concerned about those details right now. The big question is where should we add those classes? A straightforward rule to follow is to create separate files for each new class, such that our project structure looks like this:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{children:"ShapeTracker.Solution/\n  \u251c\u2500\u2500 ShapeTracker/\n  \u2502     \u251c\u2500\u2500 Models/\n  |     |     \u251c\u2500\u2500 Ellipse.cs\n  |     |     \u251c\u2500\u2500 Rectangle.cs\n  \u2502     \u2502     \u2514\u2500\u2500 Triangle.cs\n  \u2502     \u251c\u2500\u2500 ShapeTracker.csproj\n  \u2502     \u2514\u2500\u2500 Program.cs\n  \u251c\u2500\u2500 .gitignore\n  \u2514\u2500\u2500 README.md\n"})}),"\n",(0,o.jsxs)(s.p,{children:["Since each of these classes are a part of our Shape Tracker models, we should also add each new class to the ",(0,o.jsx)(s.code,{children:"ShapeTracker.Models"})," namespace:"]}),"\n",(0,o.jsx)(s.div,{className:"filename",children:"Models/Ellipse.cs"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-csharp",children:"namespace ShapeTracker.Models\n{\n  public class Ellipse\n  {\n    // Ellipse code here.\n  }\n}\n"})}),"\n",(0,o.jsx)(s.div,{className:"filename",children:"Models/Rectangle.cs"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-csharp",children:"namespace ShapeTracker.Models\n{\n  public class Rectangle\n  {\n    // Rectangle code here.\n  }\n}\n"})}),"\n",(0,o.jsxs)(s.p,{children:["As we can see in the above example, we can reuse existing namespaces in new files to add new classes to that namespace. All classes declared in the same namespace will 'know' about each other and be in the same ",(0,o.jsx)(s.strong,{children:"scope"}),". For example, this means we don't have to include a using directive for ",(0,o.jsx)(s.code,{children:"ShapeTracker.Models"})," in order to use ",(0,o.jsx)(s.code,{children:"Triangle"})," logic within our ",(0,o.jsx)(s.code,{children:"Rectangle"})," class (even though there's not a good reason to do this anyways). Similarly, we don't need to include a brand new using directive in ",(0,o.jsx)(s.code,{children:"Program.cs"})," to start using the ",(0,o.jsx)(s.code,{children:"Ellipse"})," or ",(0,o.jsx)(s.code,{children:"Rectangle"})," classes."]}),"\n",(0,o.jsxs)(s.p,{children:["Another organization we could follow is adding all of our Shape Tracker models to one file. In this case, we could create a ",(0,o.jsx)(s.code,{children:"Shapes.cs"})," and add the ",(0,o.jsx)(s.code,{children:"Triangle"}),", ",(0,o.jsx)(s.code,{children:"Rectangle"}),", and ",(0,o.jsx)(s.code,{children:"Ellipse"})," classes within it. The project structure would look like this:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{children:"ShapeTracker.Solution/\n  \u251c\u2500\u2500 ShapeTracker/\n  \u2502     \u251c\u2500\u2500 Models/\n  \u2502     \u2502     \u2514\u2500\u2500 Shapes.cs\n  \u2502     \u251c\u2500\u2500 ShapeTracker.csproj\n  \u2502     \u2514\u2500\u2500 Program.cs\n  \u251c\u2500\u2500 .gitignore\n  \u2514\u2500\u2500 README.md\n"})}),"\n",(0,o.jsxs)(s.p,{children:["Take note that the ",(0,o.jsx)(s.strong,{children:"naming convention"})," for files that contain multiple classes is to give the file a plural name, like ",(0,o.jsx)(s.code,{children:"Shapes.cs"}),", and not ",(0,o.jsx)(s.code,{children:"Shape.cs"}),"."]}),"\n",(0,o.jsxs)(s.p,{children:["And ",(0,o.jsx)(s.code,{children:"Shapes.cs"})," would look like this (with some code omitted for brevity):"]}),"\n",(0,o.jsx)(s.div,{className:"filename",children:"Models/Shapes.cs"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-csharp",children:"namespace ShapeTracker.Models\n{\n  public class Rectangle\n  {\n    // Rectangle code here.\n  }\n\n  public class Ellipse\n  {\n    // Ellipse code here.\n  }\n\n  public class Triangle\n  {\n    // Triangle code here.\n  }\n}\n"})}),"\n",(0,o.jsxs)(s.p,{children:["In the example projects in the C# .NET course, we'll usually have one class per file. That's because it's more descriptive \u2014 as in, ",(0,o.jsx)(s.code,{children:"Ellipse"})," class logic is found in ",(0,o.jsx)(s.code,{children:"Ellipse.cs"})," \u2014 and individual files have less code in them. Because of these reasons, for the Shape Tracker app, I think it makes more sense to put each shape class within individual files. While there's no hard and fast rule for how you organize classes into files, you always want to make sure the choice you are making leads to source code that is descriptive and easy to navigate."]}),"\n",(0,o.jsx)(s.h2,{id:"adding-more-ui-logic-files",children:"Adding More UI Logic Files"}),"\n",(0,o.jsx)(s.hr,{}),"\n",(0,o.jsxs)(s.p,{children:["For the console app projects we create in this course section, we'll likely be fine to put all UI logic in the ",(0,o.jsx)(s.code,{children:"Program"})," class (separated into multiple methods) within ",(0,o.jsx)(s.code,{children:"Program.cs"}),". However, if you end up creating a more complex UI logic in your console app, you may want to separate your UI into helper classes within multiple files to better keep your logic organized. A structure like that may look like this:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{children:"ShapeTracker.Solution/\n  \u251c\u2500\u2500 ShapeTracker/\n  \u2502     \u251c\u2500\u2500 Models/\n  |     |     \u251c\u2500\u2500 Ellipse.cs\n  |     |     \u251c\u2500\u2500 Rectangle.cs\n  \u2502     \u2502     \u2514\u2500\u2500 Triangle.cs\n  |     \u251c\u2500\u2500 UserInterfaceModels/\n  |     |     \u2514\u2500\u2500 Banners.cs\n  \u2502     \u251c\u2500\u2500 ShapeTracker.csproj\n  \u2502     \u2514\u2500\u2500 Program.cs\n  \u251c\u2500\u2500 .gitignore\n  \u2514\u2500\u2500 README.md\n"})}),"\n",(0,o.jsxs)(s.p,{children:["We've created a new folder called ",(0,o.jsx)(s.code,{children:"UserInterfaceModels/"})," within the ",(0,o.jsx)(s.code,{children:"ShapeTracker/"})," directory."]}),"\n",(0,o.jsxs)(s.p,{children:["Notice that ",(0,o.jsx)(s.code,{children:"Program.cs"})," is not inside the new ",(0,o.jsx)(s.code,{children:"UserInterfaceModels/"})," directory \u2014 that's because it's best practice to leave ",(0,o.jsx)(s.code,{children:"Program.cs"})," in the root of the production/project directory since it is the entry point to our application."]}),"\n",(0,o.jsxs)(s.p,{children:["Within ",(0,o.jsx)(s.code,{children:"UserInterfaceModels/"})," we have a made-up file called ",(0,o.jsx)(s.code,{children:"Banner.cs"})," that will contain multiple classes within it, each of which has a static property that stores different banners:"]}),"\n",(0,o.jsx)(s.div,{className:"filename",children:"UserInterfaceModels/Banners.cs"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-csharp",children:'namespace ShapeTracker.UserInterfaceModels\n{\n  class WelcomeBanner\n  {\n    public static string Welcome { get; } = @"\n  #####                                #######                                           \n #     # #    #   ##   #####  ######      #    #####    ##    ####  #    # ###### #####  \n #       #    #  #  #  #    # #           #    #    #  #  #  #    # #   #  #      #    # \n  #####  ###### #    # #    # #####       #    #    # #    # #      ####   #####  #    # \n       # #    # ###### #####  #           #    #####  ###### #      #  #   #      #####  \n #     # #    # #    # #      #           #    #   #  #    # #    # #   #  #      #   #  \n  #####  #    # #    # #      ######      #    #    # #    #  ####  #    # ###### #    # \n                                                                                         ";\n  }\n\n  class GoodbyeBanner\n  {\n    // GoodbyeBanner code here.\n  }\n\n  class SubMenuBanner\n  {\n    // SubMenuBanner code here.\n  }\n}\n'})}),"\n",(0,o.jsxs)(s.p,{children:["First note that we're using a new namespace: ",(0,o.jsx)(s.code,{children:"ShapeTracker.UserInterfaceModels"}),". That means if we want to use any class within the ",(0,o.jsx)(s.code,{children:"Banners.cs"})," file in ",(0,o.jsx)(s.code,{children:"Program.cs"}),", we'll need to add a new using directive: ",(0,o.jsx)(s.code,{children:"using ShapeTracker.UserInterfaceModels;"}),"."]}),"\n",(0,o.jsxs)(s.p,{children:["Why not add the classes within ",(0,o.jsx)(s.code,{children:"Banner.cs"})," to the namespace ",(0,o.jsx)(s.code,{children:"ShapeTracker"}),", which contains the ",(0,o.jsx)(s.code,{children:"Program"})," class and our project's entry point? Well, it would actually be fine to use the ",(0,o.jsx)(s.code,{children:"ShapeTracker"})," namespace in ",(0,o.jsx)(s.code,{children:"Banner.cs"}),"."]}),"\n",(0,o.jsx)(s.p,{children:"In this example of growing our application's source code, we've opted to use three namespaces because it creates a clearer separation of source code:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"ShapeTracker.Models"})," for our business logic (everything in the ",(0,o.jsx)(s.code,{children:"Models/"})," directory)."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"ShapeTracker"})," for our program's entry point in ",(0,o.jsx)(s.code,{children:"Program.cs"}),"."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"ShapeTracker.UserInterfaceModels"})," for our additional UI logic models (everything in the ",(0,o.jsx)(s.code,{children:"UserInterfaceModels/"})," directory)."]}),"\n"]}),"\n",(0,o.jsx)(s.p,{children:"However, you might prefer to keep the namespaces simple, and just go for two: one for the UI logic and the other for business logic. This organizational decision is yours. The baseline requirement is that you organize your code into namespaces so that your code is scalable."}),"\n",(0,o.jsxs)(s.p,{children:["Finally, note that we are not including the ",(0,o.jsx)(s.code,{children:"public"})," access modifier on the ",(0,o.jsx)(s.code,{children:"WelcomeBanner"}),", ",(0,o.jsx)(s.code,{children:"GoodbyeBanner"}),", and ",(0,o.jsx)(s.code,{children:"SubMenuBanner"})," classes. That means each of these classes will default to the access modifier of ",(0,o.jsx)(s.code,{children:"internal"}),", which means that these classes are available publicly within this assembly, but not outside of the assembly. Why does this matter? The short answer is that we won't be testing our user interface logic, so this code only needs to be accessible within the ",(0,o.jsx)(s.code,{children:"ShapeTracker"})," folder. The long answer is that ",(0,o.jsx)(s.code,{children:"ShapeTracker"})," is one assembly, and when we write tests, we'll be creating a separate assembly; so any Shape Tracker code that we want accessible to our testing folder will need to have the ",(0,o.jsx)(s.code,{children:"public"})," access modifier. We'll revisit this topic when we start writing tests."]}),"\n",(0,o.jsx)(s.h3,{id:"verbatim-string-literals",children:"Verbatim String Literals"}),"\n",(0,o.jsxs)(s.p,{children:["Before we move on, check out the above code snippet for ",(0,o.jsx)(s.code,{children:"Banner.cs"})," again. Take note of the ",(0,o.jsx)(s.code,{children:"@"})," symbol in front of the string that contains the ",(0,o.jsx)(s.code,{children:"Welcome"})," banner."]}),"\n",(0,o.jsxs)(s.p,{children:["The ",(0,o.jsx)(s.code,{children:"@"})," symbol defines a ",(0,o.jsx)(s.strong,{children:"verbatim string literal"}),", which prints the string as-is, without changing formatting or evaluating any escape sequences. An example ",(0,o.jsx)(s.strong,{children:"escape sequence"})," is when we include ",(0,o.jsx)(s.code,{children:"\\n"})," within a string to momentarily escape the string, create a new line, and then go back to evaluating the string. Here's an example using the ",(0,o.jsx)(s.code,{children:"dotnet-script"})," REPL:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-csharp",children:'> Console.WriteLine("Hello\\nWorld");\nHello\nWorld\n> Console.WriteLine(@"Hello\\nWorld");\nHello\\nWorld\n'})}),"\n",(0,o.jsx)(s.h3,{id:"ascii-banners",children:"Ascii Banners"}),"\n",(0,o.jsxs)(s.p,{children:["Ascii text banners are a very cool way to decorate your console apps and create distinct sections within your UI. There's a lot of ascii text generators out there. ",(0,o.jsx)(s.a,{href:"https://manytools.org/hacker-tools/ascii-banner/",children:"Here's one"})," you can use in the projects you create."]}),"\n",(0,o.jsx)(s.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(s.hr,{}),"\n",(0,o.jsx)(s.p,{children:"Organizing code in C# is much the same as it is in JavaScript: we want to separate code by concern and use descriptive names. The big difference between the two languages is that C# has namespaces that we can use to further group code, beyond classes, files, and directories."}),"\n",(0,o.jsx)(s.p,{children:"For namespaces, keep in mind two things:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsx)(s.li,{children:"We can reuse the same namespace across multiple files."}),"\n",(0,o.jsx)(s.li,{children:"When classes are in the same namespace, they are in the same scope and automatically have access to each other."}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);