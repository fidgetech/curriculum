"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[98756],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(96540);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}},46150:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-14-processing-html-with-a-webpack-plugin","title":"\ud83d\udcd3 2.2.0.14 Processing HTML with a webpack Plugin","description":"So far we\'ve used webpack to bundle our JavaScript and CSS files. We can also use webpack to generate HTML files for us. Note that we\'re not using webpack to bundle HTML with our JS and CSS \u2014 instead, we\'re using webpack to do some additional work for us by having webpack process and generate our HTML based on a template we provide to webpack.","source":"@site/versioned_docs/version-v1_3/2_intermediate-javascript/2_test-driven-development-and-environments-with-javascript/2-2-0-14-processing-html-with-a-webpack-plugin.md","sourceDirName":"2_intermediate-javascript/2_test-driven-development-and-environments-with-javascript","slug":"/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-14-processing-html-with-a-webpack-plugin","permalink":"/v1.3/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-14-processing-html-with-a-webpack-plugin","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 2.2.0.14 Processing HTML with a webpack Plugin","day":"weekend","id":"2-2-0-14-processing-html-with-a-webpack-plugin","hide_table_of_contents":true},"sidebar":"intermediate-javascript","previous":{"title":"\ud83d\udcd3 2.2.0.13 Bundling CSS with webpack Loaders","permalink":"/v1.3/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-13-bundling-css-with-webpack-loaders"},"next":{"title":"\ud83d\udcd3 2.2.0.15 Improving Development by Automating Clean Up Tasks","permalink":"/v1.3/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-15-improving-development-by-automating-clean-up-tasks"}}');var s=t(74848),o=t(28453);const a={title:"\ud83d\udcd3 2.2.0.14 Processing HTML with a webpack Plugin",day:"weekend",id:"2-2-0-14-processing-html-with-a-webpack-plugin",hide_table_of_contents:!0},r=void 0,l={},d=[{value:"webpack Plugins",id:"webpack-plugins",level:2},{value:"Using HtmlWebpackPlugin",id:"using-htmlwebpackplugin",level:2}];function c(e){const n={a:"a",code:"code",div:"div",em:"em",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"So far we've used webpack to bundle our JavaScript and CSS files. We can also use webpack to generate HTML files for us. Note that we're not using webpack to bundle HTML with our JS and CSS \u2014 instead, we're using webpack to do some additional work for us by having webpack process and generate our HTML based on a template we provide to webpack."}),"\n",(0,s.jsx)(n.p,{children:"Why would we do this? A bigger application could have many HTML files, all with multiple different entry points. In fact, this is a feature of webpack \u2014 to have multiple entry points instead of just one. With multiple entry points, we can tell webpack to create a bundle with dependencies for each entry point we specify. In turn, this gives us flexibility to load just one or all bundles, or load them at different times. This is a more advanced topic that you don't need to understand right now. At Epicodus, we'll only use one entry point with one bundle."}),"\n",(0,s.jsxs)(n.p,{children:["Let's get back to why we would use webpack to generate our HTML. Considering again an application with multiple entry points, what if someone adds an entry point or changes the ",(0,s.jsx)(n.code,{children:"output"})," configuration in ",(0,s.jsx)(n.code,{children:"webpack.config.js"}),"? Our HTML file's script tags would then also need to be updated, too. That might lead to errors, and it is something we would need to manage carefully in order to avoid errors."]}),"\n",(0,s.jsxs)(n.p,{children:["In an ideal world, we should only have to update our configuration file, and have our changes automatically be applied by webpack. Well, that's just what we'll do with a webpack plugin called ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/plugins/html-webpack-plugin/",children:"HtmlWebpackPlugin"})," \u2014 we'll let  webpack do the heavy lifting of processing and generating our HTML files."]}),"\n",(0,s.jsx)(n.p,{children:"By the end of this lesson, you should have HtmlWebpackPlugin installed and configured in your Shape Tracker project."}),"\n",(0,s.jsx)(n.h2,{id:"webpack-plugins",children:"webpack Plugins"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["To add this functionality to webpack, we'll use our first ",(0,s.jsx)(n.strong,{children:"plugin"})," called HtmlWebpackPlugin."]}),"\n",(0,s.jsx)(n.p,{children:"What's the difference between a webpack loader and a webpack plugin?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Loaders preprocess code that webpack can't directly work with, which means any file that's not JavaScript. Generally loaders process code before or during the creation of our bundle, and they only work with specific file types."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Plugins are more powerful. They can modify and work with the entire bundle, so they generally run after the bundle has been created."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If the difference between loaders and plugins is feeling fuzzy, that's nothing to be worried about. You can continue using webpack without knowing the difference between loaders and plugins. Also, don't worry about spending extra time trying to understand the difference between the two. For the most part, once we have an environment set up, we can forget about it \u2014 at least until we need to add or update new packages."}),"\n",(0,s.jsx)(n.h2,{id:"using-htmlwebpackplugin",children:"Using HtmlWebpackPlugin"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["Before we install the plugin, ",(0,s.jsxs)(n.strong,{children:["let's move our ",(0,s.jsx)(n.code,{children:"index.html"})," file from the ",(0,s.jsx)(n.code,{children:"dist"})," folder back into the ",(0,s.jsx)(n.code,{children:"src"})," folder"]}),". Why? From now on, we'll let webpack handle generating our HTML and outputting it to ",(0,s.jsx)(n.code,{children:"dist"}),", and the ",(0,s.jsx)(n.code,{children:"src/index.html"})," will be the HTML template that webpack uses to do this."]}),"\n",(0,s.jsxs)(n.p,{children:["This is why ",(0,s.jsx)(n.code,{children:"dist/"})," is in our ",(0,s.jsx)(n.code,{children:".gitignore"})," file \u2014 webpack will automatically generate everything inside this directory for us. Any developer can clone our project and then build it from our source code \u2014 so it would be redundant to push that code to GitHub."]}),"\n",(0,s.jsx)(n.p,{children:"Now let's add another dev dependency with npm. In the terminal, navigate to the root of the Shape Tracker project and enter the following command."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"$ npm install html-webpack-plugin@4.5.2 --save-dev\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Let's also update ",(0,s.jsx)(n.code,{children:"webpack.config.js"})," to use this new plugin:"]}),"\n",(0,s.jsx)(n.div,{className:"filename",children:"webpack.config.js"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const path = require('path');\n// There's a new line below this one!\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist')\n  },\n  // The plugins key below this line is also new!\n  plugins: [\n    new HtmlWebpackPlugin({\n      title: 'Shape Tracker',\n      template: './src/index.html',\n      inject: 'body'\n    })\n  ],\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          'style-loader',\n          'css-loader'\n        ]\n      }\n    ]\n  }\n};\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["First we require ",(0,s.jsx)(n.code,{children:"html-webpack-plugin"})," and make it available in ",(0,s.jsx)(n.code,{children:"webpack.config.js"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Next we add a new key to the ",(0,s.jsx)(n.code,{children:"module.exports"})," object called ",(0,s.jsx)(n.code,{children:"plugins"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Finally, we instantiate a new ",(0,s.jsx)(n.code,{children:"HtmlWebpackPlugin"}),". Our instantiated plugin is taking three arguments:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"title"}),": This will be the title of our auto-generated HTML file."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"template"}),": This is the HTML file we'll use as a template. Here we specify that it should be the ",(0,s.jsx)(n.code,{children:"index.html"})," file we just moved to the ",(0,s.jsx)(n.code,{children:"src"})," folder. If we didn't specify a template file, then webpack would just generate a file with a ",(0,s.jsx)(n.code,{children:"<head>"})," and ",(0,s.jsx)(n.code,{children:"<title>"})," and ",(0,s.jsx)(n.code,{children:"<script>"})," tags."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"inject"}),": This is a nice little option. webpack will inject our script at the bottom of our HTML for us. It's yucky to put script tags in the body when we're writing code because it's hard to read and mixes HTML and JS, which are separate concerns. However, our code will be more performant in production if we put our script tags there. webpack gives us the best of both worlds. We can write clean code when we're developing and then let webpack make it more performant for us by moving the script tags to the bottom of the HTML."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Also, because all the code in our HTML file loads synchronously, line by line, putting our script tags at the end of our HTML file means that we NO longer need to create an event listener for the ",(0,s.jsx)(n.code,{children:"window"})," 'load' event in our code:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"window.addEventListener('load', function() {\n  // We set up event listeners here.\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"That's because we use it to prevent our scripts from running before our HTML has loaded so that we can ensure that our HTML elements exist and we can target them with document query methods. Moving our script tag to the bottom of our HTML file will reorder the loading process of our project's dependencies: first our HTML will load, then our scripts will load. Again, this happens because our script tag has been added to the bottom of our HTML body."}),"\n",(0,s.jsxs)(n.p,{children:["All that said, we won't remove the event listener for the ",(0,s.jsx)(n.code,{children:"window"})," 'load' event from our example projects. However, you can if you would like to, as long as your scripts tags are at the bottom of your HTML's body tag, with or without using webpack."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," Some students have found that their projects load faster ",(0,s.jsx)(n.em,{children:"in development"})," when they use ",(0,s.jsx)(n.code,{children:"inject: 'head'"})," instead of ",(0,s.jsx)(n.code,{children:"inject: 'body'"}),". Ultimately, you may use either option based on your preferences. However, keep in mind that having the script at the end of the body is preferable for production sites."]}),"\n",(0,s.jsxs)(n.p,{children:["Before we ",(0,s.jsx)(n.code,{children:"$ npm run build"})," our application again, let's remove the ",(0,s.jsx)(n.code,{children:"<script>"})," tag currently linking our bundled JavaScript from ",(0,s.jsx)(n.code,{children:"index.html"}),". Here's the updated ",(0,s.jsx)(n.code,{children:"<head>"}),":"]}),"\n",(0,s.jsx)(n.div,{className:"filename",children:"src/index.html"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"...\n<head>\n  <title>Shape Tracker</title>\n</head>\n...\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now run ",(0,s.jsx)(n.code,{children:"$ npm run build"}),". webpack will add ",(0,s.jsx)(n.code,{children:"index.html"})," to our ",(0,s.jsx)(n.code,{children:"dist"})," folder for us. If you take a look, you'll see that webpack has added a script tag for our bundled JavaScript to the bottom of our HTML file."]}),"\n",(0,s.jsxs)(n.p,{children:["At this point, we can open ",(0,s.jsx)(n.code,{children:"dist/index.html"})," (either by opening it in the browser or by using Live Server), and our site will be there. Everything appears exactly the same \u2014 but our code is now bundled."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);