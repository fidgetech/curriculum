"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[47608],{8771:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/good-failing-test-9fadd5cb900b046d21114a9ac8d7061b.png"},12259:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/bad-failing-test-72b5bcd8f3c107c9666c7221529212d0.png"},28453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>o});var n=s(96540);const i={},r=n.createContext(i);function a(e){const t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(r.Provider,{value:t},e.children)}},58392:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/first-passing-triangle-test-2ff4ec7a82fbe973c3b41b3ff88d6508.png"},65744:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-1-6-tdd-with-jest-testing-the-triangle-constructor","title":"\ud83d\udcd3 2.2.1.6 TDD with Jest: Testing the Triangle() Constructor","description":"Now that Jest is set up, it\'s time to test some code. We\'re now ready to write the business logic to check if three lengths make a triangle (and what kind of triangle they make) in our shape tracker application. As we write our business logic, we\'ll use the Red, Green, Refactor workflow, and commit our code after each passing test.","source":"@site/versioned_docs/version-v1_3/2_intermediate-javascript/2_test-driven-development-and-environments-with-javascript/2-2-1-06-tdd-with-jest-testing-the-triangle-constructor.md","sourceDirName":"2_intermediate-javascript/2_test-driven-development-and-environments-with-javascript","slug":"/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-1-6-tdd-with-jest-testing-the-triangle-constructor","permalink":"/v1.3/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-1-6-tdd-with-jest-testing-the-triangle-constructor","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 2.2.1.6 TDD with Jest: Testing the Triangle() Constructor","day":"monday","id":"2-2-1-6-tdd-with-jest-testing-the-triangle-constructor","hide_table_of_contents":true},"sidebar":"intermediate-javascript","previous":{"title":"\ud83d\udcd3 2.2.1.5 Setting Up Babel","permalink":"/v1.3/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-1-5-setting-up-babel"},"next":{"title":"\ud83d\udcd3 2.2.1.7 TDD with Jest: Testing the Triangle.prototype.checkType() Method","permalink":"/v1.3/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-1-7-tdd-with-jest-testing-the-triangle-prototype-checktype-method"}}');var i=s(74848),r=s(28453);const a={title:"\ud83d\udcd3 2.2.1.6 TDD with Jest: Testing the Triangle() Constructor",day:"monday",id:"2-2-1-6-tdd-with-jest-testing-the-triangle-constructor",hide_table_of_contents:!0},o=void 0,c={},l=[{value:"Review: Writing Tests before Logic",id:"review-writing-tests-before-logic",level:2},{value:"Test 1: Should Correctly Create a Triangle Object with Three Lengths",id:"test-1-should-correctly-create-a-triangle-object-with-three-lengths",level:2},{value:"1. First, we must always import any necessary code from other files.",id:"1-first-we-must-always-import-any-necessary-code-from-other-files",level:3},{value:"2. Then we set up a <code>describe()</code> statement.",id:"2-then-we-set-up-a-describe-statement",level:3},{value:"3. Next, within our <code>describe()</code> block, we create a test that calls on the function we are testing.",id:"3-next-within-our-describe-block-we-create-a-test-that-calls-on-the-function-we-are-testing",level:3},{value:"4. Finally, every test includes one or more expectation statements that use a matcher method.",id:"4-finally-every-test-includes-one-or-more-expectation-statements-that-use-a-matcher-method",level:3},{value:"A Best Practice: A Test Should Test for One Thing, No Matter How Many Expectation Statements There Are",id:"a-best-practice-a-test-should-test-for-one-thing-no-matter-how-many-expectation-statements-there-are",level:3},{value:"A Bad Fail",id:"a-bad-fail",level:2},{value:"A Good Fail",id:"a-good-fail",level:2},{value:"Passing Our First Test",id:"passing-our-first-test",level:2},{value:"How to Test Functions that Have Multiple Behaviors",id:"how-to-test-functions-that-have-multiple-behaviors",level:2}];function h(e){const t={a:"a",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["Now that Jest is set up, it's time to test some code. We're now ready to write the business logic to check if three lengths make a triangle (and what kind of triangle they make) in our shape tracker application. As we write our business logic, we'll use the Red, Green, Refactor workflow, and commit our code after ",(0,i.jsx)(t.em,{children:"each"})," passing test."]}),"\n",(0,i.jsxs)(t.p,{children:["In order to effectively demonstrate the Red, Green, Refactor workflow, we'll need to start from scratch, which means ",(0,i.jsxs)(t.strong,{children:["we'll need to delete all of our business logic in ",(0,i.jsx)(t.code,{children:"triangle.js"})]}),". Go ahead and do so now."]}),"\n",(0,i.jsx)(t.p,{children:"Also note that over the last few course sections, we've been adding pseudocode tests to our READMEs. We've done so with specific goals in mind: to learn how to use a TDD approach as a problem-solving tool and also to prepare for writing tests using Jest. Now that we're actually writing tests with Jest, it's no longer necessary to add pseudocode tests in your READMEs. Instead, we'll shift our focus to comprehensively testing our code with Jest."}),"\n",(0,i.jsx)(t.h2,{id:"review-writing-tests-before-logic",children:"Review: Writing Tests before Logic"}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.p,{children:"Students often describe that it's an awkward process to write a test before the actual logic has been written that the test is supposed to test for. This is certainly true, and can take some getting used to."}),"\n",(0,i.jsx)(t.p,{children:"One thing that's helpful to remember is that we're shaping the name and functionality of a function when we write the test. We decide what our function is called, how we call it (if there's any arguments, or not), and what it returns all before actually coding it. And this is exactly the point of this Test-Driven Development \u2014 to decide where we're going before we start coding \u2014 and to do so incrementally."}),"\n",(0,i.jsx)(t.h2,{id:"test-1-should-correctly-create-a-triangle-object-with-three-lengths",children:"Test 1: Should Correctly Create a Triangle Object with Three Lengths"}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsxs)(t.p,{children:["With the business logic erased in ",(0,i.jsx)(t.code,{children:"src/triangle.js"}),", we're ready to recreate the business logic for our ",(0,i.jsx)(t.code,{children:"Triangle"})," object using TDD."]}),"\n",(0,i.jsx)(t.p,{children:"Let's write our first test. A lot of the content will look familiar because we've written pseudocode tests that look very similar to Jest tests."}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"__tests__/triangle.test.js"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"import Triangle from './../src/triangle.js';\n\ndescribe('Triangle', () => {\n\n  test('should correctly create a triangle object with three lengths', () => {\n    const triangle = new Triangle(2,4,5);\n    expect(triangle.side1).toEqual(2);\n    expect(triangle.side2).toEqual(4);\n    expect(triangle.side3).toEqual(5);\n  });\n});\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The test above simply checks to see if the constructor works and properly instantiates a ",(0,i.jsx)(t.code,{children:"Triangle"})," object with three properties: ",(0,i.jsx)(t.code,{children:"side1"}),", ",(0,i.jsx)(t.code,{children:"side2"}),", and ",(0,i.jsx)(t.code,{children:"side3"}),". Remember that we should always start by testing the smallest possible behavior. In this case, it makes sense to check if we can properly instantiate a ",(0,i.jsx)(t.code,{children:"Triangle"})," object."]}),"\n",(0,i.jsx)(t.p,{children:"Let's go over the different parts of this test including the new functions and methods that we're using from Jest to run our tests:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"describe()"})," function."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"test()"})," function."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"expect()"})," function."]}),"\n",(0,i.jsxs)(t.li,{children:["And 'matcher' methods, like ",(0,i.jsx)(t.code,{children:"toEqual()"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"1-first-we-must-always-import-any-necessary-code-from-other-files",children:"1. First, we must always import any necessary code from other files."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"import Triangle from './../src/triangle.js';\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In this case, we need to ",(0,i.jsx)(t.code,{children:"import Triangle from './../src/triangle.js';"}),". That way, Jest can actually access the file that needs to be tested. And don't forget that we used Babel to make sure Jest understands import and export statements \u2014 this is exactly the issue that Babel solves for us."]}),"\n",(0,i.jsxs)(t.h3,{id:"2-then-we-set-up-a-describe-statement",children:["2. Then we set up a ",(0,i.jsx)(t.code,{children:"describe()"})," statement."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"describe('Triangle', () => {\n  // tests go in here\n});\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We've been using ",(0,i.jsx)(t.strong,{children:"describe"})," to group our pseudocode tests so far so this term should be very familiar now. However, in the context of automated testing, we're going to be more specific about what it means: we use ",(0,i.jsx)(t.code,{children:"describe()"})," to define a ",(0,i.jsx)(t.strong,{children:"suite"}),". A suite allows us to group and organize tests. There's a couple things to note here:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["We don't need to describe this suite as a ",(0,i.jsx)(t.code,{children:"Triangle"}),". We could describe it as ",(0,i.jsx)(t.code,{children:"'the Triangle and all its prototypes'"}),". The description is there to make our code more readable."]}),"\n",(0,i.jsxs)(t.li,{children:["Our suite should be described in a concise and descriptive way. Since it's a suite that describes ",(0,i.jsx)(t.code,{children:"Triangle"})," and its prototypes, describing it as a ",(0,i.jsx)(t.code,{children:"Triangle"})," makes sense. If we were to test other shapes such as squares and circles, they'd have their own ",(0,i.jsx)(t.code,{children:"describe"})," block."]}),"\n",(0,i.jsxs)(t.li,{children:["We also have some new JS syntax called ",(0,i.jsx)(t.strong,{children:"arrow notation"}),": ",(0,i.jsx)(t.code,{children:"() =>"}),". When we use this syntax, it's the same thing as saying ",(0,i.jsx)(t.code,{children:"function()"}),", though, there are some other benefits to using arrow notation that function declarations do not have. We will cover arrow notation further in a future lesson. You can use either ",(0,i.jsx)(t.code,{children:"() =>"})," or ",(0,i.jsx)(t.code,{children:"function()"})," in your Jest tests. Keep in mind that the Jest documentation uses ",(0,i.jsx)(t.code,{children:"() =>"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.h3,{id:"3-next-within-our-describe-block-we-create-a-test-that-calls-on-the-function-we-are-testing",children:["3. Next, within our ",(0,i.jsx)(t.code,{children:"describe()"})," block, we create a test that calls on the function we are testing."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"test('should correctly create a triangle object with three lengths', () => {\n  const triangle = new Triangle(2,4,5);\n  expect(triangle.side1).toEqual(2);\n  expect(triangle.side2).toEqual(4);\n  expect(triangle.side3).toEqual(5);\n});\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The term ",(0,i.jsx)(t.strong,{children:"test"})," should be very familiar at this point! Jest tests begin with ",(0,i.jsx)(t.code,{children:"test()"})," \u2014 very similar to the pseudocode we've been using. Once again, we describe the content of the test, which generally begins with the word \"should.\" Jest doesn't care what we put in this string. It's there so we can better communicate our intentions as developers. As always, we should try to be specific without being overly verbose."]}),"\n",(0,i.jsxs)(t.p,{children:["Within the test, we can run any JavaScript code we need. Because this test is testing whether we can properly create an instance of a Triangle, we just need to call the ",(0,i.jsx)(t.code,{children:"Triangle()"})," constructor to  instantiate a ",(0,i.jsx)(t.code,{children:"triangle"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const triangle = new Triangle(2,4,5);\n"})}),"\n",(0,i.jsx)(t.h3,{id:"4-finally-every-test-includes-one-or-more-expectation-statements-that-use-a-matcher-method",children:"4. Finally, every test includes one or more expectation statements that use a matcher method."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"expect(triangle.side1).toEqual(2);\nexpect(triangle.side2).toEqual(4);\nexpect(triangle.side3).toEqual(5);\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We have 3 expectation statements, which are each made up of calling the ",(0,i.jsx)(t.code,{children:"expect()"})," function and a matcher method like ",(0,i.jsx)(t.code,{children:"toEqual()"}),". In these statements we describe what we expect our result to be, as compared to the actual result from calling on our business logic function."]}),"\n",(0,i.jsxs)(t.p,{children:["Expectation statements are common across test frameworks. It's also common to call an expectation an ",(0,i.jsx)(t.strong,{children:"assertion"}),", and these terms can be used interchangeably."]}),"\n",(0,i.jsxs)(t.p,{children:["We pass in the value that we've derived from running the ",(0,i.jsx)(t.code,{children:"Triangle()"})," constructor in the ",(0,i.jsx)(t.code,{children:"expect()"})," function, and then in the ",(0,i.jsx)(t.code,{children:"toEqual()"})," method we pass in a hardcoded value that represents our expected result from calling the ",(0,i.jsx)(t.code,{children:"Triangle()"})," constructor. If we wanted to describe this in pseudocode, here's what this looks like:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"// the arguments \nexpect(derivedValueFromBusinessLogic).toEqual(resultWeExpect);\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"toEqual()"})," method is called a ",(0,i.jsx)(t.strong,{children:"matcher"}),". A matcher determines how ",(0,i.jsx)(t.code,{children:"derivedValueFromBusinessLogic"})," should match ",(0,i.jsx)(t.code,{children:"resultWeExpect"}),". Or, how the actual result should match our expected result. In the test that we wrote, if the results are equal, the test returns true and the test will pass. If the results aren't equal, the test returns false and the test will fail."]}),"\n",(0,i.jsxs)(t.p,{children:["In the pseudocode tests we've written up until now, we always listed what we expected our output to equal as if we were using Jest's ",(0,i.jsx)(t.code,{children:"toEqual()"})," method. Well, Jest has many other matchers we can use. For instance, we can check if a value is less than another value, if it's true or false, and so on. For more information on matchers, see the ",(0,i.jsx)(t.a,{href:"https://jestjs.io/docs/en/using-matchers",children:"Jest documentation on using matchers"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"a-best-practice-a-test-should-test-for-one-thing-no-matter-how-many-expectation-statements-there-are",children:"A Best Practice: A Test Should Test for One Thing, No Matter How Many Expectation Statements There Are"}),"\n",(0,i.jsx)(t.p,{children:"As stated previously, the test we wrote has 3 expectation statements:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"test('should correctly create a triangle object with three lengths', () => {\n  const triangle = new Triangle(2,4,5);\n  expect(triangle.side1).toEqual(2);\n  expect(triangle.side2).toEqual(4);\n  expect(triangle.side3).toEqual(5);\n});\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Often tests will have just one expectation statement, unlike in the test above. However, you can really have as many expectations as you need, ",(0,i.jsx)(t.strong,{children:"as long as your test is testing for just one thing"}),". In this case, all of the expectations are testing the same thing: that the ",(0,i.jsx)(t.code,{children:"Triangle()"})," constructor can correctly create a ",(0,i.jsx)(t.code,{children:"Triangle"})," object with the properties it needs."]}),"\n",(0,i.jsx)(t.h2,{id:"a-bad-fail",children:"A Bad Fail"}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsxs)(t.p,{children:["Now that we have a test written for our ",(0,i.jsx)(t.code,{children:"Triangle()"})," constructor, and no logic in ",(0,i.jsx)(t.code,{children:"triangle.js"}),", we're ready to complete the red phase or Red, Green, Refactor to verify that our tests fails. In the root of the Shape Tracker directory, run the npm test script:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-shel",children:"$ npm test\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Test is failing and shows an error.",src:s(12259).A+"",width:"1358",height:"776"})}),"\n",(0,i.jsx)(t.p,{children:"Jest provides nice color coding for us. Green means the test passed while red indicates a fail. We've got a pretty obvious fail here, but it's not a meaningful one."}),"\n",(0,i.jsxs)(t.p,{children:["Remember how we said there are good and bad fails? Well, in this case, the test throws a ",(0,i.jsx)(t.code,{children:"TypeError: _triangle.Triangle is not a constructor"})," error when we try to instantiate a triangle."]}),"\n",(0,i.jsxs)(t.p,{children:["Why is it throwing the error? Well, we don't have a constructor now. Our goal is to test the constructor itself, not the ",(0,i.jsx)(t.em,{children:"absence"})," of a constructor. ",(0,i.jsx)(t.strong,{children:"If a test can't find a method, file, or constructor and fails as a result, that is always going to be a bad fail."})," It's not really testing anything \u2014 it's just demonstrating that our code isn't wired up properly."]}),"\n",(0,i.jsx)(t.p,{children:"Another way to tell this is a bad fail is because our expectation is never reached. The error happens immediately so our test doesn't run successfully."}),"\n",(0,i.jsx)(t.h2,{id:"a-good-fail",children:"A Good Fail"}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.p,{children:"Let's update our code to add our constructor back. We won't add any properties yet."}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"src/triangle.js"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"export default function Triangle(side1, side2, side3) {\n\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We now have a constructor that's successfully exported, even if no properties are initialized when the constructor makes a new instance of a ",(0,i.jsx)(t.code,{children:"Triangle"})," object. If we run ",(0,i.jsx)(t.code,{children:"$ npm test"})," again, our test will fail \u2014 as expected \u2014 but in a different way:"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"We get a different failure message this time.",src:s(8771).A+"",width:"1332",height:"776"})}),"\n",(0,i.jsx)(t.p,{children:"The failure message highlights the values of the expected value versus the received (actual or derived) value:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"expect(received).toEqual(expected) // deep equality\n\nExpected: 2\nReceived: undefined\n"})}),"\n",(0,i.jsx)(t.p,{children:"The key difference here is that we've actually reached our expectations. This way, we know that our test is properly connected to our code \u2014 and that we have a basic constructor in place. We expect our test to fail because our constructor doesn't have any properties yet."}),"\n",(0,i.jsx)(t.p,{children:"It's important to get our tests to fail first because otherwise we might get a false positive. This could happen if we wrote the test incorrectly or if our tests are testing something other than we intended."}),"\n",(0,i.jsx)(t.p,{children:"The red part of the RGR workflow is now complete, at least for our first test. That means we are ready to move onto getting the test passing \u2014 making it green."}),"\n",(0,i.jsx)(t.h2,{id:"passing-our-first-test",children:"Passing Our First Test"}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.p,{children:"Well, this part is simple. We just need to add our constructor's properties:"}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"src/triangle.js"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"export default function Triangle(side1, side2, side3) {\n  this.side1 = side1;\n  this.side2 = side2;\n  this.side3 = side3;\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Once we do that, we can run ",(0,i.jsx)(t.code,{children:"$ npm test"})," again."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Jest shows one passing test.",src:s(58392).A+"",width:"1170",height:"354"})}),"\n",(0,i.jsx)(t.p,{children:"As we can see, our test is color coded green now. We've passed our first test \u2014 and we can see why this is called the red-green-refactor workflow."}),"\n",(0,i.jsx)(t.p,{children:"There are no opportunities to refactor \u2014 at least not yet \u2014 but don't forget that we should always look for opportunities to improve our code after each passing test."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsxs)(t.strong,{children:["Now that we have a passing test, it's important to ",(0,i.jsx)(t.em,{children:"commit"})," your code."]})," You should always commit your code after ",(0,i.jsx)(t.em,{children:"each"})," passing test. Think of it as being like a save point where all is well and everything is working correctly \u2014 you can always return to this save point later if your code goes south."]}),"\n",(0,i.jsx)(t.p,{children:"Also, in the real world, we'll always want to commit after each passing test anyway to document our work. Just to clarify, you should commit not only the updated source code but also the updated tests."}),"\n",(0,i.jsx)(t.h2,{id:"how-to-test-functions-that-have-multiple-behaviors",children:"How to Test Functions that Have Multiple Behaviors"}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsxs)(t.p,{children:["There's one other important thing to note before we move on. Only one test is listed as passing even though we have three expectations. Is this an issue? Sometimes, but not always. Your ",(0,i.jsx)(t.strong,{children:"unit test"})," should always be testing one unit of code, meaning a single behavior. In this test, we're testing that the constructor can create a ",(0,i.jsx)(t.code,{children:"Triangle"})," object with 3 sides \u2014 this is just one behavior we're testing for, the creation of a triangle. In this case, it's fine to have multiple expectation statements in one test."]}),"\n",(0,i.jsxs)(t.p,{children:["However, what if our constructor handles creating a ",(0,i.jsx)(t.code,{children:"Triangle"})," object with 3 sides ",(0,i.jsx)(t.em,{children:"and"})," calculated whether or not the Triangle is in fact a triangle? Consider the code snippet below that borrows code from the ",(0,i.jsx)(t.code,{children:"Triangle.prototype.checkType()"})," method:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:'export default function Triangle(side1, side2, side3, height) {\n  this.side1 = side1;\n  this.side2 = side2;\n  this.side3 = side3;\n  this.isTriangle = ((this.side1 > (this.side2 + this.side3)) || (this.side2 > (this.side1 + this.side3)) || (this.side3 > (this.side1 + this.side2))) ? "not a triangle" : "this is a triangle"; \n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["In this example, we're using a ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator",children:"ternary operator"})}),", which takes this format:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"condition ? outcome if condition is truthy : outcome if condition is falsey`\n"})}),"\n",(0,i.jsxs)(t.p,{children:["There are 3 sections in the ternary, separated by a question mark ",(0,i.jsx)(t.code,{children:"?"})," and a colon ",(0,i.jsx)(t.code,{children:":"}),". In the first section, we state the condition that should be evaluated. In the next section after the ",(0,i.jsx)(t.code,{children:"?"}),", we have the expression that will execute if the condition is truthy. Then in the last section after the ",(0,i.jsx)(t.code,{children:":"}),",  we have the expression that will execute if the condition is false."]}),"\n",(0,i.jsxs)(t.p,{children:["In our example, ",(0,i.jsx)(t.code,{children:"this.isTriangle"})," will be set to the value of ",(0,i.jsx)(t.code,{children:'"not a triangle"'})," or ",(0,i.jsx)(t.code,{children:'"this is a triangle"'})," depending on whether this condition:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"((this.side1 > (this.side2 + this.side3)) || (this.side2 > (this.side1 + this.side3)) || (this.side3 > (this.side1 + this.side2)))\n"})}),"\n",(0,i.jsx)(t.p,{children:"returns as true or false."}),"\n",(0,i.jsxs)(t.p,{children:["Now, does the Triangle constructor include one behavior or two behaviors? Would we write a test for creating a ",(0,i.jsx)(t.code,{children:"Triangle"})," object with 3 sides and an isTriangle property? Or would we write two tests, one for determining whether the sides make a true triangle, and the other for creating a triangle object with 3 sides?"]}),"\n",(0,i.jsx)(t.p,{children:"There's no right answer. However, we want you to ask these questions so that you are considering how to write your tests so that they clearly communicate the different behaviors of your application, no matter how it is structured in the code."}),"\n",(0,i.jsx)(t.p,{children:"Sometimes development teams or companies have specific guidelines for testing that could answer the question of whether to write two tests, or another expectation, however this is certainly not always the case."}),"\n",(0,i.jsx)(t.p,{children:"Now, let's consider this code:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:'export default function Triangle(side1, side2, side3, height) {\n  this.side1 = side1;\n  this.side2 = side2;\n  this.side3 = side3;\n  this.isTriangle = ((this.side1 > (this.side2 + this.side3)) || (this.side2 > (this.side1 + this.side3)) || (this.side3 > (this.side1 + this.side2))) ? "not a triangle" : "this is a triangle";\n  this.isScalene = ((this.side1 !== this.side2) && ((this.side1 !== this.side3)) && ((this.side2 !== this.side3))) ? "is scalene" : "not scalene";\n  this.isEquilateral = ((this.side1 === this.side2) && (this.side1 === this.side3)) ? "is equilateral" : "not equilateral";\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["This constructor is starting to get code smell! The ternary operator is hard to read, and the constructor is doing more than just creating a ",(0,i.jsx)(t.code,{children:"Triangle"})," object. In fact, this is why we have a ",(0,i.jsx)(t.code,{children:"Triangle.prototype.checkType()"})," method to determine what type of triangle we have!"]}),"\n",(0,i.jsx)(t.p,{children:"Those concerns aside, how many tests would you write for this constructor?"}),"\n",(0,i.jsxs)(t.p,{children:["If we had one test for the constructor with multiple expect statements covering all of the behavior, we'd be testing the ",(0,i.jsx)(t.code,{children:"Triangle"})," constructor, but it wouldn't be obvious that means we're:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Creating a ",(0,i.jsx)(t.code,{children:"Triangle"})," object with 3 sides, ",(0,i.jsx)(t.em,{children:"and"})]}),"\n",(0,i.jsxs)(t.li,{children:["Determining if the inputted sides actually make a triangle, ",(0,i.jsx)(t.em,{children:"and"}),","]}),"\n",(0,i.jsxs)(t.li,{children:["Determining if the triangle is scalene, ",(0,i.jsx)(t.em,{children:"and"})]}),"\n",(0,i.jsx)(t.li,{children:"Determining if the triangle is equilateral."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["When we distinguish each behavior, it becomes clear that we are doing much more than just creating a ",(0,i.jsx)(t.code,{children:"Triangle"})," object, and that it's likely better to have multiple tests that describe and test each behavior."]}),"\n",(0,i.jsx)(t.p,{children:"In the end, it's OK to have multiple expectations in a single test, but make sure that each test is covering just one behavior."}),"\n",(0,i.jsxs)(t.p,{children:["Next up, let's continue applying TDD and the RGR workflow to the ",(0,i.jsx)(t.code,{children:"Triangle.prototype.checkType()"})," method."]})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);