"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[11990],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var i=t(96540);const o={},a=i.createContext(o);function s(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:n},e.children)}},94584:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"introduction-to-programming/javascript-and-web-browsers/1-2-3-11-using-function-declarations-in-event-handling","title":"\ud83d\udcd3 1.2.3.11 Using Function Declarations in Event Handling","description":"In this lesson we\'ll learn how to use function declarations in event handling. We\'ll look at examples with event handler properties and event listeners. We\'ll also learn that using function declarations really improves code reusability and is generally considered a good choice for applications that scale. In the next lesson when we learn how to remove event listeners, we will need to use function declarations.","source":"@site/docs/1_introduction-to-programming/2_javascript-and-web-browsers/1-2-3-11-using-function-declarations-in-event-handling.md","sourceDirName":"1_introduction-to-programming/2_javascript-and-web-browsers","slug":"/introduction-to-programming/javascript-and-web-browsers/1-2-3-11-using-function-declarations-in-event-handling","permalink":"/v1.2/introduction-to-programming/javascript-and-web-browsers/1-2-3-11-using-function-declarations-in-event-handling","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 1.2.3.11 Using Function Declarations in Event Handling","day":"wednesday","id":"1-2-3-11-using-function-declarations-in-event-handling","hide_table_of_contents":true},"sidebar":"introduction-to-programming","previous":{"title":"\ud83d\udcd3 1.2.3.10 Event Handling with Event Listeners","permalink":"/v1.2/introduction-to-programming/javascript-and-web-browsers/1-2-3-10-event-handling-with-event-listeners"},"next":{"title":"\ud83d\udcd3 1.2.3.12 Removing Event Listeners","permalink":"/v1.2/introduction-to-programming/javascript-and-web-browsers/1-2-3-12-removing-event-listeners"}}');var o=t(74848),a=t(28453);const s={title:"\ud83d\udcd3 1.2.3.11 Using Function Declarations in Event Handling",day:"wednesday",id:"1-2-3-11-using-function-declarations-in-event-handling",hide_table_of_contents:!0},r=void 0,l={},c=[{value:"Using Function Declarations with Event Handler Properties",id:"using-function-declarations-with-event-handler-properties",level:2},{value:"Using Function Declarations with Event Listeners",id:"using-function-declarations-with-event-listeners",level:2},{value:"When Would I Use a Function Declaration in an Event Handler?",id:"when-would-i-use-a-function-declaration-in-an-event-handler",level:2},{value:"Writing Functions So They Are Reusable",id:"writing-functions-so-they-are-reusable",level:3},{value:"A Review of Hoisting",id:"a-review-of-hoisting",level:3},{value:"Reusable Code that Scales",id:"reusable-code-that-scales",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"In this lesson we'll learn how to use function declarations in event handling. We'll look at examples with event handler properties and event listeners. We'll also learn that using function declarations really improves code reusability and is generally considered a good choice for applications that scale. In the next lesson when we learn how to remove event listeners, we will need to use function declarations."}),"\n",(0,o.jsx)(n.h2,{id:"using-function-declarations-with-event-handler-properties",children:"Using Function Declarations with Event Handler Properties"}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.p,{children:["Let's see how to use a function declaration in an ",(0,o.jsx)(n.code,{children:"onclick"})," event handler property. We'll start by reviewing how to use an \"onevent\" property with a function expression. Below is the JS and a snippet of the HTML that we'll target. This code isn't from a specific project, just a small example to work with."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-html",children:"<h1>Heading 1</h1>\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'let h1 = document.querySelector("h1"); \nh1.onclick = function() {\n  window.alert("This is a heading element.");\n};\n'})}),"\n",(0,o.jsx)(n.p,{children:"Now let's use a function declaration instead. Check out the updated JS:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'let h1 = document.querySelector("h1");\nfunction alertHeading() {\n  window.alert("This is a heading element.");\n}\nh1.onclick = alertHeading;\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Notice that we only set the name of the function declaration as the value of the ",(0,o.jsx)(n.code,{children:"onclick"})," event handler property: ",(0,o.jsx)(n.code,{children:"h1.onclick = alertHeading;"}),". This is a good reminder of the distinctions within function syntax between defining a function, calling a function, and printing the value/definition of a function. Let's review these distinctions with an example. Check out the following code snippets and pay attention to the comments. Optionally try out the following code in your DevTools console."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'// we are defining a function with a function declaration\n> function alertHeading() {\n  window.alert("This is a heading element.");\n}\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// we are calling the alertHeading() function\n> alertHeading();\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'// this is printing the value of a function\n> alertHeading;\n\u0192 alertHeading() {\n  window.alert("This is a heading element.");\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"When we call on the name of a function without parens, we get the value of the function's definition returned to us. This is just like accessing a variable name to get its value:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"> let myAge = 55;\n> myAge;\n55\n"})}),"\n",(0,o.jsx)(n.p,{children:"So, when we want to set the value of an object property to a function declaration that we've already defined, we need to only use the name of the function:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"> h1.onclick = alertHeading;\n"})}),"\n",(0,o.jsx)(n.p,{children:"If this concept is unclear, try out the code in the DevTools console, and talk about it with a classmate or teacher."}),"\n",(0,o.jsx)(n.h2,{id:"using-function-declarations-with-event-listeners",children:"Using Function Declarations with Event Listeners"}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.p,{children:["The syntax to use a function declaration with an event listener is much the same as using one with an event handler property. In the following code snippets, we've updated the example ",(0,o.jsx)(n.code,{children:"onclick"})," event handler property to use an event listener instead. The first code snippet uses a function expression and the section code snippet uses a function declaration."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'// using a function expression\nlet h1 = document.querySelector("h1"); \nh1.addEventListener("click", function() {\n  window.alert("This is a heading element.");\n});\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'// using a function declaration\nlet h1 = document.querySelector("h1");\nfunction alertHeading() {\n  window.alert("This is a heading element.");\n}\nh1.addEventListener("click", alertHeading);\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Just like with the event handler property example, we pass in the name of the ",(0,o.jsx)(n.code,{children:"alertHeading"})," function that we are passing in as the second argument to the ",(0,o.jsx)(n.code,{children:"addEventListner()"}),' method call. Remember, a function that is passed in as the argument to another function or method is called a callback function. If you need a review of callback functions, revisit the "Event Handling with Event Listeners" lesson.']}),"\n",(0,o.jsx)(n.h2,{id:"when-would-i-use-a-function-declaration-in-an-event-handler",children:"When Would I Use a Function Declaration in an Event Handler?"}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.p,{children:"This is a great question. We prefer to reuse functionality by using function declarations or function expressions that are stored in variables, and we prefer to use function declarations because of hoisting. Let's look at an example for the first reason, and then cover the second."}),"\n",(0,o.jsx)(n.h3,{id:"writing-functions-so-they-are-reusable",children:"Writing Functions So They Are Reusable"}),"\n",(0,o.jsx)(n.p,{children:"To understand how functions can improve code reusability, let's expand on our example in this lesson. Now let's say we are coding an educational website that teaches students the names of different HTML elements. For our HTML, we'll list all heading elements H1 through H6:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-html",children:"<h1>Heading 1</h1>\n<h2>Heading 2</h2>\n<h3>Heading 3</h3>\n<h4>Heading 4</h4>\n<h5>Heading 5</h5>\n<h6>Heading 6</h6>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Now, anytime the user clicks on a heading element, we'll inform them ",(0,o.jsx)(n.code,{children:'"This is a heading element."'})," in an alert. With the event handling we've learned so far, our JS would need to have a click event handler set up for each element. This is what our code would look like using event listeners:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'let h1 = document.querySelector("h1"); \nlet h2 = document.querySelector("h2"); \nlet h3 = document.querySelector("h3"); \nlet h4 = document.querySelector("h4"); \nlet h5 = document.querySelector("h5"); \nlet h6 = document.querySelector("h6"); \n\nh1.addEventListener("click", function() {\n  window.alert("This is a heading element.");\n});\nh2.addEventListener("click", function() {\n  window.alert("This is a heading element.");\n});\nh3.addEventListener("click", function() {\n  window.alert("This is a heading element.");\n});\nh4.addEventListener("click", function() {\n  window.alert("This is a heading element.");\n});\nh5.addEventListener("click", function() {\n  window.alert("This is a heading element.");\n});\nh6.addEventListener("click", function() {\n  window.alert("This is a heading element.");\n});\n'})}),"\n",(0,o.jsx)(n.p,{children:"However, we can drastically reduce the amount of code by using a function declaration or a function expression stored in a variable. Let's see what this looks like with a function declaration:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'let h1 = document.querySelector("h1"); \nlet h2 = document.querySelector("h2"); \nlet h3 = document.querySelector("h3"); \nlet h4 = document.querySelector("h4"); \nlet h5 = document.querySelector("h5"); \nlet h6 = document.querySelector("h6"); \n\nfunction alertHeadings() {\n  window.alert("This is a heading element.");\n}\n\nh1.addEventListener("click", alertHeadings);\nh2.addEventListener("click", alertHeadings);\nh3.addEventListener("click", alertHeadings);\nh4.addEventListener("click", alertHeadings);\nh5.addEventListener("click", alertHeadings);\nh6.addEventListener("click", alertHeadings);\n'})}),"\n",(0,o.jsxs)(n.p,{children:["With this refactor, we've gone from 24 lines of code down to 15, which is a good sign that we've improved our code reusability. Instead of repeating the ",(0,o.jsx)(n.code,{children:'window.alert("This is a heading element.");'})," in six different function expressions, we've opted to create just one function declaration and reuse it for each of the headings. When thinking about how to optimize our code a good rule to follow is to look for repeated code and add it to a single function that you can then call in multiple places."]}),"\n",(0,o.jsx)(n.p,{children:"Now, which code snippet do you think is easier to read and understand? There's actually no right answer here. I would pick the second option because it's easier to pick out the function definition, and the event listeners are all on single lines, which is easier for me to scan."}),"\n",(0,o.jsx)(n.p,{children:"By the way, this code works the exact same when we store an anonymous function expression into a variable."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'let h1 = document.querySelector("h1"); \nlet h2 = document.querySelector("h2"); \nlet h3 = document.querySelector("h3"); \nlet h4 = document.querySelector("h4"); \nlet h5 = document.querySelector("h5"); \nlet h6 = document.querySelector("h6"); \n\nconst alertHeadings = function() {\n  window.alert("This is a heading element.");\n}\n\nh1.addEventListener("click", alertHeadings);\nh2.addEventListener("click", alertHeadings);\nh3.addEventListener("click", alertHeadings);\nh4.addEventListener("click", alertHeadings);\nh5.addEventListener("click", alertHeadings);\nh6.addEventListener("click", alertHeadings);\n'})}),"\n",(0,o.jsxs)(n.p,{children:["So why would we pick a function declaration over a function expression? Generally speaking, we prefer to use function declarations because that code is ",(0,o.jsx)(n.strong,{children:"hoisted"}),". We learned about hoisting in a previous lesson, but now is a good time to review."]}),"\n",(0,o.jsx)(n.h3,{id:"a-review-of-hoisting",children:"A Review of Hoisting"}),"\n",(0,o.jsxs)(n.p,{children:["JS interpreters (programs that interpret JS code, like Google Chrome's V8 JS engine) perform ",(0,o.jsx)(n.strong,{children:"hoisting"}),", which is the process of moving the declaration of functions and variables to the top of their scope, prior to execution of the code. Let's understand this with an example. Copy and paste this code into your DevTools console"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const result = add(3, 5);\nfunction add(number1, number2) {\n   return number1 + number2;\n}\nresult;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Take note that we've declared our ",(0,o.jsx)(n.code,{children:"add()"})," function with a function declaration, and we're calling the ",(0,o.jsx)(n.code,{children:"add()"})," function before we've defined it in our code. Should this code execute properly?"]}),"\n",(0,o.jsxs)(n.p,{children:["When we hit 'enter' the code executes without error and we should get ",(0,o.jsx)(n.code,{children:"8"}),". In this case we can call ",(0,o.jsx)(n.code,{children:"add()"})," before it has been defined because of ",(0,o.jsx)(n.strong,{children:"hoisting"}),". This only happens with function declarations."]}),"\n",(0,o.jsx)(n.p,{children:"Now refresh your page and your DevTools console and copy/paste this code and hit enter:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const result = add(3, 5);\nconst add = function(number1, number2) {\n   return number1 + number2;\n}\nresult;\n"})}),"\n",(0,o.jsx)(n.p,{children:"And what do we get? We get an error similar to this one:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"Uncaught ReferenceError: add is not defined\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The difference with the second code snippet is that we've defined our ",(0,o.jsx)(n.code,{children:"add()"})," function with a function expression, which does not get hoisted. Code gets red from top to bottom, and in this case when we call ",(0,o.jsx)(n.code,{children:"add(3,5)"}),", our JS interpreter can't find this function because it hasn't been hoisted and literally doesn't exist yet."]}),"\n",(0,o.jsx)(n.p,{children:"Because of hoisting, we generally recommend that you stick to using function declarations. However, you are welcome to use function expressions instead. Just remember the implications of hoisting!"}),"\n",(0,o.jsx)(n.h2,{id:"reusable-code-that-scales",children:"Reusable Code that Scales"}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.p,{children:['To write code that we can reuse, it\'s generally considered a good choice to set up event handlers to use function declarations or function expressions that are stored in variables. This code is considered scalable, because we can reuse those functions in multiple locations. The "scalability" of the code we write comes down to how quickly we can adapt our code to new requirements. In the previous example, we went from the requirement of alerting ',(0,o.jsx)(n.code,{children:'"This is a heading element."'})," for one H1 tag to all 6 heading tags. Even though this example is a bit simplistic, we can see how using functions declarations (or function expressions stored in a variable) impact how easily we can reuse code."]}),"\n",(0,o.jsx)(n.p,{children:"Note that when you are just starting out with JavaScript and writing interactive programs, any code that works is good! When you get to your independent project for this course section, we really want to see a working project that follows JavaScript best practices (indentation, spacing, syntax, semicolons, descriptive variable names), and continues to implement the best practices for HTML and CSS. The next step up is considering code reusability and organizing your code based on the goal of making it easy to read and understand. This is something that we'll work on over multiple course sections."}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.p,{children:"In this lesson, we learned how to use function declarations in event handling, both with event handler properties and event listeners. We also learned that it's encouraged to set up event handlers to use function declarations or function expressions that are stored in variables, because it makes our code reusable. You can choose to use either function declarations or function expressions in your event handlers, just remember the implication of hoisting."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);