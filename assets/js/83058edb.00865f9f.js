"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[5210],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var o=t(96540);const i={},r=o.createContext(i);function s(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:n},e.children)}},31923:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"introduction-to-programming/arrays-looping/1-3-2-9-drying-code-and-completing-the-text-analyzer-ui","title":"\ud83d\udcd3 1.3.2.9 DRYing Code and Completing the Text Analyzer UI","description":"In the last lesson, we focused on the importance of keeping our business logic and UI logic separate. We could\'ve updated our numberOfOccurrencesInText() function to do multiple things but this is a bad practice. A function should just do one thing if possible. We want to have separation of concerns, which means each function is concerned about just one thing and doesn\'t worry about anything else. That means numberOfOccurrencesInText() just cares about counting the number of occurrences of a substring in a string while boldPassage() should bold matches. Writing a function that did both things wouldn\'t be good even if it results in fewer lines of code.","source":"@site/versioned_docs/version-WIP/1_introduction-to-programming/3_arrays-looping/1-3-2-09-drying-code-and-completing-the-text-analyzer-ui.md","sourceDirName":"1_introduction-to-programming/3_arrays-looping","slug":"/introduction-to-programming/arrays-looping/1-3-2-9-drying-code-and-completing-the-text-analyzer-ui","permalink":"/WIP/introduction-to-programming/arrays-looping/1-3-2-9-drying-code-and-completing-the-text-analyzer-ui","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 1.3.2.9 DRYing Code and Completing the Text Analyzer UI","day":"tuesday","id":"1-3-2-9-drying-code-and-completing-the-text-analyzer-ui","hide_table_of_contents":true},"sidebar":"introduction-to-programming","previous":{"title":"\ud83d\udcd3 1.3.2.8 Separation of Concerns in Text Analyzer: boldPassage() UI Function","permalink":"/WIP/introduction-to-programming/arrays-looping/1-3-2-8-separation-of-concerns-in-text-analyzer-boldpassage-ui-function"},"next":{"title":"\u270f\ufe0f 1.3.2.10 Practice: Using TDD with Text Analyzer","permalink":"/WIP/introduction-to-programming/arrays-looping/1-3-2-10-practice-using-tdd-with-text-analyzer"}}');var i=t(74848),r=t(28453);const s={title:"\ud83d\udcd3 1.3.2.9 DRYing Code and Completing the Text Analyzer UI",day:"tuesday",id:"1-3-2-9-drying-code-and-completing-the-text-analyzer-ui",hide_table_of_contents:!0},a=void 0,c={},l=[{value:"Finding a Balance between DRY Code and Code that Is Separated by Concern",id:"finding-a-balance-between-dry-code-and-code-that-is-separated-by-concern",level:2},{value:"Completing our UI Logic",id:"completing-our-ui-logic",level:2}];function d(e){const n={a:"a",code:"code",div:"div",em:"em",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["In the last lesson, we focused on the importance of keeping our business logic and UI logic separate. We could've updated our ",(0,i.jsx)(n.code,{children:"numberOfOccurrencesInText()"})," function to do multiple things but this is a bad practice. A function should just do one thing if possible. We want to have ",(0,i.jsx)(n.strong,{children:"separation of concerns"}),", which means each function is concerned about just one thing and doesn't worry about anything else. That means ",(0,i.jsx)(n.code,{children:"numberOfOccurrencesInText()"})," just cares about counting the number of occurrences of a substring in a string while ",(0,i.jsx)(n.code,{children:"boldPassage()"})," should bold matches. Writing a function that did both things wouldn't be good even if it results in fewer lines of code."]}),"\n",(0,i.jsxs)(n.p,{children:["In this lesson, we're going to discuss another very important programming concept known as ",(0,i.jsx)(n.strong,{children:"DRY"}),", which means ",(0,i.jsx)(n.strong,{children:"Don't Repeat Yourself"}),". There are a lot of good reasons not to repeat yourself:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"It results in unnecessary repeated code."}),"\n",(0,i.jsx)(n.li,{children:"It's harder to read and reason about because there's extra repeated code to deal with and read."}),"\n",(0,i.jsx)(n.li,{children:"If the code breaks or it needs to be updated, we have to change it in multiple places, not just one."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["If you really practice separating concerns and keeping your code DRY, you are making a ",(0,i.jsx)(n.em,{children:"huge"})," step towards writing amazing code that clearly communicates your intentions. These are some of the most important techniques you can learn as a coder."]}),"\n",(0,i.jsx)(n.p,{children:"So, let's start by reviewing how DRY our Text Analyzer application is. We'll also discuss tradeoffs and considerations when writing code that's both DRY and separated by concerns. Then, we'll end this lesson by completing our UI logic."}),"\n",(0,i.jsx)(n.h2,{id:"finding-a-balance-between-dry-code-and-code-that-is-separated-by-concern",children:"Finding a Balance between DRY Code and Code that Is Separated by Concern"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["If we review our Text Analyzer scripts, we can find a fair amount of repetition. For example, our two business logic functions and the ",(0,i.jsx)(n.code,{children:"boldPassage()"})," UI function perform similar tasks:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Checking whether the ",(0,i.jsx)(n.code,{children:"word"})," or ",(0,i.jsx)(n.code,{children:"text"})," parameters are empty."]}),"\n",(0,i.jsx)(n.li,{children:"Splitting the text input into an array."}),"\n",(0,i.jsx)(n.li,{children:"Looping through each element of the text array to perform different actions on it."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["As you might guess, sometimes separating our code makes it harder not to repeat ourselves. If we'd just put this all in one function, it would be DRY but have poor separation of logic. With good separation of logic, though, it's not as DRY. ",(0,i.jsxs)(n.strong,{children:["Often, the best way to handle this is to ",(0,i.jsx)(n.em,{children:"extract"})," any repeated code into its own function."]})]}),"\n",(0,i.jsxs)(n.p,{children:["So, let's DRY up our code in a small way: we'll extract the first conditional we use to check whether the ",(0,i.jsx)(n.code,{children:"word"})," or ",(0,i.jsx)(n.code,{children:"text"})," parameters are empty into its own function."]}),"\n",(0,i.jsx)(n.p,{children:"First, let's put these functions next to each other. Notice how the conditionals are similar:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// Business Logic\n\nfunction wordCounter(text) {\n  if (text.trim().length === 0) {\n    return 0;\n  }\n  ...\n  return wordCount;\n}\n\nfunction numberOfOccurrencesInText(word, text) {\n  if (word.trim().length === 0) {\n    return 0;\n  }\n  ...\n  return wordCount;\n}\n\nfunction boldPassage(word, text) {\n  if ((text.trim().length === 0) || (word.trim().length === 0)) {\n    return null;\n  }\n  ...\n  return p;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"There's two main differences: what each conditional returns and the number of parameters we check. But this won't be a problem \u2014 we can easily accommodate these differences."}),"\n",(0,i.jsxs)(n.p,{children:["We'll extract the functionality of the conditional into its own function, and we will put this at the top of our file and call it ",(0,i.jsx)(n.em,{children:"Utility Logic"}),". You'll see the reason for the name later in this lesson."]}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"scripts.js"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// Utility Logic\n\nfunction isEmpty(testString) {\n  return (testString.trim().length === 0);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"isEmpty()"})," function returns a boolean. If any inputted string is empty, it will return ",(0,i.jsx)(n.code,{children:"true"}),". Otherwise, it will return ",(0,i.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Next, we can plug it into our functions. Here's how we do it:"}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"scripts.js"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// Business Logic\n\nfunction wordCounter(text) {\n  if (isEmpty(text)) {\n    return 0;\n  }\n  ...\n  return wordCount;\n}\n\nfunction numberOfOccurrencesInText(word, text) {\n  if (isEmpty(word)) {\n    return 0;\n  }\n  ...\n  return wordCount;\n}\n\nfunction boldPassage(word, text) {\n  if (isEmpty(word) || isEmpty(text)) {\n    return null;\n  }\n  ...\n  return p;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As we can see, instead of checking ",(0,i.jsx)(n.code,{children:"word.trim().length === 0"}),", our code now checks ",(0,i.jsx)(n.code,{children:"isEmpty(word)"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Hmm... doesn't seem like much of an improvement. Is it really worth it?"}),"\n",(0,i.jsxs)(n.p,{children:["Well, imagine if we were using that same code in ten different functions and we realized that we also wanted to account for punctuation. For instance, if someone enters the following: ",(0,i.jsx)(n.code,{children:'numberOfOccurrencesInText("!", ".");'}),", we want ",(0,i.jsx)(n.code,{children:"isEmpty()"})," to return ",(0,i.jsx)(n.code,{children:"false"}),", not ",(0,i.jsx)(n.code,{children:"true"}),". Would you rather update that code in one place (the ",(0,i.jsx)(n.code,{children:"isEmpty()"})," function) or in ten different functions? Also, what if in the process of updating the code in ten different places, you missed an eleventh place in the code that needed to be updated as well? These are the sort of scenarios that we need to think about when we're writing JavaScript."]}),"\n",(0,i.jsx)(n.p,{children:"In other situations you'll find that you're able to DRY up a much larger chunk of code. For instance, imagine that we have many different functions that all verify that every input is an actual English word. Imagine that this verification process involves a lot of different steps. Extracting this English-verifying functionality into a separate function that we can then call from any function that needs it makes a lot of sense."}),"\n",(0,i.jsxs)(n.p,{children:["So while refactoring our code to use the ",(0,i.jsx)(n.code,{children:"isEmpty()"})," function is a very small example of DRYing our code, it illustrates the basic principle of extracting repeated code into its own function."]}),"\n",(0,i.jsxs)(n.p,{children:["These kinds of functions are sometimes known as ",(0,i.jsx)(n.strong,{children:"helper"})," or ",(0,i.jsx)(n.strong,{children:"utility"})," functions. You should look for these kinds of opportunities to DRY up your code wherever possible. And again, while the example here is a very small one, it illustrates how we can keep our code DRY with helper functions while still keeping our business and user interface logic separate."]}),"\n",(0,i.jsx)(n.h2,{id:"completing-our-ui-logic",children:"Completing our UI Logic"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["There's one more thing we need to do to get our application working. We've written our ",(0,i.jsx)(n.code,{children:"boldPassage()"})," function but we aren't calling it yet. It needs to be called when the form is submitted, so we'll add it to the ",(0,i.jsx)(n.code,{children:"handleFormSubmission()"})," UI function:"]}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"scripts.js"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'...\n\nfunction handleFormSubmission() {\n  event.preventDefault();\n  const passage = document.getElementById("text-passage").value;\n  const word = document.getElementById("word").value;\n  const wordCount = wordCounter(passage);\n  const occurrencesOfWord = numberOfOccurrencesInText(word, passage);\n  document.getElementById("total-count").innerText = wordCount;\n  document.getElementById("selected-count").innerText = occurrencesOfWord;\n  // new lines here!\n  let boldedPassage = boldPassage(word, passage);\n  if (boldedPassage) {\n    document.querySelector("div#bolded-passage").append(boldedPassage);\n  } else {\n    document.querySelector("div#bolded-passage").innerText = null;\n  }\n}\n\nwindow.addEventListener("load", function() {\n  document.querySelector("form#word-counter").addEventListener("submit", handleFormSubmission);\n});\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Look how nice and clean that is! No logic cluttering up this section of the code at all. Instead, it's totally separated out. Even though ",(0,i.jsx)(n.code,{children:"boldPassage()"})," is a function that deals with UI logic, it doesn't directly alter the DOM. It just returns a paragraph element. That makes it easy to test and easy to separate out. Then we can just call the function when we need it, and then use ",(0,i.jsx)(n.code,{children:"Element.append()"})," to actually add it to the DOM."]}),"\n",(0,i.jsxs)(n.p,{children:["Notice that we only update the DOM if the ",(0,i.jsx)(n.code,{children:"boldedPassage"})," variable (the result from calling ",(0,i.jsx)(n.code,{children:"boldPassage()"}),") is truthy. If the ",(0,i.jsx)(n.code,{children:"boldedPassage"})," variable is ",(0,i.jsx)(n.code,{children:"null"})," or any other falsey value, the code in the else block will run, setting the contents of the div to ",(0,i.jsx)(n.code,{children:"null"}),", deleting anything inside of it including any HTML elements."]}),"\n",(0,i.jsx)(n.p,{children:"And with that, we've completely connected all of the logic for our Text Analyzer application. Hooray! Our code is nicely separated and we even added a little utility function to DRY things up a bit."}),"\n",(0,i.jsxs)(n.p,{children:["In a future lesson, we'll create a brand new function for our Text Analyzer application that uses a ",(0,i.jsx)(n.code,{children:"for"})," loop. We'll also use a ",(0,i.jsx)(n.code,{children:"for"})," loop when we explore JavaScript's ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments",children:"arguments object"})," to expand the capacity of the ",(0,i.jsx)(n.code,{children:"isEmpty()"})," function."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Visit the cheat sheet to see the completed scripts and HTML for the Text Analyzer application."})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);