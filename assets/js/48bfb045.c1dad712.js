"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[32796],{28453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>r});var s=t(96540);const i={},c=s.createContext(i);function d(e){const n=s.useContext(c);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),s.createElement(c.Provider,{value:n},e.children)}},45561:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>d,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"c-and-net/basic-web-applications/5-2-2-4-finding-objects-with-unique-ids","title":"\ud83d\udcd3 5.2.2.4 Finding Objects with Unique IDs","description":"We\'ll eventually want users to click an individual Item in our To Do List to view its details on a special detail page. To do this, our application needs to differentiate between Items. Otherwise, the server won\'t know which Item\'s details to display. That means we need to add a unique ID to our Item model. Then we can use routing to differentiate between Items like this: items/1 and items/2.","source":"@site/versioned_docs/version-WIP/c-and-net/2_basic-web-applications/3-2-2-04-finding-objects-with-unique-ids.md","sourceDirName":"c-and-net/2_basic-web-applications","slug":"/c-and-net/basic-web-applications/5-2-2-4-finding-objects-with-unique-ids","permalink":"/WIP/c-and-net/basic-web-applications/5-2-2-4-finding-objects-with-unique-ids","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 5.2.2.4 Finding Objects with Unique IDs","day":"tuesday","id":"5-2-2-4-finding-objects-with-unique-ids","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 5.2.2.3 Deleting Items","permalink":"/WIP/c-and-net/basic-web-applications/5-2-2-3-deleting-items"},"next":{"title":"\ud83d\udcd3 5.2.2.5 Introduction to RESTful Routing","permalink":"/WIP/c-and-net/basic-web-applications/5-2-2-5-introduction-to-restful-routing"}}');var i=t(74848),c=t(28453);const d={title:"\ud83d\udcd3 5.2.2.4 Finding Objects with Unique IDs",day:"tuesday",id:"5-2-2-4-finding-objects-with-unique-ids",hide_table_of_contents:!0},r=void 0,l={},o=[{value:"Assigning Unique IDs",id:"assigning-unique-ids",level:2},{value:"Testing",id:"testing",level:3},{value:"Implementing Unique IDs",id:"implementing-unique-ids",level:3},{value:"Finding Items By ID",id:"finding-items-by-id",level:2},{value:"Testing",id:"testing-1",level:3},{value:"Properly Failing the Test",id:"properly-failing-the-test",level:3},{value:"Implementing <code>Find()</code>",id:"implementing-find",level:3},{value:"Repository Reference",id:"repository-reference",level:3}];function a(e){const n={a:"a",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",hr:"hr",i:"i",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["We'll eventually want users to click an individual ",(0,i.jsx)(n.code,{children:"Item"})," in our To Do List to view its details on a special detail page. To do this, our application needs to differentiate between ",(0,i.jsx)(n.code,{children:"Item"}),"s. Otherwise, the server won't know ",(0,i.jsx)(n.em,{children:"which"})," ",(0,i.jsx)(n.code,{children:"Item"}),"'s details to display. That means we need to add a unique ID to our ",(0,i.jsx)(n.code,{children:"Item"})," model. Then we can use routing to differentiate between ",(0,i.jsx)(n.code,{children:"Item"}),"s like this: ",(0,i.jsx)(n.code,{children:"items/1"})," and ",(0,i.jsx)(n.code,{children:"items/2"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"assigning-unique-ids",children:"Assigning Unique IDs"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"testing",children:"Testing"}),"\n",(0,i.jsxs)(n.p,{children:["Because this requires updating our ",(0,i.jsx)(n.code,{children:"Item.cs"})," model logic, we'll need to add a test."]}),"\n",(0,i.jsxs)(n.p,{children:["First, however, let's run our previous tests by navigating to the test directory and running ",(0,i.jsx)(n.code,{children:"dotnet test"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["All 5 should pass, but if there are errors, try running ",(0,i.jsx)(n.code,{children:"dotnet restore"})," in the test directory."]}),"\n",(0,i.jsx)(n.p,{children:"Let's add our new test:"}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"ToDoList.Tests/ModelTests/ItemTests.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'...\n\n  [TestMethod]\n  public void GetId_ItemsInstantiateWithAnIdAndGetterReturns_Int()\n  {\n    //Arrange\n    string description = "Walk the dog.";\n    Item newItem = new Item(description);\n\n    //Act\n    int result = newItem.Id;\n\n    //Assert\n    Assert.AreEqual(1, result);\n  }\n\n...\n'})}),"\n",(0,i.jsx)(n.p,{children:"Our new test:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Arranges the necessary materials by creating a sample ",(0,i.jsx)(n.code,{children:"Item"}),";"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Calls a new ",(0,i.jsx)(n.code,{children:"Id"})," property from the ",(0,i.jsx)(n.code,{children:"Item"}),";"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Asserts that ",(0,i.jsx)(n.code,{children:"Id"})," returns the ",(0,i.jsx)(n.code,{children:"int"})," ",(0,i.jsx)(n.code,{children:"1"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"implementing-unique-ids",children:"Implementing Unique IDs"}),"\n",(0,i.jsxs)(n.p,{children:["Because our new test references an ",(0,i.jsx)(n.code,{children:"Id"})," property that doesn't exist yet, we won't be able to run our tests. In order to get around this and see our test fail, however, let's temporarily change the 'Act' portion of our test to this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"int result = 0;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Now we should be able to see our test fail properly."}),"\n",(0,i.jsxs)(n.p,{children:["Let's change the value of the ",(0,i.jsx)(n.code,{children:"result"})," variable in the test back to ",(0,i.jsx)(n.code,{children:"newItem.Id"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"int result = newItem.Id;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Let's also add our logic to make this test pass. We'll begin by updating our ",(0,i.jsx)(n.code,{children:"Item"})," class to contain a new ",(0,i.jsx)(n.code,{children:"Id"})," property:"]}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"ToDoList/Models/Item.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"...\npublic class Item\n{\n  public string Description { get; set; }\n  public int Id { get; }\n  private static List<Item> _instances = new List<Item> {};\n\n...\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then we'll set this property in the constructor:"}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"ToDoList/Models/Item.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"...\n\n    public Item(string description)\n    {\n      Description = description;\n      _instances.Add(this);\n      Id = _instances.Count;\n    }\n\n    ...\n  ...\n...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This assigns an ",(0,i.jsx)(n.code,{children:"Item"}),"'s ",(0,i.jsx)(n.code,{children:"Id"})," to the current number of ",(0,i.jsx)(n.code,{children:"Item"}),"s in the static ",(0,i.jsx)(n.code,{children:"_instances"})," list. After the first ",(0,i.jsx)(n.code,{children:"Item"})," is added, ",(0,i.jsx)(n.code,{children:"_instances.Count"})," will be ",(0,i.jsx)(n.code,{children:"1"}),". After the second ",(0,i.jsx)(n.code,{children:"Item"}),", it'll be ",(0,i.jsx)(n.code,{children:"2"}),", and so on. Using ",(0,i.jsx)(n.code,{children:"_instances.Count"})," to assign ",(0,i.jsx)(n.code,{children:"Id"}),"  ensures each is always unique. Note that we do this ",(0,i.jsx)(n.em,{children:"after"})," adding ",(0,i.jsx)(n.code,{children:"Item"}),"s to the ",(0,i.jsx)(n.code,{children:"_instances"})," list in order to get an updated ",(0,i.jsx)(n.code,{children:"Count"})," for ",(0,i.jsx)(n.code,{children:"Id"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["One more thing: Remember that when we are working inside an object, we can use the keyword ",(0,i.jsx)(n.code,{children:"this"})," to reference that object. In the code above, we use ",(0,i.jsx)(n.code,{children:"this"})," to reference the ",(0,i.jsx)(n.code,{children:"Item"})," being actively constructed by the constructor."]}),"\n",(0,i.jsxs)(n.p,{children:["We don't add a set method, because this property will be set in the constructor automatically. In fact, we specifically ",(0,i.jsx)(n.em,{children:"don't"})," ever want to manually edit it. That would increase the risk of IDs not being unique."]}),"\n",(0,i.jsxs)(n.p,{children:["This is called creating a ",(0,i.jsx)(n.strong,{children:"readonly"})," property. In other words, it's a property that can be read but not overwritten."]}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"ToDoList/Models/Item.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"...\n\n    public int Id { get; }\n\n...\n"})}),"\n",(0,i.jsx)(n.p,{children:"If we run our tests again, they'll all pass."}),"\n",(0,i.jsx)(n.h2,{id:"finding-items-by-id",children:"Finding Items By ID"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["Next, we'll need to locate specific ",(0,i.jsx)(n.code,{children:"Item"}),"s based on their new unique ",(0,i.jsx)(n.code,{children:"Id"}),"s. This will help our server populate our eventual ",(0,i.jsx)(n.code,{children:"Item"})," detail pages with the correct object's information."]}),"\n",(0,i.jsx)(n.h3,{id:"testing-1",children:"Testing"}),"\n",(0,i.jsx)(n.p,{children:"Let's write a test for this functionality:"}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"ToDoList.Tests/ModelTests/ItemTests.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'...\n\n  [TestMethod]\n  public void Find_ReturnsCorrectItem_Item()\n  {\n    //Arrange\n    string description01 = "Walk the dog";\n    string description02 = "Wash the dishes";\n    Item newItem1 = new Item(description01);\n    Item newItem2 = new Item(description02);\n\n    //Act\n    Item result = Item.Find(2);\n\n    //Assert\n    Assert.AreEqual(newItem2, result);\n  }\n\n...\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["This test arranges multiple sample ",(0,i.jsx)(n.code,{children:"Item"})," objects."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["It then calls a static ",(0,i.jsx)(n.code,{children:"Find()"})," method, passing in the int ",(0,i.jsx)(n.code,{children:"2"})," as an argument because this is the anticipated ",(0,i.jsx)(n.code,{children:"Id"})," property of the second ",(0,i.jsx)(n.code,{children:"Item"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["We then assert that ",(0,i.jsx)(n.code,{children:"Find()"})," will return ",(0,i.jsx)(n.code,{children:"newItem2"})," when provided the argument ",(0,i.jsx)(n.code,{children:"2"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"properly-failing-the-test",children:"Properly Failing the Test"}),"\n",(0,i.jsxs)(n.p,{children:["Similar to when we added our last test, we won't be able to compile and run our test suite because we are referencing a method that doesn't yet exist. In order to properly fail this test, we'll have to set the value of ",(0,i.jsx)(n.code,{children:"result"})," to a different ",(0,i.jsx)(n.code,{children:"Item"}),". Normally, we could just set the value of ",(0,i.jsx)(n.code,{children:"result"})," to ",(0,i.jsx)(n.code,{children:"0"}),", but this time, because ",(0,i.jsx)(n.code,{children:"result"})," is of type ",(0,i.jsx)(n.code,{children:"Item"}),", we'll set it to a new ",(0,i.jsx)(n.code,{children:"Item"})," we know will give us a proper failure."]}),"\n",(0,i.jsx)(n.p,{children:"Let's do that now:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'...\n  //Act\n  Item result = new Item("Incorrect test item");\n...\n'})}),"\n",(0,i.jsxs)(n.p,{children:["If we run ",(0,i.jsx)(n.code,{children:"dotnet test"})," we can now see that our test is failing as expected. Let's now reset the value of ",(0,i.jsx)(n.code,{children:"result"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"...\n  //Act\n  Item result = Item.Find(2);\n...\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"implementing-find",children:["Implementing ",(0,i.jsx)(n.code,{children:"Find()"})]}),"\n",(0,i.jsxs)(n.p,{children:["Let's add logic for our new static ",(0,i.jsx)(n.code,{children:"Find()"})," method:"]}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"ToDoList/Models/Item.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"...\n\n    public static Item Find(int searchId)\n    {\n      return _instances[searchId-1];\n    }\n\n...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We create a ",(0,i.jsx)(n.code,{children:"static"})," method to locate an ",(0,i.jsx)(n.code,{children:"Item"})," using its ",(0,i.jsx)(n.code,{children:"Id"}),". It's static because it must sift through ",(0,i.jsx)(n.em,{children:"all"})," ",(0,i.jsx)(n.code,{children:"Item"}),"s to find the one we're seeking. And because it's static, we must call it on the entire ",(0,i.jsx)(n.code,{children:"Item"})," class, as seen in the test above."]}),"\n",(0,i.jsxs)(n.p,{children:["Also, notice we subtract ",(0,i.jsx)(n.code,{children:"1"})," from the provided ",(0,i.jsx)(n.code,{children:"searchId"})," because indexes in the ",(0,i.jsx)(n.code,{children:"_instances"})," array begin at ",(0,i.jsx)(n.code,{children:"0"}),", whereas our ",(0,i.jsx)(n.code,{children:"Id"})," properties will begin at ",(0,i.jsx)(n.code,{children:"1"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The entire updated ",(0,i.jsx)(n.code,{children:"Item.cs"})," model file looks like this:"]}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"ToDoList/Models/Item.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"using System.Collections.Generic;\n\nnamespace ToDoList.Models\n{\n    public class Item\n    {\n        public string Description { get; set; }\n        public int Id { get; }\n        private static List<Item> _instances = new List<Item> { };\n\n        public Item(string description)\n        {\n            Description = description;\n            _instances.Add(this);\n            Id = _instances.Count;\n        }\n\n        public static List<Item> GetAll()\n        {\n            return _instances;\n        }\n\n        public static void ClearAll()\n        {\n            _instances.Clear();\n        }\n\n        public static Item Find(int searchId)\n        {\n            return _instances[searchId - 1];\n        }\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Try running tests and verify that they pass. We can now automatically assign each ",(0,i.jsx)(n.code,{children:"Item"})," a guaranteed unique ",(0,i.jsx)(n.code,{children:"Id"})," that can be used to locate specific objects. In the next few lessons, we'll add functionality for ",(0,i.jsx)(n.code,{children:"Item"})," detail pages to our app."]}),"\n",(0,i.jsx)(n.h3,{id:"repository-reference",children:"Repository Reference"}),"\n",(0,i.jsx)(n.p,{children:"Follow the link below to view how a sample version of the project should look at this point. Note that this is a link to a specific branch in the repository."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsxs)(n.a,{href:"https://github.com/epicodus-lessons/section-2-to-do-list-csharp-net6/tree/5_deleting_and_finding_objects",children:[(0,i.jsx)(n.i,{className:"glyphicon glyphicon-folder-open"})," Example GitHub Repo for To Do List: 5_deleting_and_finding_objects"]})})})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}}}]);