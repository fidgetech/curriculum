"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[55546],{8887:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"c-and-net/lessons-6-18-data-types-and-variables/5-0-0-08-integers-decimals-and-arithmetic","title":"\ud83d\udcd3 5.0.0.08 Integers, Decimals, and Arithmetic","description":"Let\u2019s look at the data types that represent numbers: integers, longs,  floats, and doubles. Between these four data types, C# covers whole and decimal numbers, as well as numbers with many digits and fewer digits. As we\'ll see, C# numbers are very similar to JavaScript numbers; the main difference is that JavaScript has fewer data types that represent numbers than in C#.","source":"@site/versioned_docs/version-WIP/c-and-net/0_lessons-6-18-data-types-and-variables/3-0-0-08-integers-decimals-and-arithmetic.md","sourceDirName":"c-and-net/0_lessons-6-18-data-types-and-variables","slug":"/c-and-net/lessons-6-18-data-types-and-variables/5-0-0-08-integers-decimals-and-arithmetic","permalink":"/WIP/c-and-net/lessons-6-18-data-types-and-variables/5-0-0-08-integers-decimals-and-arithmetic","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 5.0.0.08 Integers, Decimals, and Arithmetic","day":"weekend","id":"5-0-0-08-integers-decimals-and-arithmetic","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 5.0.0.07 Strings, String Concatenation and Interpolation, and Chars","permalink":"/WIP/c-and-net/lessons-6-18-data-types-and-variables/5-0-0-07-strings-string-concatenation-and-interpolation-and-chars"},"next":{"title":"\ud83d\udcd3 5.0.0.09 Variables","permalink":"/WIP/c-and-net/lessons-6-18-data-types-and-variables/5-0-0-09-variables"}}');var t=s(74848),r=s(28453);const i={title:"\ud83d\udcd3 5.0.0.08 Integers, Decimals, and Arithmetic",day:"weekend",id:"5-0-0-08-integers-decimals-and-arithmetic",hide_table_of_contents:!0},l=void 0,o={},d=[{value:"Integers and Longs",id:"integers-and-longs",level:2},{value:"Assigning Integers to Variables",id:"assigning-integers-to-variables",level:3},{value:"Choosing the Right Data Type: <code>int</code> or <code>long</code>",id:"choosing-the-right-data-type-int-or-long",level:3},{value:"Floats and Doubles",id:"floats-and-doubles",level:2},{value:"Assigning Floating-Point Numbers to Variables",id:"assigning-floating-point-numbers-to-variables",level:3},{value:"Choosing the Right Data Type: <code>float</code> or <code>double</code>",id:"choosing-the-right-data-type-float-or-double",level:3},{value:"Arithmetic Operators",id:"arithmetic-operators",level:2}];function c(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Let\u2019s look at the data types that represent numbers: integers, longs,  floats, and doubles. Between these four data types, C# covers whole and decimal numbers, as well as numbers with many digits and fewer digits. As we'll see, C# numbers are very similar to JavaScript numbers; the main difference is that JavaScript has fewer data types that represent numbers than in C#."}),"\n",(0,t.jsxs)(n.p,{children:["We'll practice working with C# number types in the REPL. Start by opening your REPL with the ",(0,t.jsx)(n.code,{children:"$ dotnet-script"})," command in the Terminal (for Mac) or GitBash (for Windows)."]}),"\n",(0,t.jsx)(n.h2,{id:"integers-and-longs",children:"Integers and Longs"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:["Both integers and longs represent whole numbers, that is, numbers without decimals. ",(0,t.jsx)(n.strong,{children:"Integers"})," are meant to hold smaller numbers between -2,147,483,648 and 2,147,483,647. ",(0,t.jsx)(n.strong,{children:"Longs"})," are meant to hold larger numbers between -9,223,372,036,854,775,808 and 9,223,372,036,854,775,807."]}),"\n",(0,t.jsx)(n.p,{children:"We can create a new integer like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> 1\n1\n"})}),"\n",(0,t.jsx)(n.p,{children:"Or a new long like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> 9222222222222222\n9222222222222222\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Easy enough! But do notice this is ",(0,t.jsx)(n.em,{children:"very"})," different than:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'> "1"\n"1"\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The second example is a string ",(0,t.jsx)(n.em,{children:"containing"})," an integer. Strings are the ",(0,t.jsx)(n.strong,{children:"only"})," type of data wrapped in quotation marks. If we put quotation marks around a number, it's actually a string... and will act as such!"]}),"\n",(0,t.jsx)(n.p,{children:"For instance, check out what happens when we add two numbers wrapped in quotations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'> "1" + "1"\n"11"\n'})}),"\n",(0,t.jsxs)(n.p,{children:["1 + 1 isn't 11! But we receive this result because the REPL is actually concatenating two ",(0,t.jsx)(n.em,{children:"strings"})," containing the character ",(0,t.jsx)(n.code,{children:"1"})," together. You likely already recognize this type of error from JavaScript but it's so common it's worth mentioning again!"]}),"\n",(0,t.jsx)(n.p,{children:"We can avoid this erroneous math by avoiding quotation marks and ensuring numerical values are integers like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> 1 + 1\n2\n"})}),"\n",(0,t.jsx)(n.p,{children:"That's more like it!"}),"\n",(0,t.jsx)(n.h3,{id:"assigning-integers-to-variables",children:"Assigning Integers to Variables"}),"\n",(0,t.jsxs)(n.p,{children:["Finally, we can store integers in a variable by declaring it of the type ",(0,t.jsx)(n.code,{children:"int"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> int myAge = 45;\n> myAge\n45\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We can store longs in a variable by declaring it of the type ",(0,t.jsx)(n.code,{children:"long"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> long superBigNumber = 9222222222222222;\n> superBigNumber\n9222222222222222\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"choosing-the-right-data-type-int-or-long",children:["Choosing the Right Data Type: ",(0,t.jsx)(n.code,{children:"int"})," or ",(0,t.jsx)(n.code,{children:"long"})]}),"\n",(0,t.jsx)(n.p,{children:"So what happens if we store a long in an int?"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> int superBigNumber = 9222222222222222;\n"})}),"\n",(0,t.jsx)(n.p,{children:"We'll actually get a helpful error message:"}),"\n",(0,t.jsx)(n.p,{children:"<code style={{color:\"red\"}}>\n(1,22): error CS0266: Cannot implicitly convert type 'long' to 'int'. An explicit conversion exists (are you missing a cast?)\n"}),"\n",(0,t.jsxs)(n.p,{children:["This error message lets us know that we can't store a ",(0,t.jsx)(n.code,{children:"long"})," number into a variable that's declared for an ",(0,t.jsx)(n.code,{children:"int"})," type. We either need to update our variable's data type to ",(0,t.jsx)(n.code,{children:"long"}),', or convert one data type into another. Data type conversion is also called "type casting", and we\'ll learn about it a bit later on.']}),"\n",(0,t.jsx)(n.p,{children:"So what happens if we store a small number in a long?"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> long aNumber = 2;\n> aNumber\n2\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This will work as expected! In this case, the ",(0,t.jsx)(n.code,{children:"aNumber"})," variable is of the type ",(0,t.jsx)(n.code,{children:"long"}),", so it can hold a very large number at any point. For example, we could update the ",(0,t.jsx)(n.code,{children:"aNumber"})," variable to hold a very large number:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> aNumber = 9222222222222222;\n> aNumber\n9222222222222222\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Generally we shouldn't use a ",(0,t.jsx)(n.code,{children:"long"})," data type for small numbers that could be declared as ",(0,t.jsx)(n.code,{children:"int"}),". That's because ",(0,t.jsx)(n.code,{children:"long"})," takes up more space in memory than ",(0,t.jsx)(n.code,{children:"int"})," does, and we should be mindful of conversing memory in simple cases like these."]}),"\n",(0,t.jsxs)(n.p,{children:["In the example projects for this course, we'll primarily use the ",(0,t.jsx)(n.code,{children:"int"})," data type because we won't be working with long whole numbers. However, if you know that you are dealing with very large numbers in a project you create, you should be mindful to investigate whether or not it's best to use the ",(0,t.jsx)(n.code,{children:"long"})," data type."]}),"\n",(0,t.jsx)(n.h2,{id:"floats-and-doubles",children:"Floats and Doubles"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:["The float and double data types represent decimal numbers like 3.14  or 9.2342342342342. ",(0,t.jsx)(n.strong,{children:"Floats"})," are meant to hold numbers with a smaller number of decimals, about 6 to 9 digits. ",(0,t.jsx)(n.strong,{children:"Doubles"})," are meant to hold numbers with a larger amount of decimals, about 15 to 17 digits. Collectively, numbers with a decimal point are referred to as ",(0,t.jsx)(n.strong,{children:"floating-point numbers"})," in computer programming."]}),"\n",(0,t.jsx)(n.p,{children:"We can create a new double like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> 9.2342342342342\n9.2342342342342\n"})}),"\n",(0,t.jsx)(n.p,{children:"Or a new float like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> 3.14F\n3.14\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Notice that we add the suffix ",(0,t.jsx)(n.code,{children:"F"})," to our number to declare it as a float. We need to do this, otherwise the number ",(0,t.jsx)(n.code,{children:"3.14"})," will be declared as a double. That's because ",(0,t.jsx)(n.strong,{children:"C# performs an implicit conversion of all floats to doubles"}),". If we want to make sure that this implicit conversion does not happen, we need to include the suffix ",(0,t.jsx)(n.code,{children:"F"})," or ",(0,t.jsx)(n.code,{children:"f"})," at the end of the number we want to declare as a ",(0,t.jsx)(n.code,{children:"float"}),", as in ",(0,t.jsx)(n.code,{children:"3.14F"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["There's also a suffix for numbers that we want to declare as a double that we can use as needed, which is ",(0,t.jsx)(n.code,{children:"D"})," or ",(0,t.jsx)(n.code,{children:"d"}),". To summarize, all of the following examples creates a double:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> 9.2342342342342\n9.2342342342342\n> 3.14\n3.14\n> 0.124123123123D\n0.124123123123\n"})}),"\n",(0,t.jsx)(n.h3,{id:"assigning-floating-point-numbers-to-variables",children:"Assigning Floating-Point Numbers to Variables"}),"\n",(0,t.jsxs)(n.p,{children:["We can store doubles in a variable by declaring our variable of the ",(0,t.jsx)(n.code,{children:"double"})," data type:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> double aLongDecimal = 9.2342342342342;\n> aLongDecimal\n9.2342342342342\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We can store floats in a variable by declaring our variable of the ",(0,t.jsx)(n.code,{children:"float"})," data type:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> float pi = 3.14F;\n> pi\n3.14\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Notice that we need to include an ",(0,t.jsx)(n.code,{children:"F"})," suffix at the end of the decimal number that we're declaring as a float: ",(0,t.jsx)(n.code,{children:"3.14F"}),". If we don't include the ",(0,t.jsx)(n.code,{children:"F"}),", we'll get an error:"]}),"\n",(0,t.jsx)(n.p,{children:"<code style={{color:\"red\"}}>\n(1,12): error CS0664: Literal of type double cannot be implicitly converted to type 'float'; use an 'F' suffix to create a literal of this type\n"}),"\n",(0,t.jsxs)(n.p,{children:["Again, this is because C# performs an implicit conversion of all floats to doubles. If we want to make sure that this implicit conversion does not happen, we need to include the suffix ",(0,t.jsx)(n.code,{children:"F"})," or ",(0,t.jsx)(n.code,{children:"f"})," at the end of the number we want to declare as a ",(0,t.jsx)(n.code,{children:"float"}),", as in ",(0,t.jsx)(n.code,{children:"3.14F"}),"."]}),"\n",(0,t.jsxs)(n.h3,{id:"choosing-the-right-data-type-float-or-double",children:["Choosing the Right Data Type: ",(0,t.jsx)(n.code,{children:"float"})," or ",(0,t.jsx)(n.code,{children:"double"})]}),"\n",(0,t.jsxs)(n.p,{children:["If we choose the wrong data type between ",(0,t.jsx)(n.code,{children:"float"})," and ",(0,t.jsx)(n.code,{children:"double"}),", we're at risk of losing data and we won't get an error message about it."]}),"\n",(0,t.jsxs)(n.p,{children:["Take this for example, where we store a very long decimal into a variable called ",(0,t.jsx)(n.code,{children:"testNum"})," declared as the ",(0,t.jsx)(n.code,{children:"float"})," type:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> float testNum = 9.2342342342342F;\n> testNum\n9.234234\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Notice that our decimal number got shortened! From ",(0,t.jsx)(n.code,{children:"9.2342342342342"})," to ",(0,t.jsx)(n.code,{children:"9.234234"}),". Well, this is what happens in C# if we don't pick the right data type for floating point numbers."]}),"\n",(0,t.jsxs)(n.p,{children:["Now, if we save a number with a small amount of decimals to a variable that's declared as a ",(0,t.jsx)(n.code,{children:"double"}),", we'd simply be taking up more space in memory. Something like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> double testNum2 = 9.1;\n> testNum2\n9.1\n"})}),"\n",(0,t.jsxs)(n.p,{children:["However, this is the right choice if we plan to later update our ",(0,t.jsx)(n.code,{children:"testNum2"})," variable to a new number that has many decimals:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> testNum2 = 16.11231231222312;\n> testNum2\n16.11231231222312\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We won't work often with decimals in the example projects in this course. However, you'll likely find use cases for ",(0,t.jsx)(n.code,{children:"float"})," and ",(0,t.jsx)(n.code,{children:"double"})," in your own practice projects that you create."]}),"\n",(0,t.jsx)(n.h2,{id:"arithmetic-operators",children:"Arithmetic Operators"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:["The five ",(0,t.jsx)(n.strong,{children:"arithmetic operators"})," we used in JavaScript work the same in C#. You should recall these basic operators:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"+"})," for addition, as seen in the example above."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"-"})," for subtraction."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"*"})," for multiplication."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"/"})," for division."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"%"})," for modulo, which gives us the remainder of dividing two numbers."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["We can use each with integers in the REPL and receive expected results. Note that the following examples use whole numbers of the ",(0,t.jsx)(n.code,{children:"int"})," type, but they will work the same with floating point numbers."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Subtraction"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> 1 - 1\n0\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Addition:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> 1 + 1\n2\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Multiplication:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> 2 * 2\n4\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Division:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> 4 / 2\n2\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Modulo:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"> 5 % 2\n1\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Remember that a ",(0,t.jsx)(n.strong,{children:"modulo"})," gives us the remainder of dividing two numbers and it has nothing to do with percentages!"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>l});var a=s(96540);const t={},r=a.createContext(t);function i(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);