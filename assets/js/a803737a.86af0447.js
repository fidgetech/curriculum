"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[38081],{4248:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-3-4-es6-maps-and-sets","title":"\ud83d\udcd3 2.2.3.4 ES6 Maps and Sets","description":"In this lesson, we\'ll cover two more useful features of ES6: Maps and Sets. ES6 also introduced the WeakMap and WeakSet but these two data structures are more obscure and not as widely useful so we won\'t cover them here. You won\'t be required to utilize either Maps or Sets for this section\'s independent project but you are encouraged to explore them in class.","source":"@site/docs/2_intermediate-javascript/2_test-driven-development-and-environments-with-javascript/2-2-3-04-es6-maps-and-sets.md","sourceDirName":"2_intermediate-javascript/2_test-driven-development-and-environments-with-javascript","slug":"/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-3-4-es6-maps-and-sets","permalink":"/v1.2/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-3-4-es6-maps-and-sets","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 2.2.3.4 ES6 Maps and Sets","day":"wednesday","id":"2-2-3-4-es6-maps-and-sets","hide_table_of_contents":true},"sidebar":"intermediate-javascript","previous":{"title":"\ud83d\udcd3 2.2.3.3 ES6 Array and Object Destructuring","permalink":"/v1.2/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-3-3-es6-array-and-object-destructuring"},"next":{"title":"\u270f\ufe0f 2.2.4.1 Haiku Creator, RPG, Sudoku Solver (Longer Project) - Part 2 (day 2)","permalink":"/v1.2/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-4-1-haiku-creator-rpg-sudoku-solver-longer-project---part-2-day-2"}}');var a=t(74848),r=t(28453);const o={title:"\ud83d\udcd3 2.2.3.4 ES6 Maps and Sets",day:"wednesday",id:"2-2-3-4-es6-maps-and-sets",hide_table_of_contents:!0},i=void 0,l={},c=[{value:"Maps",id:"maps",level:2},{value:"Sets",id:"sets",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["In this lesson, we'll cover two more useful features of ES6: ",(0,a.jsx)(n.strong,{children:"Maps"})," and ",(0,a.jsx)(n.strong,{children:"Sets"}),". ES6 also introduced the ",(0,a.jsx)(n.strong,{children:"WeakMap"})," and ",(0,a.jsx)(n.strong,{children:"WeakSet"})," but these two data structures are more obscure and not as widely useful so we won't cover them here. You won't be required to utilize either Maps or Sets for this section's independent project but you are encouraged to explore them in class."]}),"\n",(0,a.jsx)(n.h2,{id:"maps",children:"Maps"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:"We'll often want to map specific keys to values. In fact, we've done this quite a bit so far with objects. For instance, let's say we're making a game where we're exploring a dungeon. Each room should have a specific key corresponding to a door number. The value associated with each key should be a description of the room."}),"\n",(0,a.jsx)(n.p,{children:"Here's an example using a basic object:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const dungeon = {\n  1: "The room is dark and has no windows.",\n  2: "There are spiderwebs everywhere.",\n  3: "There is a book on a stone pedestal. The book appears to be glowing."\n};\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This object is being used to map specific keys to specific values. If a user enters door #3, for example, we'd want them to get the corresponding description ",(0,a.jsx)(n.code,{children:'"There is a book on a stone pedestal. The book appears to be glowing."'}),"."]}),"\n",(0,a.jsx)(n.p,{children:"In this situation, we could use a Map instead of an object literal. A Map is just a special kind of object that also maps keys to values. There are several similarities between a Map and a basic object but a Map has a few key advantages:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"The insertion order of key-values is preserved in a Map. This isn't the case for a basic object."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Maps have a ",(0,a.jsx)(n.code,{children:"size"})," property so we can easily see how many key-value pairs they're holding. A basic object doesn't have this functionality."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Maps have convenient utility methods such as ",(0,a.jsx)(n.code,{children:"Map.prototype.clear()"})," which basic objects don't have."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Maps are iterable while basic objects are not. With a basic object, we need to first grab the keys and use these to iterate through the object."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Maps can have any data type as a key while objects can only have strings or symbols as keys."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["For this last one, you may be wondering how we were able to create the basic ",(0,a.jsx)(n.code,{children:"dungeon"})," object above. Doesn't it have integers as keys? Actually, no. Let's check out the type of the first object key in the DevTools console:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"> typeof Object.keys(dungeon)[0];\nString\n"})}),"\n",(0,a.jsx)(n.p,{children:"When we do this, we'll see that the key is actually a string, not an integer."}),"\n",(0,a.jsx)(n.p,{children:"At this point, it should be clear that there are quite a few benefits to using Maps."}),"\n",(0,a.jsx)(n.p,{children:"So how can we implement one using the dungeon example above?"}),"\n",(0,a.jsx)(n.p,{children:"Well, we can instantiate a map with values like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'let dungeon = new Map(\n  [\n    [1, "The room is dark and has no windows."],\n    [2, "There are spiderwebs everywhere."],\n    [3, "There is a book on a stone pedestal. The book appears to be glowing."]\n  ]\n);\n'})}),"\n",(0,a.jsx)(n.p,{children:"As we can see, we instantiate key values inside a map by creating an array of arrays. The outer array holds all the key-value pairs. Each inner array holds a single key-value pair separated by a comma. The key is the first element of the array and the value is the second."}),"\n",(0,a.jsx)(n.p,{children:"If we want to just instantiate an empty map, we can do that, too:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"let map = new Map();\n"})}),"\n",(0,a.jsx)(n.p,{children:"Now let's return to the dungeon we're building. Here's how we can add another room to our Map:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'dungeon.set(4, "The room is full of sleeping bats.");\n'})}),"\n",(0,a.jsxs)(n.p,{children:["We use the ",(0,a.jsx)(n.code,{children:"Map.prototype.set()"})," method to add key-value pairs to a map. The method takes two arguments: the first is the key, the second is the value."]}),"\n",(0,a.jsx)(n.p,{children:"To delete a room, we just need to specify the key:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"dungeon.delete(4);\n"})}),"\n",(0,a.jsx)(n.p,{children:"We can check to see if the dungeon has a specific room:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"dungeon.has(12);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This will return ",(0,a.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"We can also get the value associated with a key:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"dungeon.get(3);\n"})}),"\n",(0,a.jsx)(n.p,{children:"This will return the associated value, which is:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'"There is a book on a stone pedestal. The book appears to be glowing."\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Note that if a value doesn't exist in a Map, the return will be ",(0,a.jsx)(n.code,{children:"undefined"}),". Sometimes it will be a good idea to call ",(0,a.jsx)(n.code,{children:"Map.prototype.has()"})," before looking for a value just in case."]}),"\n",(0,a.jsxs)(n.p,{children:["Finally, we can iterate directly over a Map, unlike with an object. For instance, there's ",(0,a.jsx)(n.code,{children:"Map.prototype.forEach()"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"dungeon.forEach(function(value, key) {\n  console.log(value, key);\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:"Note that the first argument corresponds to the values in the Map while the second (optional) argument corresponds to the keys. We could rewrite the above with different parameters:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"dungeon.forEach(function(description, roomNumber) {\n  console.log(description, roomNumber);\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:"The result will be the same because the first argument still relates to values while the second relates to keys."}),"\n",(0,a.jsxs)(n.p,{children:["Check out the ",(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",children:"Mozilla documentation on Map"})," for more information. Here are a few things from the documentation you might want to look over:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Iterating over a Map with a ",(0,a.jsx)(n.code,{children:"for...of"})," loop."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Map.prototype.keys()"}),", ",(0,a.jsx)(n.code,{children:"Map.prototype.values()"}),", and ",(0,a.jsx)(n.code,{children:"Map.prototype.entries()"})," methods, which are all iterable and specifically allow you to iterate over keys, values, and entries (which return both keys and values) respectively."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"You won't be expected to use Maps on this section's independent project. However, we still recommend practicing with them and using them in your code when applicable."}),"\n",(0,a.jsx)(n.h2,{id:"sets",children:"Sets"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:"Sometimes you'll want every element in a collection to be unique. While it's possible to create an array and then check that array for duplicates every time a new value is inserted, it's not necessary to do so. Instead, we can use a Set to enforce uniqueness for us. However, it's important to be aware that Sets don't really behave like arrays even though they are collections for holding elements."}),"\n",(0,a.jsx)(n.p,{children:"We can create an empty Set like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"let set = new Set();\n"})}),"\n",(0,a.jsx)(n.p,{children:"We could also instantiate a Set with existing values. For instance:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"let numbers = new Set([4, 9, 12, 4, 7]);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Note that there is a duplicate above. However, once we create the Set and check the value of ",(0,a.jsx)(n.code,{children:"numbers"}),", we'll see that the duplicate has been removed! If you ever have an array of things and you want to remove duplicates, you can just save it as a Set. By the way, you can also pass a string in as an argument to a set \u2014 it will automatically be broken up into letters and all duplicate letters will be removed."]}),"\n",(0,a.jsx)(n.p,{children:"Here's how we can add values to a Set:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"> numbers.add(32);\nSet(5)\xa0{4, 9, 12, 7, 32}\n"})}),"\n",(0,a.jsx)(n.p,{children:"What happens if we try to add a value that already exists in the set?"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"> numbers.add(4);\nSet(5)\xa0{4, 9, 12, 7, 32}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["As you can see, nothing at all. ",(0,a.jsx)(n.code,{children:"Set.prototype.add()"})," just returns the full Set. There's no message if you try to add a duplicate. A Set just quietly enforces uniqueness."]}),"\n",(0,a.jsx)(n.p,{children:"We can also remove values from a Set:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"> numbers.delete(4);\ntrue\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Note that this returns a boolean based on whether the value was successfully deleted. If it were to return ",(0,a.jsx)(n.code,{children:"false"}),", that would just mean that the value wasn't in the Set in the first place."]}),"\n",(0,a.jsx)(n.p,{children:"We can also check to see if a Set has a value:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"> numbers.has(9);\ntrue\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"> numbers.has(51);\nfalse\n"})}),"\n",(0,a.jsx)(n.p,{children:"One very important thing to consider about Sets is that we can't grab a value by its index. For instance, we can't use bracket notation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Won't work!\nnumbers[0];\n"})}),"\n",(0,a.jsx)(n.p,{children:"If getting an element by its index is necessary for your use case, a Set isn't the way to go. Stick with an array."}),"\n",(0,a.jsxs)(n.p,{children:["Like a Map, a Set is iterable. We can use ",(0,a.jsx)(n.code,{children:"Set.prototype.forEach()"})," or a ",(0,a.jsx)(n.code,{children:"for...of"})," loop to iterate through a Set (same as we can with a Map)."]}),"\n",(0,a.jsx)(n.p,{children:"Here's an example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"numbers.forEach(function(number) {\n  console.log(number);\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["For more information, see the ",(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",children:"Mozilla documentation on Set"}),". You will not be expected to utilize Sets in an independent project. However, you are encouraged to explore them in your own code."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var s=t(96540);const a={},r=s.createContext(a);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);