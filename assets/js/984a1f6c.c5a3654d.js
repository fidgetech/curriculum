"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[75305],{28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var s=n(96540);const a={},r=s.createContext(a);function o(e){const t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(r.Provider,{value:t},e.children)}},28735:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/friend-graph-1b59aa48b4b6b400f4fc56b71f52924d.png"},91148:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>i,default:()=>l,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"capstone/capstone-week-1/depth-first-algorithms","title":"\ud83d\udcd3 Depth First Algorithms","description":"In the last lesson, we covered depth-first search and breadth-first search approaches. There are a lot of benefits of using these algorithms. We could determine the reachability between two nodes or we could determine the shortest path between two nodes, just to name a few use cases.","source":"@site/versioned_docs/version-WIP/capstone/1_capstone-week-1/depth-first-algorithms.md","sourceDirName":"capstone/1_capstone-week-1","slug":"/capstone/capstone-week-1/depth-first-algorithms","permalink":"/WIP/capstone/capstone-week-1/depth-first-algorithms","draft":false,"unlisted":false,"tags":[],"version":"WIP","sidebarPosition":23,"frontMatter":{"title":"\ud83d\udcd3 Depth First Algorithms","id":"depth-first-algorithms","slug":"depth-first-algorithms","hide_table_of_contents":true,"sidebar_position":23,"day":"tuesday","type":"lesson","url":"https://github.com/epicodus-curriculum/capstone/blob/main/7_depth_first_algorithm.md"},"sidebar":"capstone","previous":{"title":"\ud83d\udcd3 Depth and Breadth Search Algorithms","permalink":"/WIP/capstone/capstone-week-1/depth-and-breadth-search-algorithms"},"next":{"title":"\ud83d\udcd3 Breadth First Algorithms","permalink":"/WIP/capstone/capstone-week-1/breadth-first-algorithms"}}');var a=n(74848),r=n(28453);const o={title:"\ud83d\udcd3 Depth First Algorithms",id:"depth-first-algorithms",slug:"depth-first-algorithms",hide_table_of_contents:!0,sidebar_position:23,day:"tuesday",type:"lesson",url:"https://github.com/epicodus-curriculum/capstone/blob/main/7_depth_first_algorithm.md"},i=void 0,h={},d=[];function c(e){const t={code:"code",div:"div",em:"em",img:"img",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["In the last lesson, we covered depth-first search and breadth-first search approaches. There are a lot of benefits of using these algorithms. We could determine the ",(0,a.jsx)(t.strong,{children:"reachability"})," between two nodes or we could determine the shortest path between two nodes, just to name a few use cases."]}),"\n",(0,a.jsx)(t.p,{children:"We'll start with the depth-first algorithm because it is a bit easier to implement. To actually use a TDD approach and test our algorithms in a graph, we are going to need to code that graph first. We will add this graph to our test file."}),"\n",(0,a.jsxs)(t.p,{children:["To keep things separated out, we are going to create a new test file called ",(0,a.jsx)(t.code,{children:"dfs.test.js"})," and run all tests related to our depth-first search there. Here is the starter code which includes a graph."]}),"\n",(0,a.jsx)(t.div,{className:"filename",children:"__tests__/dfs.test.js"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'import Graph from \'../src/graph.js\';\n\ndescribe(\'depth-first search\', () => {\n\n  let graph = new Graph();\n  graph.addNode("Jasmine");\n  graph.addNode("Ada");\n  graph.addNode("Lydia");\n  graph.addNode("Rose");\n  graph.addNode("Dylan");\n  graph.addNode("Allison");\n  graph.addNode("Thomas");\n  graph.addNode("Sarah");\n  graph.createEdge("Jasmine", "Ada");\n  graph.createEdge("Jasmine", "Lydia");\n  graph.createEdge("Jasmine", "Rose");\n  graph.createEdge("Ada", "Dylan");\n  graph.createEdge("Lydia", "Ada");\n  graph.createEdge("Dylan", "Allison");\n  graph.createEdge("Lydia", "Thomas");\n});\n'})}),"\n",(0,a.jsxs)(t.p,{children:["Note that we don't put the graph in a ",(0,a.jsx)(t.code,{children:"beforeEach()"})," or ",(0,a.jsx)(t.code,{children:"afterEach()"})," block. We aren't actually going to modify this graph, just traverse it, so there's no need to re-instantiate it before or after every single test."]}),"\n",(0,a.jsx)(t.p,{children:"Next, let's include a visual representation of the coded graph above. It's the same one we were using in the last lesson."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"The following chart shows all of the nodes and edges in the friend graph we&#39;ve created.",src:n(28735).A+"",width:"601",height:"361"})}),"\n",(0,a.jsxs)(t.p,{children:["There is one small but key difference about our graph that is ",(0,a.jsx)(t.em,{children:"not"})," included in our illustration. We've also added Sarah, a node that isn't connected to ",(0,a.jsx)(t.em,{children:"anyone"})," in the graph. We'll need this for one of our tests \u2014 which we'll cover in a moment."]}),"\n",(0,a.jsxs)(t.p,{children:["Our DFS will just check to see if a node is ",(0,a.jsx)(t.strong,{children:"reachable"})," from another node. In this case, we just want to see if we can reach Thomas via Jasmine. While it's obvious from our graph that all its nodes are reachable from each other (except for Sarah), in a real-world application, that might not be the case."]}),"\n",(0,a.jsxs)(t.p,{children:["Let's write our first test. We'll call our method ",(0,a.jsx)(t.code,{children:"Graph.prototype.depthFirstReachable()"})," and it will return a boolean. The reason for the wordy name is because we'll write a method called ",(0,a.jsx)(t.code,{children:"Graph.prototype.breadthFirstReachable()"})," in the next lesson that does the exact same thing as this method \u2014 but with a different algorithm."]}),"\n",(0,a.jsxs)(t.p,{children:["The simplest implementation of our ",(0,a.jsx)(t.code,{children:"Graph.prototype.depthFirstReachable()"})," method is to return false if a potential node doesn't even exist in the graph. For the sake of brevity, we'll code two tests right now: one to check the starting node, one to check the target node. Here are the tests:"]}),"\n",(0,a.jsx)(t.div,{className:"filename",children:"__tests__/dfs.test.js"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'...\n test(\'should return false if the target node doe not exist\', () => {\n    expect(graph.depthFirstReachable("Jasmine", "Albert")).toEqual(false);\n  });\n\n  test(\'should return false if the starting node doe not exist\', () => {\n    expect(graph.depthFirstReachable("Albert", "Thomas")).toEqual(false);\n  });\n...\n'})}),"\n",(0,a.jsx)(t.p,{children:"Now let's get these tests passing:"}),"\n",(0,a.jsx)(t.div,{className:"filename",children:"src/graph.js"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"...\n  depthFirstReachable(startingNode, targetNode) {\n    if ((!this.adjacencyList.has(startingNode)) || (!this.adjacencyList.has(targetNode))) {\n      return false;\n    }\n  }\n...\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Our method will take two arguments: the first, a ",(0,a.jsx)(t.code,{children:"startingNode"}),", is the node we want to start from. The second is the ",(0,a.jsx)(t.code,{children:"targetNode"}),", which is the node we want to find. In an undirected graph, these arguments could be interchangeable. In a directed graph, on the other hand, the order would matter."]}),"\n",(0,a.jsx)(t.p,{children:"Our method just checks to see if both nodes exist in the adjacency list. If one or the other doesn't exist, they obviously aren't reachable. Why go to the trouble of doing a DFS, which could be computationally intensive with a big graph, when values don't even exist? Because our adjacency list is a Map, it is super-fast to do this lookup. Meanwhile, doing a DFS to search the whole graph \u2014 only to tell us the same thing \u2014 would be very inefficient."}),"\n",(0,a.jsx)(t.p,{children:"Next, let's get to the fun stuff. We will check to see if a direct friend of Jasmine is reachable."}),"\n",(0,a.jsx)(t.p,{children:"Here's the test:"}),"\n",(0,a.jsx)(t.div,{className:"filename",children:"__tests__/dfs.test.js"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'...\n  test(\'should check if the first friend in the adjacency list is reachable\', () => {\n    expect(graph.depthFirstReachable("Jasmine", "Ada")).toEqual(true);\n  });\n...\n'})}),"\n",(0,a.jsx)(t.p,{children:"Here's the thing. To get this test passing, we have to write most of the algorithm!"}),"\n",(0,a.jsx)(t.p,{children:"Now the code:"}),"\n",(0,a.jsx)(t.div,{className:"filename",children:"src/graph.js"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"depthFirstReachable(startingNode, targetNode) {\n  if ((!this.adjacencyList.has(startingNode)) || (!this.adjacencyList.has(targetNode))) {\n    return false;\n  }\n  let stack = [startingNode];\n  let traversedNodes = new Set();\n  while (stack.length) {\n    const currentNode = stack.shift();\n    if (currentNode === targetNode) {\n      return true;\n    } else {\n      traversedNodes.add(currentNode);\n      const adjacencyList = this.adjacencyList.get(currentNode);\n      adjacencyList.forEach(function(node) {\n        if (!traversedNodes.has(node)) {\n          stack.unshift(node);\n        }\n      });\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"Let's focus on just the new code \u2014 which is our actual DFS algorithm:"}),"\n",(0,a.jsx)(t.div,{className:"filename",children:"src/graph.js"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"...\nlet stack = [startingNode];\nlet traversedNodes = new Set();\nwhile (stack.length) {\n  const currentNode = stack.shift();\n  if (currentNode === targetNode) {\n    return true;\n  } else {\n    traversedNodes.add(currentNode);\n    const adjacencyList = this.adjacencyList.get(currentNode);\n    adjacencyList.forEach(function(node) {\n      if (!traversedNodes.has(node)) {\n        stack.unshift(node);\n      }\n    });\n  }\n}\n...\n"})}),"\n",(0,a.jsx)(t.p,{children:"First, we need to create our stack:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"let stack = [startingNode];\n"})}),"\n",(0,a.jsxs)(t.p,{children:["It's an array with the ",(0,a.jsx)(t.code,{children:"startingNode"})," as its only element."]}),"\n",(0,a.jsx)(t.p,{children:"Next, we also need some way to flag the nodes that have been traversed. We don't want this to be a property on the node itself because this flag is temporary \u2014 we don't want it to persist once the method is finished running."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"let traversedNodes = new Set();\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This is a ",(0,a.jsx)(t.em,{children:"perfect"})," use case for a Set. We don't want there to be duplicate values \u2014 we just want to know whether a node has been traversed or not. And looking up whether a value in a Set is super-fast \u2014 so it won't take too much time. Remember, hash table lookup is O(1) constant time \u2014 and a Set uses a hash table under the hood."]}),"\n",(0,a.jsx)(t.p,{children:"At this point, we have collections to store a stack as well as a set of traversed nodes. We are ready to start looping!"}),"\n",(0,a.jsxs)(t.p,{children:["In general, when looping through a stack or a queue that will eventually be empty, we can just iterate until the collection's length is zero. At that point, we know we've checked ",(0,a.jsx)(t.em,{children:"every"})," value in the stack or queue."]}),"\n",(0,a.jsx)(t.p,{children:"That's exactly what we do here:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"while (stack.length)\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This just states that we should loop through the stack until it is empty. Once the length of the stack becomes zero, ",(0,a.jsx)(t.code,{children:"stack.length"})," is falsy \u2014 and the loop will end."]}),"\n",(0,a.jsx)(t.p,{children:"Next, we need to take the first element from the stack:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"const currentNode = stack.shift();\n"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"Array.prototype.shift()"})," is a destructive method \u2014 that means that we aren't just grabbing the value of the first element in our stack \u2014 we are also removing it from the array. This is the ",(0,a.jsx)(t.code,{children:"currentNode"})," that we are examining. It is a ",(0,a.jsx)(t.code,{children:"const"})," because the variable itself never changes \u2014 it falls out of scope each time through the loop and is created anew."]}),"\n",(0,a.jsxs)(t.p,{children:["Next, we have a conditional that checks to see if the ",(0,a.jsx)(t.code,{children:"currentNode === targetNode"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"if (currentNode === targetNode) {\n  return true;\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["If they are equal, we've found the target node! The target node is reachable from the starting node \u2014 and we can return ",(0,a.jsx)(t.code,{children:"true"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["If it isn't, we have more work to do. Here's the code in our ",(0,a.jsx)(t.code,{children:"else"})," statement:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"...\n  else {\n    traversedNodes.add(currentNode);\n    const adjacencyList = this.adjacencyList.get(currentNode);\n    adjacencyList.forEach(function(node) {\n      if (!traversedNodes.has(node)) {\n        stack.unshift(node);\n      }\n    });\n  }\n...\n"})}),"\n",(0,a.jsx)(t.p,{children:'First, we need to "flag" our node to show that it\'s been traversed:'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"traversedNodes.add(currentNode);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Here, we use the ",(0,a.jsx)(t.code,{children:"Set.prototype.add()"})," method to add the ",(0,a.jsx)(t.code,{children:"currentNode"})," to ",(0,a.jsx)(t.code,{children:"traversedNodes"}),". This way, when we need to look up whether the node has been traversed or not, we'll see that the ",(0,a.jsx)(t.code,{children:"currentNode"})," has been added. The first time through the loop, this will be the ",(0,a.jsx)(t.code,{children:"startingNode"})," \u2014 also known as Jasmine."]}),"\n",(0,a.jsx)(t.p,{children:"Next, we need to find the adjacency list for the current node. In Jasmine's case, the list is a Set that includes Ada, Lydia, and Rose."}),"\n",(0,a.jsxs)(t.p,{children:["Once we've gotten the adjacency list, we are ready to add it to the stack. To do that, we iterate through the adjacency list, first checking each node in the adjacency list to see if it's in the traversed array \u2014 and then adding that node to the top of the stack with ",(0,a.jsx)(t.code,{children:"Array.prototype.unshift()"}),", which adds an element to the beginning of an array. This will loop through the entire adjacency list, updating our stack. After the loop is done, our stack will look like this:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'["Rose", "Lydia", "Ada"]\n'})}),"\n",(0,a.jsxs)(t.p,{children:["Because ",(0,a.jsx)(t.code,{children:"stack.length"})," has three elements, it's truthy so the loop continues. Due to the following line ",(0,a.jsx)(t.code,{children:"const currentNode = stack.shift();"}),", Rose is taken off the top of the stack and becomes the ",(0,a.jsx)(t.code,{children:"currentNode"}),". Then the entire process continues \u2014 Rose is added to the list of ",(0,a.jsx)(t.code,{children:"traversedNodes"})," and then her adjacency list is added to the stack and so on. Eventually, our DFS will find Ada and recognize that it's equal to the ",(0,a.jsx)(t.code,{children:"targetNode"}),", meaning the method will return true."]}),"\n",(0,a.jsx)(t.p,{children:"If we update our test to look for Thomas instead of Ada, it will pass. As we can see, in order to find Ada, we had to write an algorithm that would also find Thomas \u2014 or anyone else in the graph."}),"\n",(0,a.jsx)(t.p,{children:"There is one more thing we need to do. What about a node that exists but isn't reachable? That's why we added a node for Sarah. This node isn't connected to any other node in the graph \u2014 but it's still part of the graph, which means our initial conditional won't return false."}),"\n",(0,a.jsx)(t.p,{children:"Here's the test:"}),"\n",(0,a.jsx)(t.div,{className:"filename",children:"__tests__/dfs.test.js"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'...\n  test(\'should return false if the target node can not be reached from the starting node\', () => {\n    expect(graph.depthFirstReachable("Jasmine", "Sarah")).toEqual(false);\n  });\n...\n'})}),"\n",(0,a.jsxs)(t.p,{children:["Fortunately, getting this test passing is easy. At some point, ",(0,a.jsx)(t.code,{children:"stack.length"})," is going to be falsy (because it's zero). At that point, we know that we've traversed every node in the graph that is reachable from the starting node. So if we've traversed the entire graph and we still haven't found the node we are looking for, we know it's not reachable. Here's the updated code:"]}),"\n",(0,a.jsx)(t.div,{className:"filename",children:"src/graph.js"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"depthFirstReachable(startingNode, targetNode) {\n  if ((!this.adjacencyList.has(startingNode)) || (!this.adjacencyList.has(targetNode))) {\n    return false;\n  }\n  let stack = [startingNode];\n  let traversedNodes = new Set();\n  while (stack.length) {\n    const currentNode = stack.shift();\n    if (currentNode === targetNode) {\n      return true;\n    } else {\n      traversedNodes.add(currentNode);\n      const adjacencyList = this.adjacencyList.get(currentNode);\n      adjacencyList.forEach(function(node) {\n        if (!traversedNodes.has(node)) {\n          stack.unshift(node);\n        }\n      });\n    }\n  }\n  return false;\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This is our entire method. All we added is the ",(0,a.jsx)(t.code,{children:"return false;"})," outside the while loop. As we can see here, we have a nested loop. The Big O of this particular algorithm is something akin to O(AB) \u2014 though that's not quite accurate because the B (the adjacency list for each node) is always changing \u2014 A (the stack itself) is always changing, too. It should be clear why that initial condition is even more helpful now. Searching the ",(0,a.jsx)(t.em,{children:"entire"})," graph to determine that a node isn't reachable is a big task \u2014 best to check if one of the nodes doesn't exist in the first place."]}),"\n",(0,a.jsxs)(t.p,{children:["At this point, if you are feeling any confusion about how this algorithm works (and it's very understandable if you are), the next step is to intentionally break one of the tests and get into Jest's debug mode so you can step through the method and watch how variables change. The GIF below shows this \u2014 all the relevant variables have been added to ",(0,a.jsx)(t.em,{children:"Watch"})," in the left-hand pane. This loop runs until the algorithm discovers that the Thomas node is, in fact, reachable from the Jasmine node."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"This GIF walks through the code.",src:n(98244).A+"",width:"800",height:"444"})}),"\n",(0,a.jsx)(t.p,{children:"It can also be useful to look at what would happen if we didn't flag traversed nodes. In other words, if our code looked like this instead:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"// This will not work! It will lead to infinite loops because we aren't flagging traversed nodes.\n\ndepthFirstReachable(startingNode, targetNode) {\n    if ((!this.adjacencyList.has(startingNode)) || (!this.adjacencyList.has(targetNode))) {\n      return false;\n    }\n    let stack = [startingNode];\n    while (stack.length) {\n      const currentNode = stack.shift();\n      if (currentNode === targetNode) {\n        return true;\n      } else {\n        const adjacencyList = this.adjacencyList.get(currentNode);\n        adjacencyList.forEach(function(node) {\n          stack.unshift(node);\n        });\n      }\n    }\n    return false;\n  }\n"})}),"\n",(0,a.jsx)(t.p,{children:"Take a look at what happens when we do this:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Now we have an infinite loop between Rose and Jasmine.",src:n(94335).A+"",width:"800",height:"442"})}),"\n",(0,a.jsx)(t.p,{children:"We bounce back and forth between Jasmine and Rose because Rose is a friend of Jasmine and Jasmine is a friend of Rose back and forth forever and ever. A truly beautiful friendship! But we don't want this in our code."}),"\n",(0,a.jsx)(t.p,{children:"So that is a depth-first search algorithm in a nutshell. We use a stack to search through each branch. In this lesson, we just focused on finding whether a node is reachable. You will get a chance to practice some other implementations soon as well."})]})}function l(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},94335:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/depth-first-infinite-loop-27862be37bf773b9e90f1e1a6c10bef4.gif"},98244:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/dfs-8db021490947994c96a0d02b41532cdd.gif"}}]);