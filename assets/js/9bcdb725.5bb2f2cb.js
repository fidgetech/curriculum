"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[86913],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(96540);const o={},s=i.createContext(o);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:n},e.children)}},86519:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"react/react-fundamentals/3-2-0-11-looping-in-jsx","title":"\ud83d\udcd3 3.2.0.11 Looping in JSX","description":"Currently, our application only has two hard-coded tickets. However, this isn\'t how our Help Queue should actually work. A functioning, production-ready application should contain a dynamic list of tickets. In this lesson, we\'ll cover looping through content in JSX.","source":"@site/versioned_docs/version-WIP/3_react/2_react-fundamentals/3-2-0-11-looping-in-jsx.md","sourceDirName":"3_react/2_react-fundamentals","slug":"/react/react-fundamentals/3-2-0-11-looping-in-jsx","permalink":"/WIP/react/react-fundamentals/3-2-0-11-looping-in-jsx","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 3.2.0.11 Looping in JSX","day":"weekend","id":"3-2-0-11-looping-in-jsx","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 3.2.0.10 Prop Types","permalink":"/WIP/react/react-fundamentals/3-2-0-10-prop-types"},"next":{"title":"\ud83d\udcd3 3.2.0.12 Using External Stylesheets with React","permalink":"/WIP/react/react-fundamentals/3-2-0-12-using-external-stylesheets-with-react"}}');var o=t(74848),s=t(28453);const a={title:"\ud83d\udcd3 3.2.0.11 Looping in JSX",day:"weekend",id:"3-2-0-11-looping-in-jsx",hide_table_of_contents:!0},r=void 0,c={},l=[{value:"Looping in JSX",id:"looping-in-jsx",level:2},{value:"Additional Resources",id:"additional-resources",level:3}];function d(e){const n={a:"a",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"Currently, our application only has two hard-coded tickets. However, this isn't how our Help Queue should actually work. A functioning, production-ready application should contain a dynamic list of tickets. In this lesson, we'll cover looping through content in JSX."}),"\n",(0,o.jsx)(n.h2,{id:"looping-in-jsx",children:"Looping in JSX"}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.p,{children:["First, let's create an array of tickets in ",(0,o.jsx)(n.em,{children:"TicketList.js"}),":"]}),"\n",(0,o.jsx)(n.div,{className:"filename",children:"src/components/TicketList.js"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import React from 'react';\nimport Ticket from './Ticket';\n\nconst mainTicketList = [\n  {\n    names: 'Thato and Haley',\n    location: '3A',\n    issue: 'Firebase won\\'t save record. Halp.'\n  },\n  {\n    names: 'Sleater and Kinney',\n    location: '4B',\n    issue: 'Prop types are throwing an error.'\n  },\n  {\n    names: 'Imani & Jacob',\n    location: '9F',\n    issue: 'Child component isn\\'t rendering.'\n  }\n];\n\nfunction TicketList(){\n  ...\n...\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In the future, this list will come from a database or a Redux store. (We'll be exploring both approaches in the next two course sections.) For now, we'll store hard-coded tickets inside our ",(0,o.jsx)(n.code,{children:"TicketList"})," component. Note that we use ",(0,o.jsx)(n.code,{children:"const"}),", not ",(0,o.jsx)(n.code,{children:"let"}),". Remember that props are read-only and that we can't change them."]}),"\n",(0,o.jsxs)(n.p,{children:["Next, we'll add a loop to render a Ticket component for each entry in ",(0,o.jsx)(n.code,{children:"mainTicketList"}),". In JSX, we use the ",(0,o.jsx)(n.code,{children:"map()"})," function for loops."]}),"\n",(0,o.jsx)(n.div,{className:"filename",children:"TicketList.js"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"...\n    return (\n      <React.Fragment>\n        <hr/>\n        {mainTicketList.map((ticket, index) =>\n          <Ticket names={ticket.names}\n            location={ticket.location}\n            issue={ticket.issue}\n            key={index}/>\n        )}\n      </React.Fragment>\n    );\n...\n"})}),"\n",(0,o.jsxs)(n.p,{children:["As we can see here, ",(0,o.jsx)(n.code,{children:"map()"})," loops through our ",(0,o.jsx)(n.code,{children:"mainTicketList"}),". On each iteration, it creates a new ",(0,o.jsx)(n.code,{children:"Ticket"})," with props corresponding to one of the tickets in ",(0,o.jsx)(n.code,{children:"mainTicketList"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"There are a few other important things to note:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["We add ",(0,o.jsx)(n.code,{children:"index"})," as an argument to our ",(0,o.jsx)(n.code,{children:"map()"})," function. ",(0,o.jsx)(n.code,{children:"map()"})," can take an optional ",(0,o.jsx)(n.code,{children:"index"})," argument if we need access to how many times our loop has iterated."]}),"\n",(0,o.jsxs)(n.li,{children:["We add a ",(0,o.jsx)(n.code,{children:"key"})," value to each ticket which corresponds to the current ",(0,o.jsx)(n.code,{children:"index"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Why bother to include the ",(0,o.jsx)(n.code,{children:"index"})," and create a unique ",(0,o.jsx)(n.code,{children:"key"})," value? If we don't, our code will run correctly but we'll get the following error in the console: ",(0,o.jsx)(n.em,{children:'Warning: Each child in an array or iterator should have a unique "key" prop.'}),' This error is pretty clear. Each ticket should have a unique "key" prop.']}),"\n",(0,o.jsx)(n.p,{children:"Having unique keys makes our application more efficient because it helps React differentiate between similar components so it can identify which have been updated, added, or removed from the list during its virtual DOM reconciliation."}),"\n",(0,o.jsxs)(n.p,{children:["Our tickets don't have a unique ID value (at least not yet), which is why we are using the item's array index for now. If our tickets already had unique IDs, we wouldn't need to pass in ",(0,o.jsx)(n.code,{children:"index"})," as an argument to ",(0,o.jsx)(n.code,{children:"map()"})," \u2014 we'd just use the unique IDs as keys. The keys just need to be unique so React can manage reconciliation effectively."]}),"\n",(0,o.jsx)(n.p,{children:"Now we can run our application and see that all our tickets are correctly populating!"}),"\n",(0,o.jsx)(n.h3,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,o.jsxs)(n.p,{children:["If you'd like a more technical explanation about how React uses these unique ",(0,o.jsx)(n.code,{children:"key"})," props, check out the ",(0,o.jsx)(n.a,{href:"https://facebook.github.io/react/docs/reconciliation.html#recursing-on-children",children:'"Recursing on Children" section of the React Reconciliation Documentation'}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);