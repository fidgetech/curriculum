"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[38687],{16339:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"c-and-net/authentication-with-identity/5-5-0-8-authentication-with-identity-user-login-and-logout","title":"\ud83d\udcd3 5.5.0.8 Authentication with Identity: User Login and Logout","description":"Now that users can successfully register for new accounts, let\'s add the logic necessary for them to sign in and out of their accounts.","source":"@site/versioned_docs/version-WIP/c-and-net/5_authentication-with-identity/3-5-0-08-authentication-with-identity-user-login-and-logout.md","sourceDirName":"c-and-net/5_authentication-with-identity","slug":"/c-and-net/authentication-with-identity/5-5-0-8-authentication-with-identity-user-login-and-logout","permalink":"/WIP/c-and-net/authentication-with-identity/5-5-0-8-authentication-with-identity-user-login-and-logout","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 5.5.0.8 Authentication with Identity: User Login and Logout","day":"weekend","id":"5-5-0-8-authentication-with-identity-user-login-and-logout","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 5.5.0.7 Authentication with Identity: User Registration ViewModel, Validation, and Views","permalink":"/WIP/c-and-net/authentication-with-identity/5-5-0-7-authentication-with-identity-user-registration-viewmodel-validation-and-views"},"next":{"title":"\ud83d\udcd3 5.5.0.9 Adding Authorization and Associating Users with Items","permalink":"/WIP/c-and-net/authentication-with-identity/5-5-0-9-adding-authorization-and-associating-users-with-items"}}');var o=t(74848),s=t(28453);const r={title:"\ud83d\udcd3 5.5.0.8 Authentication with Identity: User Login and Logout",day:"weekend",id:"5-5-0-8-authentication-with-identity-user-login-and-logout",hide_table_of_contents:!0},a=void 0,l={},c=[{value:"Logging In",id:"logging-in",level:2},{value:"ViewModel",id:"viewmodel",level:3},{value:"View",id:"view",level:3},{value:"Controller Actions",id:"controller-actions",level:3},{value:"Displaying Login Confirmation",id:"displaying-login-confirmation",level:3},{value:"Logging Out",id:"logging-out",level:2},{value:"Controller Action",id:"controller-action",level:3},{value:"View",id:"view-1",level:3},{value:"Repository Reference",id:"repository-reference",level:3}];function d(e){const n={a:"a",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",hr:"hr",i:"i",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"Now that users can successfully register for new accounts, let's add the logic necessary for them to sign in and out of their accounts."}),"\n",(0,o.jsx)(n.h2,{id:"logging-in",children:"Logging In"}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.p,{children:"First, let's walk through the process of logging a user in."}),"\n",(0,o.jsx)(n.h3,{id:"viewmodel",children:"ViewModel"}),"\n",(0,o.jsxs)(n.p,{children:["Our login page will contain a form asking for the user's email and password. We'll create the necessary ",(0,o.jsx)(n.code,{children:"ViewModel"})," in the ",(0,o.jsx)(n.code,{children:"ViewModels"})," folder to manage this:"]}),"\n",(0,o.jsx)(n.div,{className:"filename",children:"ViewModels/LoginViewModel.cs"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'using System.ComponentModel.DataAnnotations;\n\nnamespace ToDoList.ViewModels\n{\n  public class LoginViewModel\n  {\n    [Required]\n    [EmailAddress]\n    [Display(Name = "Email Address")]\n    public string Email { get; set; }\n    \n    [Required]\n    [DataType(DataType.Password)]\n    public string Password { get; set; }\n  }\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Again, notice we follow naming conventions by including the ",(0,o.jsx)(n.code,{children:"ViewModel"})," prefix at the end of our View Model's filename."]}),"\n",(0,o.jsx)(n.h3,{id:"view",children:"View"}),"\n",(0,o.jsxs)(n.p,{children:["Next, we'll create the ",(0,o.jsx)(n.code,{children:"View"})," containing our login form:"]}),"\n",(0,o.jsx)(n.div,{className:"filename",children:"Views/Account/Login.cshtml"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-html",children:'@{\n  Layout = "_Layout";\n}\n\n@using ToDoList.ViewModels\n\n@model LoginViewModel\n\n<h2>Log in with your account</h2>\n<hr />\n\n@if(!ViewData.ModelState.IsValid) \n{\n  @Html.ValidationSummary("Please fix the following error(s) and then resubmit the form:") \n}\n\n@using (Html.BeginForm())\n{\n  @Html.LabelFor(m => m.Email)\n  @Html.TextBoxFor(m => m.Email)\n\n  @Html.LabelFor(m => m.Password)\n  @Html.EditorFor(m => m.Password)\n\n  <input type="submit" value="Log in" />\n}\n\n<p>@Html.ActionLink("Register for an account", "Register")</p>\n<p>@Html.ActionLink("Back to accounts page", "Index")</p>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"controller-actions",children:"Controller Actions"}),"\n",(0,o.jsxs)(n.p,{children:["Now we can add the necessary actions to the controller. We'll include a ",(0,o.jsx)(n.code,{children:"GET"})," to retrieve and display the Login ",(0,o.jsx)(n.code,{children:"View"})," in addition to a ",(0,o.jsx)(n.code,{children:"POST"})," to go through the process of actually logging a user in once they submit the login form."]}),"\n",(0,o.jsx)(n.p,{children:"Let's take a look at the full code and then we'll explain it in detail."}),"\n",(0,o.jsx)(n.div,{className:"filename",children:"AccountController.cs"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'...\n    public ActionResult Login()\n    {\n      return View();\n    }\n\n    [HttpPost]\n    public async Task<ActionResult> Login(LoginViewModel model)\n    {\n      if (!ModelState.IsValid)\n      {\n        return View(model);\n      }\n      else\n      {\n        Microsoft.AspNetCore.Identity.SignInResult result = await _signInManager.PasswordSignInAsync(model.Email, model.Password, isPersistent: true, lockoutOnFailure: false);\n        if (result.Succeeded)\n        {\n          return RedirectToAction("Index");\n        }\n        else\n        {\n          ModelState.AddModelError("", "There is something wrong with your email or username. Please try again.");\n          return View(model);\n        }\n      }\n    }\n...\n'})}),"\n",(0,o.jsxs)(n.p,{children:["We'll focus on the ",(0,o.jsx)(n.code,{children:"Login()"})," POST method which once again uses an asynchronous method. Note that there are several similarities with our ",(0,o.jsx)(n.code,{children:"Register()"})," POST method:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Both methods are ",(0,o.jsx)(n.code,{children:"async"})," and return a ",(0,o.jsx)(n.code,{children:"Task<ActionResult>"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Both take a ",(0,o.jsx)(n.code,{children:"ViewModel"})," as an argument."]}),"\n",(0,o.jsx)(n.li,{children:"Both methods check if the model is valid, and if not return to the view to inform the user of their errors."}),"\n",(0,o.jsxs)(n.li,{children:["Both use an Identity method ending with ",(0,o.jsx)(n.code,{children:"Async"}),". All async Identity methods have ",(0,o.jsx)(n.code,{children:"Async"})," appended to them."]}),"\n",(0,o.jsxs)(n.li,{children:["Both methods have a ",(0,o.jsx)(n.code,{children:"result"})," that must ",(0,o.jsx)(n.code,{children:"await"})," the completion of an Identity method."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Now let's take a closer look at the following line:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"Microsoft.AspNetCore.Identity.SignInResult result = await _signInManager.PasswordSignInAsync(model.Email, model.Password, isPersistent: true, lockoutOnFailure: false);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Remember that we've injected a ",(0,o.jsx)(n.code,{children:"SignInManager"})," service, which is being referenced in the ",(0,o.jsx)(n.code,{children:"signInManager"})," variable. The ",(0,o.jsx)(n.code,{children:"SignInManager"})," class includes the ",(0,o.jsx)(n.code,{children:"PasswordSignInAsync()"})," method, which has a self-explanatory name: it's an async method that allows users to sign in with a password."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"PasswordSignInAsync()"})," takes four parameters: ",(0,o.jsx)(n.code,{children:"userName"}),", ",(0,o.jsx)(n.code,{children:"password"}),", ",(0,o.jsx)(n.code,{children:"isPersistent"}),", and ",(0,o.jsx)(n.code,{children:"lockoutOnFailure"}),". For now we're only handling username and password, so we set explicit boolean values for ",(0,o.jsx)(n.code,{children:"isPersistent"})," and ",(0,o.jsx)(n.code,{children:"lockoutOnFailure"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["However, just like in our ",(0,o.jsx)(n.code,{children:"Register()"})," action, we want to ensure our application doesn't freeze or break if Identity can't successfully authenticate an account. That's why we add an ",(0,o.jsx)(n.code,{children:"if"})," statement based on whether the ",(0,o.jsx)(n.code,{children:"result"})," has succeeded or not. The ",(0,o.jsx)(n.code,{children:"Microsoft.AspNetCore.Identity.SignInResult"})," object has a ",(0,o.jsx)(n.code,{children:"Succeeded"})," boolean property to help with this. If our sign in action has succeeded, then we'll be redirected to our accounts index page."]}),"\n",(0,o.jsxs)(n.p,{children:["If our sign in action has failed, well, there's no ",(0,o.jsx)(n.code,{children:"SignInResult.Errors"})," property to use to create error messages for our user. There are individual properties with information about different signin states, which you can review in ",(0,o.jsxs)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.identity.signinresult.failed?view=aspnetcore-6.0",children:["the [",(0,o.jsx)(n.code,{children:"SignInResult"}),"] docs"]}),"."]}),"\n",(0,o.jsx)(n.p,{children:"So what should we do? This is really a trick question: we don't actually want to give specific error messages to the user about why a sign in attempt has failed. That's because specific error messages could be delivered to malicious users that improve their ability to break into an account. For example, it's better to state \"there was an issue with your username or password\" than to state the more specific \"that password does not match our records\". So this is exactly what we do in case of a signin failure. Let's look at the code once more:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'Microsoft.AspNetCore.Identity.SignInResult result = await _signInManager.PasswordSignInAsync(model.Email, model.Password, isPersistent: true, lockoutOnFailure: false);\nif (result.Succeeded)\n{\n  return RedirectToAction("Index");\n}\nelse\n{\n  ModelState.AddModelError("", "There is something wrong with your email or username. Please try again.");\n  return View(model);\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["We still create a new ",(0,o.jsx)(n.code,{children:"ModelState"})," error, but our error message is very generic."]}),"\n",(0,o.jsx)(n.h3,{id:"displaying-login-confirmation",children:"Displaying Login Confirmation"}),"\n",(0,o.jsxs)(n.p,{children:["Since the action will redirect to ",(0,o.jsx)(n.em,{children:"Index"})," if the user successfully logs in, let's add some code to ",(0,o.jsx)(n.code,{children:"Index.cshtml"})," to display different information based on whether or not the user is logged in:"]}),"\n",(0,o.jsx)(n.div,{className:"filename",children:"Views/Account/Index.cshtml"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-html",children:'@{\n  Layout = "_Layout";\n}\n\n<h2>Authentication with Identity</h2>\n<hr />\n@if (User.Identity.IsAuthenticated)\n{\n  <p>Hello @User.Identity.Name!</p>\n}\nelse\n{\n  <p>@Html.ActionLink("Register", "Register")</p>\n  <p>@Html.ActionLink("Log in", "Login")</p>\n}\n<p>@Html.ActionLink("Home", "Index", "Home")</p>\n'})}),"\n",(0,o.jsxs)(n.p,{children:["We added an ",(0,o.jsx)(n.code,{children:"if/else"})," statement to display a greeting to the user if they are logged in. If they aren't, we display links to register or log in. Our if statement relies on accessing the ",(0,o.jsx)(n.code,{children:"User"})," variable, which is a property called ",(0,o.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.razor.razorpagebase.user?view=aspnetcore-6.0",children:"RazorPageBase.User"}),", but is of the type ",(0,o.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.security.claims.claimsprincipal?view=net-6.0",children:"System.Security.Claims.ClaimsPrincipal"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["We can access two properties through the ",(0,o.jsx)(n.code,{children:"User.Identity"})," property:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.security.principal.iidentity.isauthenticated?view=net-6.0",children:(0,o.jsx)(n.code,{children:"User.Indentity.Name"})})," gives us the currently logged in user's name (for us, their email) or null if there is none."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.security.principal.iidentity.name?view=net-6.0",children:(0,o.jsx)(n.code,{children:"User.Indentity.IsAuthenticated"})})," gives us ",(0,o.jsx)(n.code,{children:"true"})," if there's an authenticated user (meaning, a user who is logged in), or ",(0,o.jsx)(n.code,{children:"false"})," if there is no currently logged in user."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Note that we can access both of the above properties anywhere in our views, as needed. ",(0,o.jsx)(n.code,{children:"User.Indentity.IsAuthenticated"})," is particularly useful for creating conditionals that display information only to authenticated users."]}),"\n",(0,o.jsx)(n.h2,{id:"logging-out",children:"Logging Out"}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.p,{children:"Next, let's give the user the ability to log out. Instead of creating a separate GET and POST controller action and view, we'll create just a POST controller action and add a form directly to our account's index page."}),"\n",(0,o.jsx)(n.h3,{id:"controller-action",children:"Controller Action"}),"\n",(0,o.jsxs)(n.p,{children:["Add a ",(0,o.jsx)(n.code,{children:"LogOff()"})," action to the controller."]}),"\n",(0,o.jsx)(n.div,{className:"filename",children:"AccountController.cs"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'...\n[HttpPost]\npublic async Task<ActionResult> LogOff()\n{\n  await _signInManager.SignOutAsync();\n  return RedirectToAction("Index");\n}\n...\n'})}),"\n",(0,o.jsxs)(n.p,{children:["This method is straightforward. ",(0,o.jsx)(n.code,{children:"SignInManager"})," has the asynchronous method ",(0,o.jsx)(n.code,{children:"SignOutAsync()"})," that signs the user out. Everything else in this method should look familiar at this point."]}),"\n",(0,o.jsx)(n.p,{children:"Note that we don't need to add any error handling or model validation here, since a user should only be able to log out if they're already logged in."}),"\n",(0,o.jsx)(n.h3,{id:"view-1",children:"View"}),"\n",(0,o.jsxs)(n.p,{children:["We're going to add a form to invoke the ",(0,o.jsx)(n.code,{children:"LogOff()"})," POST action directly to our ",(0,o.jsx)(n.code,{children:"Account/Index.cshtml"})," view. Here's what our view should now look like:"]}),"\n",(0,o.jsx)(n.div,{className:"filename",children:"Views/Account/Index.cshtml"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-html",children:'@{\n  Layout = "_Layout";\n}\n\n<h2>Authentication with Identity</h2>\n<hr />\n@if (User.Identity.IsAuthenticated)\n{\n  <p>Hello @User.Identity.Name!</p>\n  @using (Html.BeginForm("LogOff", "Account"))\n  {\n    <input type="submit" class="btn btn-primary" value="Log out" />\n  }\n}\nelse\n{\n  <p>@Html.ActionLink("Register", "Register")</p>\n  <p>@Html.ActionLink("Log in", "Login")</p>\n}\n<p>@Html.ActionLink("Home", "Index", "Home")</p>\n'})}),"\n",(0,o.jsx)(n.p,{children:"We now have complete functionality for users to sign up, sign in, and sign out. Woo-hoo!"}),"\n",(0,o.jsx)(n.h3,{id:"repository-reference",children:"Repository Reference"}),"\n",(0,o.jsx)(n.p,{children:"Follow the link below to view how a sample version of the project should look at this point. Note that this is a link to a specific branch in the repository."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:(0,o.jsxs)(n.a,{href:"https://github.com/epicodus-lessons/section-5-to-do-list-with-auth-csharp-net6/tree/2_authentication",children:[(0,o.jsx)(n.i,{className:"glyphicon glyphicon-folder-open"})," Example GitHub Repo for To Do List with Authentication and Authorization: ",(0,o.jsx)(n.code,{children:"2_authentication"})]})})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(96540);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);