"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[11871],{11388:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>h});const o=JSON.parse('{"id":"capstone/capstone-week-1/memory-basics","title":"\ud83d\udcd3 Memory Basics","description":"During your time at Epicodus, you\'ve learned about storing data in variables, collections such as arrays and objects, and in databases. But we\'ve never covered how our machines store this information. In this lesson, we\'ll cover the basics of how these things are stored in our machine. We\'ll start by looking at how a low-level language like C or C++ stores various pieces of information in either a stack or a heap. We\'ll also learn a bit more about garbage collection, the process of removing variables that are no longer in scope, and memory leaks, which is when variables and other code we are no longer using remain in memory (kind of like old food in the fridge that just takes up space).","source":"@site/versioned_docs/version-WIP/capstone/1_capstone-week-1/memory-basics.md","sourceDirName":"capstone/1_capstone-week-1","slug":"/capstone/capstone-week-1/memory-basics","permalink":"/WIP/capstone/capstone-week-1/memory-basics","draft":false,"unlisted":false,"tags":[],"version":"WIP","sidebarPosition":44,"frontMatter":{"title":"\ud83d\udcd3 Memory Basics","id":"memory-basics","slug":"memory-basics","hide_table_of_contents":true,"sidebar_position":44,"day":"thursday","type":"lesson","url":"https://github.com/epicodus-curriculum/capstone/blob/main/memory_basics.md"},"sidebar":"capstone","previous":{"title":"\ud83d\udcd3 Tries","permalink":"/WIP/capstone/capstone-week-1/tries"},"next":{"title":"\ud83d\udcd3 Memoization","permalink":"/WIP/capstone/capstone-week-1/memoization"}}');var n=t(74848),r=t(28453);const s={title:"\ud83d\udcd3 Memory Basics",id:"memory-basics",slug:"memory-basics",hide_table_of_contents:!0,sidebar_position:44,day:"thursday",type:"lesson",url:"https://github.com/epicodus-curriculum/capstone/blob/main/memory_basics.md"},i=void 0,l={},h=[{value:"Random-Access Memory (RAM)",id:"random-access-memory-ram",level:2},{value:"Stack Memory Versus Heap Memory",id:"stack-memory-versus-heap-memory",level:2},{value:"How C and C++ Handle Memory",id:"how-c-and-c-handle-memory",level:2},{value:"JavaScript and V8",id:"javascript-and-v8",level:2},{value:"Memory Leaks",id:"memory-leaks",level:2}];function c(e){const a={code:"code",em:"em",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(a.p,{children:["During your time at Epicodus, you've learned about storing data in variables, collections such as arrays and objects, and in databases. But we've never covered how our machines store this information. In this lesson, we'll cover the basics of how these things are stored in our machine. We'll start by looking at how a low-level language like C or C++ stores various pieces of information in either a stack or a heap. We'll also learn a bit more about ",(0,n.jsx)(a.strong,{children:"garbage collection"}),", the process of removing variables that are no longer in scope, and ",(0,n.jsx)(a.strong,{children:"memory leaks"}),", which is when variables and other code we are no longer using remain in memory (kind of like old food in the fridge that just takes up space)."]}),"\n",(0,n.jsxs)(a.p,{children:["You might wonder why we are going to concern ourselves with how low-level languages like C and C++ do things. After all, we have focused only on learning high-level languages like JavaScript at Epicodus. Well, when we use Chrome or Node, we are utilizing the V8 engine \u2014 which is built with C++. So on a deeper level, we ",(0,n.jsx)(a.em,{children:"are"})," utilizing low-level languages, which means it's good to know a little bit more about how they work. If we were working on a computer science degree, we'd go all the way to the level of machine language by learning about the assembly language. We aren't covering assembly in this course but it's still useful to see how our code works on a deeper level beyond JavaScript. In this case, we'll start by looking at random-access memory, then we'll look at how C and C++ handle memory, and then finally we'll take a look at what the V8 engine does."]}),"\n",(0,n.jsx)(a.h2,{id:"random-access-memory-ram",children:"Random-Access Memory (RAM)"}),"\n",(0,n.jsx)(a.p,{children:"Most people that own a computer have at least a passing familiarity with the term RAM (random-access memory). Generally, we know that the more RAM a computer has, the faster it is \u2014 and the more programs it can handle. But what is RAM exactly? And how does it differ from other memory storage on our computer?"}),"\n",(0,n.jsx)(a.p,{children:"Well, in general, a computer has two kinds of memory. RAM is used to run tasks while our hard drive is used to store files. We can use the analogy of a person working on a project. As that person works (and perhaps multi-tasks), all the brain power they're using at that moment is like RAM. Meanwhile, all the other stuff that's being stored (childhood memories, vague recollections of algebra) is that person's storage drive."}),"\n",(0,n.jsx)(a.p,{children:"Likewise, when we write a program and save it, that program is stored on our computer's storage drive (or in the cloud, on a flash drive, or wherever we might choose to store it)."}),"\n",(0,n.jsx)(a.p,{children:"When we execute our program, it needs to be loaded into the machine's RAM. Whether we are using the internet, running programs we've written, writing a paper, or playing a video game, all kinds of code is running behind the scenes \u2014 and the function calls, variables and temporary data our program uses are all being stored in the machine's RAM."}),"\n",(0,n.jsx)(a.p,{children:"You've probably experienced a significant slow-down with a computer before when too many programs are running \u2014 or when we have too many windows open in a browser. Often, that occurs because we are running out of RAM. The way to fix the problem is to either close out the programs (use less memory) or get more RAM installed (have more memory to deal with all the programs)."}),"\n",(0,n.jsxs)(a.p,{children:["So let's say we run a JavaScript program we've written. The program has a variable called ",(0,n.jsx)(a.code,{children:"userInput"}),". First, this program needs to be loaded into the random-access memory of the machine. If there's not enough RAM, only part of the program will be loaded into RAM and the rest will be kept on the storage drive and pulled from as needed. As you might imagine, this slows down the execution of the program significantly."]}),"\n",(0,n.jsx)(a.p,{children:"The JavaScript interpreter will convert the variable from JavaScript all the way down to bits. In a compiled language, a compiler will do this conversion. We won't look too deeply into this conversion \u2014 thankfully our machines do the heavy lifting for us."}),"\n",(0,n.jsxs)(a.p,{children:["The memory itself is organized into ",(0,n.jsx)(a.strong,{children:"memory addresses"}),", also known as ",(0,n.jsx)(a.strong,{children:"addresses"}),". Each memory address holds one byte of data. (A quick reminder \u2014 a byte is 8 bits of data.) Memory addresses are sequential and we can think of them as being like street addresses. When someone delivers mail, they know where it should go because they simply have to go to the correct street address. So when our machine gets a piece of code that needs to be stored in RAM, it uses the memory address to determine where it should go \u2014 or where it should be retrieved from as needed."]}),"\n",(0,n.jsx)(a.p,{children:"Within RAM, there are two regions of memory: the stack and the heap. It's important to note that while the stack is similar to the data structure we've learned about (which is LIFO), the heap is just a name for the other region of memory \u2014 and it isn't actually stored in a heap data structure."}),"\n",(0,n.jsx)(a.h2,{id:"stack-memory-versus-heap-memory",children:"Stack Memory Versus Heap Memory"}),"\n",(0,n.jsx)(a.p,{children:"The stack memory is a linear data structure, which means that it is stored sequentially. When we call a function, the function and the variables inside that function are stored in stack memory. Stack memory is allocated and deallocated for us automatically. But what does that mean? Well, our machine will assign it as needed and then remove it when it is no longer needed and we don't have to worry about it. For instance, when we call a function, the variables in that function automatically are in scope. That is the memory being allocated. Then, when the function is complete, the variables in that function fall out of scope. That is the memory being deallocated. We don't need to tell the stack memory to add or remove these variables \u2014 it will take care of that for us. Stack memory is much faster than heap memory. One downside of stack memory, though, is that it's much smaller than heap memory, and if we're not careful, we can end up with a stack overflow, especially if we are calling functions recursively."}),"\n",(0,n.jsx)(a.p,{children:"On the other hand, heap memory is a hierarchical data structure. It's not stored sequentially \u2014 instead, it's stored in relation to other data. This is where dynamic variables such as global variables are stored. Also, a low-level language like C can manually allocate variables to the heap. It's slower than stack memory because there's no easy way to just grab values from the heap, unlike with stack memory, where we can just look at the top of the stack and grab what we need."}),"\n",(0,n.jsxs)(a.p,{children:["You might think that it's as simple as local versus global when it comes to determining stack versus heap storage but it's not. We also need to look at ",(0,n.jsx)(a.strong,{children:"value types"})," versus ",(0,n.jsx)(a.strong,{children:"reference types"}),"."]}),"\n",(0,n.jsxs)(a.p,{children:["A ",(0,n.jsx)(a.strong,{children:"value type"})," is a single space in memory in the stack where a value as stored. These include primitives such as numbers and strings."]}),"\n",(0,n.jsxs)(a.p,{children:["Meanwhile, ",(0,n.jsx)(a.strong,{children:"reference types"})," contain pointers to where an object is stored in memory. The object itself (such as a JavaScript array or basic object) is stored in the heap. But if we're using good coding practices, the pointer is probably being stored in a local variable in a function \u2014 which means that the reference is being stored in the stack while the array or object is being stored in the heap. Since dynamic variables are stored in the heap, it makes sense that the arrays and objects we create in JavaScript would be stored there as they can often change."]}),"\n",(0,n.jsx)(a.p,{children:"Unlike with stack memory, heap memory isn't automatically deallocated. We either need to do it manually (such as in a low-level language like C) or have an interpreter or compiler handle it for us in a high-level language like JavaScript."}),"\n",(0,n.jsx)(a.h2,{id:"how-c-and-c-handle-memory",children:"How C and C++ Handle Memory"}),"\n",(0,n.jsx)(a.p,{children:"We are skipping over the bits and bytes aspect of memory allocation and deallocation \u2014 and we are also skipping over assembly language and machine level code \u2014 but we won't jump all the way up to a high-level language like JavaScript just yet."}),"\n",(0,n.jsx)(a.p,{children:"Instead, let's look at a key difference in how a low-level language like C or C++ handles memory. As we've already mentioned, stack memory is handled automatically in RAM. However, heap memory is not. In the case of a low-level language like C++, we need to allocate and deallocate memory in the heap manually. If we don't, we'll run into memory leaks. We will talk more about memory leaks later in this lesson."}),"\n",(0,n.jsxs)(a.p,{children:["When we want to allocate a certain amount of memory with C or C++, we can do so with the ",(0,n.jsx)(a.code,{children:"malloc"})," function. (You don't need to memorize this \u2014 what's more important is the process that occurs.) The ",(0,n.jsx)(a.code,{children:"malloc"})," function allocates a ",(0,n.jsx)(a.em,{children:"specific"})," number of bytes. We might do something like this:"]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-c",children:"pointer = (int *) malloc (100);\n"})}),"\n",(0,n.jsxs)(a.p,{children:["Here, we are creating a number (",(0,n.jsx)(a.code,{children:"int"}),") and then allocating 100 bytes in the heap memory to store this number. We store this in a ",(0,n.jsx)(a.code,{children:"pointer"})," variable, which will allow us to access this number later \u2014 and also deallocate memory as necessary."]}),"\n",(0,n.jsxs)(a.p,{children:["Meanwhile, the ",(0,n.jsx)(a.code,{children:"realloc"})," function increases or decreases the size of a memory block while the ",(0,n.jsx)(a.code,{children:"free"})," function releases memory back into the system. So if we wanted to free up the memory that ",(0,n.jsx)(a.code,{children:"pointer"})," references, we'd do the following:"]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-c",children:"free(pointer);\n"})}),"\n",(0,n.jsx)(a.p,{children:"If we forgot to free up this memory \u2014 but we were no longer using the integer in our program \u2014 we'd have a memory leak. Add up enough memory leaks and performance will be significantly impacted."}),"\n",(0,n.jsx)(a.h2,{id:"javascript-and-v8",children:"JavaScript and V8"}),"\n",(0,n.jsx)(a.p,{children:"So now we're at the level of JavaScript. To run JavaScript, we need to use a JavaScript engine to compile our code. Traditionally, JavaScript engines were interpreters but they now use JIT (just-in-time) compilation, which is faster. Throughout our time at Epicodus, we've primarily run JavaScript in Chrome (if we're running applications in the browser) or in Node (if we are running tests with Jest or using the Node REPL). Chrome and Node use the V8 engine \u2014 which is built on C++. As we mentioned at the beginning of this lesson, that's why it's helpful to know a little bit more about what's happening under the hood!"}),"\n",(0,n.jsx)(a.p,{children:"JavaScript primitives are value types. Meanwhile, arrays, objects, and functions are reference types. For the latter, that means that when we create a reference type, we are creating a variable that is a pointer that will be stored in stack memory (unless it's a global variable) while the object itself (arrays and functions are both objects in JavaScript) will be stored in heap memory."}),"\n",(0,n.jsx)(a.p,{children:"So let's say that we call the following function:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-js",children:"function doesSomething() {\n  let array = [];\n  // Do stuff with array.\n  return somethingElse;\n}\n"})}),"\n",(0,n.jsxs)(a.p,{children:["When this function is called in a program, the variables inside ",(0,n.jsx)(a.code,{children:"doesSomething()"})," will go on the stack memory. When we assign ",(0,n.jsx)(a.code,{children:"array"}),", a new array will be created in heap memory and a pointer to that array (the ",(0,n.jsx)(a.code,{children:"array"})," variable itself) will be stored in stack memory because it's a local variable. JavaScript will automatically do the memory allocation for us \u2014 and will do so whenever a variable is declared."]}),"\n",(0,n.jsxs)(a.p,{children:["We'll do some computation with the array and then return ",(0,n.jsx)(a.code,{children:"somethingElse"})," from the function. At that point, we are done with the function call \u2014 and the local variable. So what happens next? Well, high level languages like JavaScript manage memory via ",(0,n.jsx)(a.strong,{children:"garbage collection"}),". Garbage collection just means that when a program no longer needs memory, it will automatically be deallocated for us. Generally, high-level languages include garbage collection."]}),"\n",(0,n.jsx)(a.p,{children:"How does JavaScript know whether a piece of memory should be garbage collected? Well, traditionally JavaScript and other languages would count references. If an object ever has nothing else referring to it, it's no longer being used, meaning that object will be garbage-collected. After all, if there are no references to an object (such as a variable), we have no way of accessing it."}),"\n",(0,n.jsx)(a.p,{children:"However, this method of garbage collection doesn't work for circular dependencies. For example, if one object refers to another and that second object refers to the first \u2014 they will both always have at least one reference, meaning they'll never be garbage-collected."}),"\n",(0,n.jsx)(a.p,{children:"At this point, modern browsers and V8 use a mark-and-sweep algorithm. This algorithm simple determines whether a variable or object is still reachable or not. If it isn't reachable, it's garbage-collected. At this point, we have enough knowledge that we could write a mark-and-sweep algorithm ourselves if we wanted by applying graph theory and writing either a DFA or a BFA."}),"\n",(0,n.jsxs)(a.p,{children:["So if we return to the ",(0,n.jsx)(a.code,{children:"doesSomething()"})," function above, when the variables inside the function fall out of scope, the ",(0,n.jsx)(a.code,{children:"array"})," variable will be removed from the stack memory. Then, when a mark-and-sweep finds that the array object in heap memory is no longer reachable (because the only pointer to it has fallen out of scope), the array object will automatically be removed from heap memory."]}),"\n",(0,n.jsx)(a.h2,{id:"memory-leaks",children:"Memory Leaks"}),"\n",(0,n.jsx)(a.p,{children:"Since memory deallocation is automatically handled for us in JavaScript, we don't need to worry about memory leaks, right?"}),"\n",(0,n.jsx)(a.p,{children:"That's actually not true. Memory leaks can and do happen in JavaScript, even if we don't have to be as attentive as we would in a low-level language where we need to deallocate memory manually."}),"\n",(0,n.jsx)(a.p,{children:"We've talked a lot about why global variables are generally bad \u2014 they can interfere with our code and pollute local variables with the same names. And now we have another reason why we should avoid global variables if possible. They remain in memory as long as the program is running. If we think about this in the context of a mark-and-sweep algorithm, this makes sense. A global variable is always reachable, which means it will never be garbage-collected."}),"\n",(0,n.jsxs)(a.p,{children:["We can also potentially run into memory links with the ",(0,n.jsx)(a.code,{children:"setInterval()"})," function. Imagine, for instance, we run a ",(0,n.jsx)(a.code,{children:"setInterval()"})," that updates a timer along with some other pieces of information in an application. At some point, the timer gets cleared (perhaps by the user) but there's no code to actually clear the interval. In that case, the call to ",(0,n.jsx)(a.code,{children:"setInterval()"})," will continue to reference code that's no longer needed but can't be garbage-collected because it's still being used behind the scenes."]}),"\n",(0,n.jsx)(a.p,{children:"There are other instances when we can create memory leaks in JavaScript, but for the most part we don't need too worry about them too much as long as we follow best practices. As you can probably guess, the very best practice is to keep code as tightly scoped as possible so that the memory allocated to that code is garbage-collected as soon as it's no longer needed."})]})}function d(e={}){const{wrapper:a}={...(0,r.R)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},28453:(e,a,t)=>{t.d(a,{R:()=>s,x:()=>i});var o=t(96540);const n={},r=o.createContext(n);function s(e){const a=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function i(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),o.createElement(r.Provider,{value:a},e.children)}}}]);