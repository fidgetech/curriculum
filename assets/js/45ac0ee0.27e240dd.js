"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[95320],{14730:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>a,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"react/react-with-redux/3-3-1-2-combining-redux-reducers","title":"\ud83d\udcd3 3.3.1.2 Combining Redux Reducers","description":"Because our Help Queue is a simple application, we can handle all of our actions with a single reducer. However, what should we do once our reducers start handling multiple slices of state?","source":"@site/versioned_docs/version-WIP/3_react/3_react-with-redux/3-3-1-02-combining-redux-reducers.md","sourceDirName":"3_react/3_react-with-redux","slug":"/react/react-with-redux/3-3-1-2-combining-redux-reducers","permalink":"/WIP/react/react-with-redux/3-3-1-2-combining-redux-reducers","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 3.3.1.2 Combining Redux Reducers","day":"monday","id":"3-3-1-2-combining-redux-reducers","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\u270f\ufe0f 3.3.1.1 Redux Help Queue, Project Refactor","permalink":"/WIP/react/react-with-redux/3-3-1-1-redux-help-queue-project-refactor"},"next":{"title":"\ud83d\udcd3 3.3.1.3 Adding Combined Reducers to React","permalink":"/WIP/react/react-with-redux/3-3-1-3-adding-combined-reducers-to-react"}}');var s=r(74848),i=r(28453);const o={title:"\ud83d\udcd3 3.3.1.2 Combining Redux Reducers",day:"monday",id:"3-3-1-2-combining-redux-reducers",hide_table_of_contents:!0},c=void 0,a={},d=[{value:"Creating a New Reducer",id:"creating-a-new-reducer",level:2},{value:"Root Reducer",id:"root-reducer",level:2}];function l(e){const t={code:"code",div:"div",em:"em",h2:"h2",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"Because our Help Queue is a simple application, we can handle all of our actions with a single reducer. However, what should we do once our reducers start handling multiple slices of state?"}),"\n",(0,s.jsxs)(t.p,{children:["In this lesson, we'll create an additional reducer to handle the ",(0,s.jsx)(t.code,{children:"formVisibleOnPage"})," boolean in our React application. Then we will learn how to use Redux's ",(0,s.jsx)(t.code,{children:"combineReducers()"})," function to combine all of our individual reducers into a single root reducer."]}),"\n",(0,s.jsx)(t.p,{children:"Then, in the next lesson, we will integrate our combined reducers into our React application."}),"\n",(0,s.jsxs)(t.p,{children:["If the Help Queue were a production application, we'd probably leave ",(0,s.jsx)(t.code,{children:"formVisibleOnPage"})," as local state instead of adding it to our Redux store. However, making this change provides the simplest use case in our application for making an additional reducer, combining it, and then doing minimal refactoring in our application to get it working. On the other hand, handling ",(0,s.jsx)(t.code,{children:"selectedTicket"})," with the Redux store would require quite a bit more refactoring in our ",(0,s.jsx)(t.code,{children:"TicketControl"})," component because it is changed in so many places. You will have the chance to move all local state into Redux during class time, which is excellent practice for improving your Redux skills. As stated in prior lessons, it's fine if Redux handles local state but there's no one size fits all approach."]}),"\n",(0,s.jsx)(t.h2,{id:"creating-a-new-reducer",children:"Creating a New Reducer"}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.p,{children:"First, let's create our new reducer. We need to test it and get it working independently before we combine it with our existing reducer."}),"\n",(0,s.jsxs)(t.p,{children:["As always, we'll start with a test. Our first test will just check to make sure that the reducer can accept a boolean value (",(0,s.jsx)(t.code,{children:"false"}),") and return the default state if no action type is provided."]}),"\n",(0,s.jsxs)(t.p,{children:["We'll create a ",(0,s.jsx)(t.code,{children:"form-visible-reducer.test.js"})," file in ",(0,s.jsx)(t.code,{children:"__tests__"})," and add the following test:"]}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"__tests__/reducers/form-visible-reducer.test.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"import formVisibleReducer from '../../reducers/form-visible-reducer';\n\ndescribe(\"formVisibleReducer\", () => {\n\n  test('Should return default state if no action type is recognized', () => {\n    expect(formVisibleReducer(false, { type: null })).toEqual(false);\n  });\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We can run ",(0,s.jsx)(t.code,{children:"$ npm run test"})," and verify that our tests fails."]}),"\n",(0,s.jsx)(t.p,{children:"Now let's create our new reducer and add just enough code to make our test pass:"}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"src/reducers/form-visible-reducer.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"const reducer = (state = false, action) => {\n  return state;\n};\n\nexport default reducer;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This reducer will always return a boolean with a default state of ",(0,s.jsx)(t.code,{children:"false"}),". Our test should now pass!"]}),"\n",(0,s.jsx)(t.p,{children:"It's time to test for the next simplest behavior. Can our reducer successfully toggle between true and false?"}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"__tests__/reducers/form-visible-reducer.test.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"import formVisibleReducer from '../../reducers/form-visible-reducer';\n\ndescribe(\"formVisibleReducer\", () => {\n\n  // First test omitted for brevity.\n\n  test('Should toggle form visibility state to true', () => {\n    expect(formVisibleReducer(false, { type: 'TOGGLE_FORM' })).toEqual(true);\n  });\n\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Given a value of ",(0,s.jsx)(t.code,{children:"false"})," and an action type called ",(0,s.jsx)(t.code,{children:"'TOGGLE_FORM'"}),", our new reducer should return ",(0,s.jsx)(t.code,{children:"true"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Our test will fail as expected."}),"\n",(0,s.jsx)(t.p,{children:"Now let's add the logic to make our second test pass:"}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"src/reducers/form-visible-reducer.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"const reducer = (state = false, action) => {\n  switch (action.type) {\n  case 'TOGGLE_FORM':\n    return !state;\n  default:\n    return state;\n  }\n};\n\nexport default reducer;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["As we can see, this is a very simple reducer. If the ",(0,s.jsx)(t.code,{children:"'TOGGLE_FORM'"})," action is passed into the reducer, the boolean state will be toggled. That's all there is to it! Our test will now pass."]}),"\n",(0,s.jsx)(t.h2,{id:"root-reducer",children:"Root Reducer"}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsxs)(t.p,{children:["Our application now has two reducers. However, our ",(0,s.jsx)(t.code,{children:"store"})," can only take a single reducer as an argument."]}),"\n",(0,s.jsxs)(t.p,{children:["We'll need to create an additional reducer called a ",(0,s.jsx)(t.strong,{children:"root reducer"})," that handles the work of combining our application's reducers. It may seem like extraneous code when our application is so small, but root reducers can help us keep our code modular and allow us to create many different reducers that can handle different slices of state."]}),"\n",(0,s.jsx)(t.p,{children:"We've tested both of the reducers we've created so far and we'll have to test this one, too. After all, we have to make sure that our root reducer correctly combines state slices."}),"\n",(0,s.jsxs)(t.p,{children:["Let's create a test file at ",(0,s.jsx)(t.code,{children:"__tests__/reducers/index-reducer.test.js"}),". It's common to combine reducers in a file called ",(0,s.jsx)(t.code,{children:"reducers/index.js"})," \u2014 that's why we name our test file ",(0,s.jsx)(t.code,{children:"index-reducer.test.js"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Before we move on, we will address the naming convention. Why put the root reducer in a file called ",(0,s.jsx)(t.code,{children:"index.js"}),"?"]}),"\n",(0,s.jsxs)(t.p,{children:["When a file is responsible for retrieving logic from other files in its directory and importing it all into one big module, it's known as a ",(0,s.jsx)(t.strong,{children:"module index"}),". Our ",(0,s.jsx)(t.code,{children:"index.js"})," file will hold a root reducer that combines logic from all of our other reducer files \u2014 hence the naming convention."]}),"\n",(0,s.jsx)(t.p,{children:"Now we're ready to move on to tests. Here's our first one:"}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"__tests__/reducers/index-reducer.test.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"import rootReducer from '../../reducers/index';\n\ndescribe(\"rootReducer\", () => {\n\n  test('Should return default state if no action type is recognized', () => {\n    expect(rootReducer({}, { type: null })).toEqual({\n      mainTicketList: {},\n      formVisibleOnPage: false\n    });\n  });\n\n});\n"})}),"\n",(0,s.jsx)(t.p,{children:"As with our other reducer tests, the first \u2014 and simplest \u2014 behavior we can test is that the reducer returns the default state."}),"\n",(0,s.jsx)(t.p,{children:"The default state for our root reducer is:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"{\n  mainTicketList: {},\n  formVisibleOnPage: false\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"As we can see, it will store multiple slices of state. We could combine many reducers if we wished \u2014 and our root reducer can have many state slices."}),"\n",(0,s.jsxs)(t.p,{children:["Now it's time to actually create our root reducer. Create a new file called ",(0,s.jsx)(t.code,{children:"index.js"})," in the ",(0,s.jsx)(t.code,{children:"reducers"})," directory and add the following code:"]}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"reducers/index.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"import formVisibleReducer from './form-visible-reducer';\nimport ticketListReducer from './ticket-list-reducer';\nimport { combineReducers } from 'redux';\n\nconst rootReducer = combineReducers({\n  formVisibleOnPage: formVisibleReducer,\n  mainTicketList: ticketListReducer\n});\n\nexport default rootReducer;\n"})}),"\n",(0,s.jsx)(t.p,{children:"Our root reducer has three import statements. The first two are the reducers it needs to access. Any reducers being combined in the root reducer must be imported."}),"\n",(0,s.jsxs)(t.p,{children:["The final import statement is the ",(0,s.jsx)(t.code,{children:"combineReducers()"})," function from Redux. This is ",(0,s.jsx)(t.em,{children:"not"})," part of React Redux \u2014 this is core Redux functionality. Whenever we create a reducer that combines other reducers, we need to import this function."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"combineReducers()"})," takes an object as an argument. That object contains key-value pairs. The key represents the state slice while the value represents the reducer that handles actions related to that state slice. Our ",(0,s.jsx)(t.code,{children:"formVisibleReducer"})," handles the ",(0,s.jsx)(t.code,{children:"formVisibleOnPage"})," state slice while our ",(0,s.jsx)(t.code,{children:"ticketListReducer"})," handles the ",(0,s.jsx)(t.code,{children:"mainTicketList"})," state slice."]}),"\n",(0,s.jsxs)(t.p,{children:["And that's a root reducer. It just combines other reducers into a single file. The ",(0,s.jsx)(t.code,{children:"combineReducers()"})," function makes this process very easy. We can create as many reducers as we need, keeping our code modular and our individual files small (both coding best practices) and then use our root reducer to combine all these smaller reducers. The root reducer will then be passed into our application's store."]}),"\n",(0,s.jsxs)(t.p,{children:["We ",(0,s.jsx)(t.em,{children:"could"})," stop our testing here but something doesn't feel quite right. We haven't actually tested that our root reducer is connected to our other reducers yet."]}),"\n",(0,s.jsxs)(t.p,{children:["In this case, we don't want to retest each individual reducer's functionality again \u2014 we've already done that. Instead, we'll have some basic ",(0,s.jsx)(t.strong,{children:"smoke tests"}),". A smoke test is just a simple test to ensure the basic functionality works. It isn't comprehensive testing, but it will get the job done."]}),"\n",(0,s.jsx)(t.p,{children:"In this case, we just want to test that our root reducers will receive values from any reducers that it combines. In order to do that, we'll actually need to create a store."}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"__tests__/index-reducer.test.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"...\nimport { createStore } from 'redux';\n\nlet store = createStore(rootReducer);\n\n...\n"})}),"\n",(0,s.jsx)(t.p,{children:"In effect, we are creating a little Redux application in our tests that is separate from our React application. We are creating a store so we can dispatch a few actions and check that our reducers are working together."}),"\n",(0,s.jsx)(t.p,{children:"First, we'll add a few tests to ensure that our root reducer is returning the default state of each individual reducer:"}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"__tests__/index-reducer.test.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"import rootReducer from '../../reducers/index';\nimport { createStore } from 'redux';\nimport formVisibleReducer from '../../reducers/form-visible-reducer';\nimport ticketListReducer from '../../reducers/ticket-list-reducer';\n\n...\n\ntest('Check that initial state of ticketListReducer matches root reducer', () => {\n  expect(store.getState().mainTicketList).toEqual(ticketListReducer(undefined, { type: null }));\n});\n\ntest('Check that initial state of formVisibleReducer matches root reducer', () => {\n  expect(store.getState().formVisibleOnPage).toEqual(formVisibleReducer(undefined, { type: null }));\n});\n...\n"})}),"\n",(0,s.jsxs)(t.p,{children:["These tests are checking the same thing, first with our reducer for the ticket list and then with our reducer for form visibility: does the default state of each individual reducer (",(0,s.jsx)(t.code,{children:"mainTicketList"})," and ",(0,s.jsx)(t.code,{children:"formVisibleOnPage"}),") match the default state for each state slice in the root reducer (",(0,s.jsx)(t.code,{children:"rootReducer.mainTicketList"})," and ",(0,s.jsx)(t.code,{children:"rootReducer.formVisibleOnPage"}),")? This is part of the reason we need to instantiate a store \u2014 so we can use Redux's ",(0,s.jsx)(t.code,{children:"getState()"})," method."]}),"\n",(0,s.jsx)(t.p,{children:'These tests will pass because we\'ve already correctly created our root reducer. These are essentially "sanity checks" to make sure everything works together.'}),"\n",(0,s.jsx)(t.p,{children:"We'll do one more pair of tests. These tests will ensure that when we pass actions into our combined reducers, the root reducer reflects those changes."}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"__tests__/index-reducer.test.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"...\ntest('Check that ADD_TICKET action works for ticketListReducer and root reducer', () => {\n  const action = {\n    type: 'ADD_TICKET',\n    names: 'Ryan & Aimen',\n    location: '4b',\n    issue: 'Redux action is not working correctly.',\n    id: 1\n  }\n  store.dispatch(action);\n  expect(store.getState().mainTicketList).toEqual(ticketListReducer(undefined, action));\n});\n\ntest('Check that TOGGLE_FORM action works for formVisibleReducer and root reducer', () => {\n  const action = {\n    type: 'TOGGLE_FORM'\n  }\n  store.dispatch(action);\n  expect(store.getState().formVisibleOnPage).toEqual(formVisibleReducer(undefined, action));\n});\n...\n"})}),"\n",(0,s.jsx)(t.p,{children:"In both of these tests, we dispatch an action. We then expect our root reducer to properly handle those actions by passing them into our individual reducers. The store's state slice should be updated accordingly \u2014 and should be equal to the return result of the individual reducer that handled the action."}),"\n",(0,s.jsx)(t.p,{children:"Now that we've set up and tested a root reducer, we are ready to update our React application to use it! We'll do that in the next lesson."})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,t,r)=>{r.d(t,{R:()=>o,x:()=>c});var n=r(96540);const s={},i=n.createContext(s);function o(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);