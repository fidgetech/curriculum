"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[95639],{16740:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"intermediate-javascript/asynchrony-and-apis/2-3-1-3-introduction-to-promises","title":"\ud83d\udcd3 2.3.1.3 Introduction to Promises","description":"ES2015 (also known as ES6) added a lot of great functionality to JavaScript. We\'ve already learned about many of the most popular features, including let and const, classes, template literals, and destructuring. Now it\'s time to learn about promises, another great addition from ES6.","source":"@site/versioned_docs/version-WIP/2_intermediate-javascript/3_asynchrony-and-apis/2-3-1-03-introduction-to-promises.md","sourceDirName":"2_intermediate-javascript/3_asynchrony-and-apis","slug":"/intermediate-javascript/asynchrony-and-apis/2-3-1-3-introduction-to-promises","permalink":"/WIP/intermediate-javascript/asynchrony-and-apis/2-3-1-3-introduction-to-promises","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 2.3.1.3 Introduction to Promises","day":"monday","id":"2-3-1-3-introduction-to-promises","hide_table_of_contents":true},"sidebar":"intermediate-javascript","previous":{"title":"\ud83d\udcd3 2.3.1.2 Tools for Handling Async Code","permalink":"/WIP/intermediate-javascript/asynchrony-and-apis/2-3-1-2-tools-for-handling-async-code"},"next":{"title":"\ud83d\udcd3 2.3.1.4 Promises with API Calls","permalink":"/WIP/intermediate-javascript/asynchrony-and-apis/2-3-1-4-promises-with-api-calls"}}');var s=o(74848),i=o(28453);const r={title:"\ud83d\udcd3 2.3.1.3 Introduction to Promises",day:"monday",id:"2-3-1-3-introduction-to-promises",hide_table_of_contents:!0},a=void 0,l={},c=[{value:"Working with Promises",id:"working-with-promises",level:2},{value:"A Demonstration",id:"a-demonstration",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["ES2015 (also known as ES6) added a lot of great functionality to JavaScript. We've already learned about many of the most popular features, including ",(0,s.jsx)(t.code,{children:"let"})," and ",(0,s.jsx)(t.code,{children:"const"}),", classes, template literals, and destructuring. Now it's time to learn about promises, another great addition from ES6."]}),"\n",(0,s.jsx)(t.p,{children:"A promise allows us to wrap async code and then wait for the result of that code before moving on. In this lesson, we'll discuss why promises are so useful and how we can use them to tidy up our async code."}),"\n",(0,s.jsxs)(t.p,{children:["Promises have been a key concept in JavaScript development for quite some time, but up until ES6, they weren't native to JS. Instead, developers relied on promise libraries like Bluebird.js or used jQuery's ",(0,s.jsx)(t.code,{children:"then()"})," method. Some developers still prefer to use promise libraries instead of ES6's native functionality because these libraries have more features or are potentially more efficient than ES6 promises."]}),"\n",(0,s.jsx)(t.h2,{id:"working-with-promises",children:"Working with Promises"}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.p,{children:"Before we dive into the async aspects of promises, it's important to cover some basic things about what a promise is."}),"\n",(0,s.jsxs)(t.p,{children:["First of all, a promise is just an object that inherits a few prototypal methods. Remember all that work we did just a few sections ago on JavaScript objects? Well, we can apply that knowledge now, which means we already know something about promises. At this point, we know that the first thing we have to do when we are working with JavaScript objects is create an instance of the object we want to work with, just like we did with the ",(0,s.jsx)(t.code,{children:"XMLHttpRequest"})," object. Once we do that, we'll be able to use the object as well as any methods that are reserved for that type of object."]}),"\n",(0,s.jsx)(t.p,{children:"So on the most basic level, that's all a promise is: an object."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"let promise = new Promise();\n"})}),"\n",(0,s.jsxs)(t.p,{children:["A promise generally takes a function as an argument. This function will hold our async code and it has two parameters, ",(0,s.jsx)(t.code,{children:"resolve"})," and ",(0,s.jsx)(t.code,{children:"reject"}),". So let's update our object a little bit."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"let promise = new Promise(function(resolve, reject) { \n  // async code goes here\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We always need to include the ",(0,s.jsx)(t.code,{children:"resolve"})," and ",(0,s.jsx)(t.code,{children:"reject"})," parameters. Why? Well, we have to decide what determines whether a promise is resolved or rejected. JavaScript can't just look at a function that's making an API call and figure out what it's supposed to do with it. In the case of our API call, our promise needs to look something like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"// Some pseudocode added... these variable names are just to demonstrate how a promise works.\n\nlet promise = new Promise(function(resolve, reject) {\n  if (apiCallSuccessful) {\n    resolve(data)\n  } else {\n    reject(message)\n  }\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In the example above, we've added a conditional. If ",(0,s.jsx)(t.code,{children:"apiCallSuccessful"})," is ",(0,s.jsx)(t.code,{children:"true"}),", our promise will ",(0,s.jsx)(t.code,{children:"resolve"}),". We'll pass the ",(0,s.jsx)(t.code,{children:"data"})," from the API call along. Otherwise, our promise will ",(0,s.jsx)(t.code,{children:"reject"})," and we'll pass a ",(0,s.jsx)(t.code,{children:"message"})," along."]}),"\n",(0,s.jsx)(t.p,{children:"Think of it as being a little bit like a gift. It won't be ready until your birthday. When it's opened, it will be resolved (\"I like it!\") or rejected (\"I don't like it.\"). Our response will then be passed along to be used where it's needed."}),"\n",(0,s.jsxs)(t.p,{children:["So if we look at the example above, the ",(0,s.jsx)(t.code,{children:"promise"})," variable is a ",(0,s.jsx)(t.code,{children:"Promise"})," object that holds a function with two parameters: ",(0,s.jsx)(t.code,{children:"resolve"})," and ",(0,s.jsx)(t.code,{children:"reject"}),". When this function is actually called, the promise can be in one of three states:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Pending"}),": The object's initial state. A pending operation has been started but hasn't been completed yet."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Fulfilled"}),": A promise is fulfilled when the operation has been successfully completed."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Rejected"}),":  A promise is rejected when the operation fails."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Once again, ",(0,s.jsx)(t.em,{children:"we"})," need to determine what it means for the promise to succeed (fulfilled) or fail (rejected)."]}),"\n",(0,s.jsxs)(t.p,{children:["It's also important to remember that ",(0,s.jsx)(t.strong,{children:"a promise can only be resolved once"}),". Once it's rejected or fulfilled, there's no going back. For instance, you can't try to turn a rejected promise into a fulfilled one. Instead, you'd have to create another promise and try again."]}),"\n",(0,s.jsx)(t.p,{children:"Let's use one more analogy to explain the process. Imagine you're waiting to renew your driver's license at the DMV. When you go in, you get a piece of paper with a number on it. You wait until your number is called and then you go to the counter to renew your license."}),"\n",(0,s.jsxs)(t.p,{children:["That piece of paper is similar to a promise. It represents an appointment you'll have in the future, but that appointment doesn't exist yet. While you're waiting for your number to be called, the promise is ",(0,s.jsx)(t.strong,{children:"pending"}),". The promise will either be ",(0,s.jsx)(t.strong,{children:"fulfilled"})," (driver's license renewed...yay!) or ",(0,s.jsx)(t.strong,{children:"rejected"})," (you forgot to bring the right documents with which to renew your license...)."]}),"\n",(0,s.jsxs)(t.p,{children:["Once the promise is either fulfilled or rejected, it is complete and becomes immutable. An ",(0,s.jsx)(t.strong,{children:"immutable"})," value can't be changed. A promise is a one-off situation and we can't use it again. Returning to the analogy of getting a license, once that ticket is resolved, it can't be used again. If you want to do something else at the DMV, you'll have to get a new ticket (which represents a new promise)."]}),"\n",(0,s.jsx)(t.p,{children:"So how do we actually access and deal with this data and determine whether it's fulfilled or rejected?"}),"\n",(0,s.jsxs)(t.p,{children:["Promise objects have just three methods \u2014 we only need to know about two of them: ",(0,s.jsx)(t.code,{children:"Promise.prototype.then()"})," and ",(0,s.jsx)(t.code,{children:"Promise.prototype.catch()"}),". As you might guess, the latter method is used to handle errors that come up in promises."]}),"\n",(0,s.jsxs)(t.p,{children:["We can do the following with our ",(0,s.jsx)(t.code,{children:"promise"})," variable:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"promise.then(function(response) {\n  doSomething(response);\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["When we call ",(0,s.jsx)(t.code,{children:"Promise.prototype.then()"}),", the function inside the promise is triggered and the promise is now in a ",(0,s.jsx)(t.strong,{children:"pending"})," state. Any code passed into ",(0,s.jsx)(t.code,{children:"Promise.prototype.then()"})," will ",(0,s.jsx)(t.em,{children:"not"})," run yet. That code won't be triggered until the promise is fulfilled or rejected. If our promise is resolved, our callback will be triggered, and the ",(0,s.jsx)(t.code,{children:"doSomething"})," function will be called. As we can see here, we'll still be working with callbacks even when we use promises."]}),"\n",(0,s.jsx)(t.p,{children:"What happens if our promise is rejected? Well, we aren't handling that yet. We have to add an additional function to handle the rejection:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"promise.then(function(success) {\n  doSomething(success);\n}, function(failure) {\n  itFailed(failure);\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Note that we put a ",(0,s.jsx)(t.code,{children:","})," after the first closing curly bracket ",(0,s.jsx)(t.em,{children:"and then"})," we add another function for rejection. The final closing parens then comes ",(0,s.jsx)(t.em,{children:"after"})," the second function. Why does this look so weird?"]}),"\n",(0,s.jsxs)(t.p,{children:["Well, ",(0,s.jsx)(t.code,{children:"Promise.prototype.then()"})," takes up to two callback functions as arguments. This is a really cool thing about JavaScript and something that can be hard for beginners to wrap their heads around. Functions are ",(0,s.jsx)(t.em,{children:"first class citizens"}),", which means they can be passed around as variables and arguments. We will be discussing that in greater detail once we get to the React course."]}),"\n",(0,s.jsxs)(t.p,{children:["So just remember that the first argument to ",(0,s.jsx)(t.code,{children:"Promise.prototype.then()"})," is the function that runs if the promise is fulfilled and the second (optional) argument is the function that runs if the promise is rejected. You might wonder why the second function is optional \u2014 well, as a developer, you might want to do nothing if the promise is rejected. In this course section, we'll always include some form of error handling."]}),"\n",(0,s.jsxs)(t.p,{children:["Another important thing to note about the example above: ",(0,s.jsx)(t.code,{children:"success"})," and ",(0,s.jsx)(t.code,{children:"failure"})," are just parameters of the functions and we can call them whatever we want. JavaScript doesn't care. We could call them both ",(0,s.jsx)(t.code,{children:"response"})," but that's not very descriptive. It's common to call the parameter for a fulfilled promise ",(0,s.jsx)(t.code,{children:"response"})," and the parameter for a rejected promise ",(0,s.jsx)(t.code,{children:"error"})," \u2014 because when a promise is rejected, it often means there was an error. But once again, remember that you get to choose what they're called \u2014 just make sure that parameters, like other variables, have concise, descriptive names."]}),"\n",(0,s.jsx)(t.h3,{id:"a-demonstration",children:"A Demonstration"}),"\n",(0,s.jsx)(t.p,{children:"So now that we know the basics of what a promise looks like, let's write a very silly one to illustrate exactly how they work. The function in this promise will generate a random number \u2014 either 0 or 1. If the value is 1, the promise will be resolved. If the value is 0, the promise will be rejected."}),"\n",(0,s.jsx)(t.p,{children:"This is a silly use case because we are using a promise to handle synchronous code. In the real world, we'd never do that \u2014 promises are for handing async code. However, the point of this example is to demonstrate how promises work before we introduce more complex async code. This way, we can see exactly how to create a promise, use it, and then handle its response."}),"\n",(0,s.jsx)(t.p,{children:"Try out the following example in the DevTools console:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'let promise = new Promise(function(resolve, reject) {\n\tconst value = Math.floor(Math.random() * Math.floor(2))\n\tif (value === 1) {\n\t\tresolve("The value is 1!");\n\t} else {\n\t\treject("The value is 0.");\n\t}\n});\n\npromise.then(function(resolvedResponse) {\n\tconsole.log("resolved!")\n\tconsole.log(resolvedResponse);\n}, function(rejectedResponse) {\n\tconsole.log("rejected!");\n\tconsole.log(rejectedResponse);\n});\n'})}),"\n",(0,s.jsxs)(t.p,{children:["First, we create a new promise and store it in a ",(0,s.jsx)(t.code,{children:"promise"})," variable. ",(0,s.jsx)(t.code,{children:"Math.floor(Math.random() * Math.floor(2))"})," just randomly generates either the value 0 or 1. Then, we use a conditional to determine when the promise should be considered resolved or rejected. As we can see, we determine the exact conditions. It doesn't matter if it's a simple synchronous example like the one above or really complex async code."]}),"\n",(0,s.jsxs)(t.p,{children:["Next, we use ",(0,s.jsx)(t.code,{children:"Promise.prototype.then()"})," to determine how to handle both a ",(0,s.jsx)(t.code,{children:"resolvedResponse"})," and a ",(0,s.jsx)(t.code,{children:"rejectedResponse"}),". Note the descriptive parameter names \u2014 maybe not as concise as we'd like but solid for educational purposes."]}),"\n",(0,s.jsxs)(t.p,{children:["Next, we use ",(0,s.jsx)(t.code,{children:"console.log()"})," to let us know whether the promise was resolved or rejected. We also log the message that's passed from the promise into ",(0,s.jsx)(t.code,{children:"Promise.prototype.then()"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Try it out in the console. If the promise is resolved, we'll get the following:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"resolved!\nThe value is 1!\nPromise\xa0{<fulfilled>: undefined}\n"})}),"\n",(0,s.jsx)(t.p,{children:"If it's rejected, we'll get this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"rejected!\nThe value is 0.\nPromise\xa0{<fulfilled>: undefined}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["But what's that third line? We didn't ",(0,s.jsx)(t.code,{children:"console.log()"})," that, did we? ",(0,s.jsx)(t.code,{children:"Promise.prototype.then()"})," returns another promise \u2014 this is the ",(0,s.jsx)(t.em,{children:"return"})," of our method. This is absolutely essential because it allows us to chain multiple promises together, waiting until one resolves before starting the next one."]}),"\n",(0,s.jsx)(t.p,{children:"Once again, don't ever use promises for synchronous code \u2014 it's bad practice. We've already stated this but it's worth emphasizing. The example above is for learning purposes only."}),"\n",(0,s.jsxs)(t.p,{children:["One other thing \u2014 if you are trying the code snippet above multiple times without refreshing the console, you might be wondering what exactly is happening. Can't a promise be resolved only once? Yes. But each time we call the code snippet above, we are creating a ",(0,s.jsx)(t.em,{children:"new"})," promise variable with a new promise in it \u2014 ",(0,s.jsx)(t.code,{children:"let"})," allows us to do that. However, if we were just to run this part of the code again:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'promise.then(function(resolvedResponse) {\n\tconsole.log("resolved!")\n\tconsole.log(resolvedResponse);\n}, function(rejectedResponse) {\n\tconsole.log("rejected!");\n\tconsole.log(rejectedResponse);\n});\n'})}),"\n",(0,s.jsx)(t.p,{children:"The promise will be fulfilled once, then each time we run the code again, we'd get the exact same response \u2014 the already fulfilled promise."}),"\n",(0,s.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.p,{children:"Now that we've gone through an example and covered promises in detail, let's summarize how they work:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"We can wrap our async code in a promise."}),"\n",(0,s.jsx)(t.li,{children:"Next, we can tell our function when it should resolve or reject, giving us fine-grained control over how JavaScript should handle our async code."}),"\n",(0,s.jsxs)(t.li,{children:["Finally, we can use ",(0,s.jsx)(t.code,{children:"Promise.prototype.then()"})," to run code once the async operation is complete \u2014 no need to keep tabs on the promise! JavaScript will do that for us."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Promise.prototype.then()"})," takes up to two functions as arguments \u2014 the first (required) function determines what happens if a promise is fulfilled while the second (optional) function determines what happens if the promise is rejected."]}),"\n",(0,s.jsxs)(t.li,{children:["We can even chain promises together because ",(0,s.jsx)(t.code,{children:"Promise.prototype.then()"})," itself returns a promise. We'll learn more about that later in this section, though it's not required to do any chaining for the independent project."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["There are a few other useful methods related to promises as well, none of which you need to use in this section. However, it's good to know about them and you may want to try them out during a class project. For instance, we can use ",(0,s.jsx)(t.code,{children:"Promise.all()"})," to work with multiple promises:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"Promise.all([promise1, promise2, promise3]);\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"Promise.all()"})," wraps the enclosed promises into a single giant promise that only resolves after each of the included promises are resolved."]}),"\n",(0,s.jsxs)(t.p,{children:["There are a few other methods such as ",(0,s.jsx)(t.code,{children:"Promise.race()"})," and ",(0,s.jsx)(t.code,{children:"Promise.catch()"}),". Check out Mozilla's documentation on ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",children:"promises"})," to learn more."]}),"\n",(0,s.jsx)(t.p,{children:"Now that we've explained the basics of how a promise works, we're ready to add one to our code. In the next lesson, we'll use a promise to handle the results of an API call."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,t,o)=>{o.d(t,{R:()=>r,x:()=>a});var n=o(96540);const s={},i=n.createContext(s);function r(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);