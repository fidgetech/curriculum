"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[11383],{16118:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"c-and-net/many-to-many-relationships/5-4-0-3-code-first-development-and-migrations","title":"\ud83d\udcd3 5.4.0.3 Code First Development and Migrations","description":"So far, we\'ve manually created and updated our database using MySQL Workbench. However, this approach isn\'t very effective for a large production application where many developers are collaborating together. Let\'s say we have many different teams that are working on different features in an application and we\'re working on a team that makes changes to the database. How can we convey the changes to other teams working on the application? We\'d need to give everyone exact instructions on the changes we made, which could get tedious fast, especially if we\'re making a lot of changes.","source":"@site/versioned_docs/version-WIP/c-and-net/4_many-to-many-relationships/3-4-0-03-code-first-development-and-migrations.md","sourceDirName":"c-and-net/4_many-to-many-relationships","slug":"/c-and-net/many-to-many-relationships/5-4-0-3-code-first-development-and-migrations","permalink":"/WIP/c-and-net/many-to-many-relationships/5-4-0-3-code-first-development-and-migrations","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 5.4.0.3 Code First Development and Migrations","day":"weekend","id":"5-4-0-3-code-first-development-and-migrations","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 5.4.0.2 Many-to-Many Relationship Review","permalink":"/WIP/c-and-net/many-to-many-relationships/5-4-0-2-many-to-many-relationship-review"},"next":{"title":"\ud83d\udcd3 5.4.0.4 Many-to-Many Relationships: Join Entities","permalink":"/WIP/c-and-net/many-to-many-relationships/5-4-0-4-many-to-many-relationships-join-entities"}}');var a=o(74848),i=o(28453);const r={title:"\ud83d\udcd3 5.4.0.3 Code First Development and Migrations",day:"weekend",id:"5-4-0-3-code-first-development-and-migrations",hide_table_of_contents:!0},s=void 0,d={},c=[{value:"To Do List Refactor Plan",id:"to-do-list-refactor-plan",level:2},{value:"Database Migrations",id:"database-migrations",level:2},{value:"Installing Tools",id:"installing-tools",level:3},{value:"Creating a Migration",id:"creating-a-migration",level:3},{value:"The <code>Migrations</code> Directory",id:"the-migrations-directory",level:3},{value:"Updating the Database with the Migration",id:"updating-the-database-with-the-migration",level:3}];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",hr:"hr",i:"i",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"So far, we've manually created and updated our database using MySQL Workbench. However, this approach isn't very effective for a large production application where many developers are collaborating together. Let's say we have many different teams that are working on different features in an application and we're working on a team that makes changes to the database. How can we convey the changes to other teams working on the application? We'd need to give everyone exact instructions on the changes we made, which could get tedious fast, especially if we're making a lot of changes."}),"\n",(0,a.jsx)(t.p,{children:"It's very common for a database to change over time. In fact, in large projects, there may be hundreds or even thousands of changes to a database over the course of a project. It would be very tedious to make all those changes in MySQL Workbench or another database tool."}),"\n",(0,a.jsxs)(t.p,{children:["Fortunately, EF Core provides a solution for this. We can use ",(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli",children:(0,a.jsx)(t.strong,{children:"migrations"})})," to create a new database or update an existing database based on our code. Migrations are a common feature of many frameworks, including Rails, which uses Active Record. So in this lesson, we're going to learn about database migrations, how to create them, and install the tools necessary for the job. The instructions in this lesson can be applied to any other project you create."]}),"\n",(0,a.jsx)(t.h2,{id:"to-do-list-refactor-plan",children:"To Do List Refactor Plan"}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsxs)(t.p,{children:["In this lesson, we'll begin to refactor our To Do List app to use EF Core migrations. We'll build off of the To Do List app that we completed by the end of the last course section. You are welcome to continue building off your own project on a new branch or save your changes to a new repo. Or, you are welcome to use the main branch of the following repo as a ",(0,a.jsx)(t.strong,{children:"starter project"}),":"]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:(0,a.jsxs)(t.a,{href:"https://github.com/epicodus-lessons/section-4-to-do-list-with-many-to-many-csharp-net6/tree/1_starter_project",children:[(0,a.jsx)(t.i,{className:"glyphicon glyphicon-folder-open"}),"  Starter GitHub Repo for To Do List with EF Core Migrations and a Many-to-Many Relationship"]})})}),"\n",(0,a.jsxs)(t.p,{children:["Before proceeding, make sure to update the name of your database in ",(0,a.jsx)(t.code,{children:"appsettings.json"})," to reflect the new project we are building. In the lessons, we'll use the name ",(0,a.jsx)(t.code,{children:"to_do_list_with_many_to_many"}),", but you can pick whatever you prefer:"]}),"\n",(0,a.jsx)(t.div,{className:"filename",children:"ToDoList/appsettings.json"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-json",children:'{\n  "ConnectionStrings": {\n    "DefaultConnection": "Server=localhost;Port=3306;database=to_do_list_with_many_to_many;uid=root;pwd=epicodus;"\n  }\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"database-migrations",children:"Database Migrations"}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsxs)(t.p,{children:["A ",(0,a.jsx)(t.strong,{children:"migration"})," is simply a file that describes an update to the database. When we use EF Core to develop and manage our database from our project's codebase, we define how our database should be structured using our project's models and the ",(0,a.jsx)(t.code,{children:"DbContext"})," class. Part of this involves telling EF Core to create a migration. When a migration is created, EF Core reviews our project's models and creates a file that describes how our database should be structured based on our models. Each migration is a snapshot of how our database should be structured, and every time we make changes to our entities (our project's models like ",(0,a.jsx)(t.code,{children:"Item"})," and ",(0,a.jsx)(t.code,{children:"Category"}),"), we need to make a new migration so that EF Core knows how to update our database."]}),"\n",(0,a.jsx)(t.p,{children:"A large project could have thousands of migrations. In order to recreate the database schema, a developer simply needs to run a command and all the migrations will run sequentially, updating the database to its current state. This can make our programs more flexible and significantly speed up the time it takes to make changes to our database."}),"\n",(0,a.jsx)(t.h3,{id:"installing-tools",children:"Installing Tools"}),"\n",(0,a.jsxs)(t.p,{children:["For Entity Framework Core, we use a tool called ",(0,a.jsx)(t.code,{children:"dotnet-ef"})," to create migrations and update our database. We'll install this tool globally so that it is always available in all of our projects. Run the following command in your terminal now:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"$ dotnet tool install --global dotnet-ef --version 6.0.0\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Optionally, you can read more about the ",(0,a.jsx)(t.code,{children:"dotnet ef"})," tool ",(0,a.jsx)(t.a,{href:"https://docs.microsoft.com/en-us/ef/core/cli/dotnet",children:"on the docs"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["In order to use ",(0,a.jsx)(t.code,{children:"dotnet-ef"}),", we also need to install the ",(0,a.jsx)(t.code,{children:"Microsoft.EntityFrameworkCore.Design"})," package in our ASP.NET Core projects. Within the production directory of our To Do List app, run the following command:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"$ dotnet add package Microsoft.EntityFrameworkCore.Design -v 6.0.0\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"Microsoft.EntityFrameworkCore.Design"})," package adds tooling to our project so that EF Core can find our  DbContext (for example, ",(0,a.jsx)(t.code,{children:"ToDoListContext.cs"}),") during ",(0,a.jsx)(t.strong,{children:"design time"}),". According to the ",(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/ef/core/cli/dbcontext-creation?tabs=dotnet-core-cli",children:"official documentation"}),":"]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"Some of the EF Core Tools commands (for example, the Migrations commands) require a derived DbContext instance to be created at design time in order to gather details about the application's entity types and how they map to a database schema."}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["We're familiar with the term ",(0,a.jsx)(t.strong,{children:"run time"}),", when we run our application with ",(0,a.jsx)(t.code,{children:"dotnet watch run"}),"; but what exactly is ",(0,a.jsx)(t.strong,{children:"design time"}),"? It's the time when we are actually writing and designing our code. As noted in the quote above, we need to add tools for EF Core to access our DbContext at design time so that our migrations (the model of our database) can be created and applied (when we update the database with ",(0,a.jsx)(t.code,{children:"dotnet ef database update"}),")."]}),"\n",(0,a.jsxs)(t.p,{children:["Note that installing the ",(0,a.jsx)(t.code,{children:"Microsoft.EntityFrameworkCore.Design"})," package is all we need to do in order to give EF Core access to our DbContext at design time. However, we can create a ",(0,a.jsx)(t.code,{children:"DesignTimeDbContextFactory"})," class in our application with which we can configure additional design time services to run. We won't be doing this in our applications. To optionally learn more, visit the following Microsoft (MS) documentation:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/ef/core/cli/dbcontext-creation?tabs=dotnet-core-cli",children:"Design-time DbContext Creation"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/ef/core/cli/services",children:"Design-time Services"})}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Next, let's look at how to create a database migration. We're not going to do this now, but instead in the next lesson, once all of the necessary setup is in place in our To Do List application."}),"\n",(0,a.jsx)(t.h3,{id:"creating-a-migration",children:"Creating a Migration"}),"\n",(0,a.jsxs)(t.p,{children:["Next, let's learn the command we need to run in order to create a migration. The following command should be run in the project's production directory. For our To Do List app, this is the ",(0,a.jsx)(t.code,{children:"ToDoList"})," project directory. Go ahead and run this command now:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"$ dotnet ef migrations add Initial\n"})}),"\n",(0,a.jsxs)(t.p,{children:["When we run the above command, a new migration will be created with the name ",(0,a.jsx)(t.code,{children:"Initial"})," in a new folder called ",(0,a.jsx)(t.code,{children:"Migrations"}),". If this is the first migration in a project, EF Core will automatically generate a ",(0,a.jsx)(t.code,{children:"Migrations"})," folder in the root directory. Note that we can name our migration anything we want, but it's common for the first migration to contain the word ",(0,a.jsx)(t.code,{children:"Initial"})," or something like it. Also note that migration names should be in upper camel case."]}),"\n",(0,a.jsxs)(t.p,{children:["When naming subsequent migrations, start with a verb to describe the change that the migration will make to the database. The migration name can be used like a commit message in a version control system, like ",(0,a.jsx)(t.code,{children:"AddItemsPriority"})," if we wanted to add a priority property to our items table. So, the entire command would look like this:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"$ dotnet ef migrations add AddItemsPriority\n"})}),"\n",(0,a.jsxs)(t.p,{children:["When we create our migration, EF Core will automatically generate code for how the database should look based on the code that is in our models. Using migrations is often called using ",(0,a.jsx)(t.strong,{children:"code first migrations"})," because we will use our entity framework models in our project's code as the source of truth for our database."]}),"\n",(0,a.jsxs)(t.p,{children:["The alternative to migrations is using the database as the source of truth and scaffolding our code based on the database; this is called ",(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/ef/core/managing-schemas/scaffolding/?tabs=dotnet-core-cli",children:(0,a.jsx)(t.strong,{children:"reverse engineering"})})," and we won't be using this method in the course."]}),"\n",(0,a.jsxs)(t.h3,{id:"the-migrations-directory",children:["The ",(0,a.jsx)(t.code,{children:"Migrations"})," Directory"]}),"\n",(0,a.jsxs)(t.p,{children:["For each migration, EF Core will create three files in the ",(0,a.jsx)(t.code,{children:"Migrations"})," directory:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"[Timestamp]_Initial.cs\n[Timestamp]_Initial.Designer.cs\nMyContextModelSnapshot.cs\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Note that ",(0,a.jsx)(t.code,{children:"[Timestamp]"})," will vary based on when the migration was created and ",(0,a.jsx)(t.code,{children:"Initial"})," will be different based on the name of the migration."]}),"\n",(0,a.jsx)(t.p,{children:"The second file is metadata that EF Core needs while the third file is a snapshot of the database for Entity. We won't touch these two files."}),"\n",(0,a.jsxs)(t.p,{children:["The first file, though, can be edited. Here's an example of the ",(0,a.jsx)(t.code,{children:"[Timestamp]_Initial.cs"})," migration file that we can edit (",(0,a.jsx)(t.em,{children:"this is an example only"}),"):"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"using Microsoft.EntityFrameworkCore.Migrations;\n\nnamespace ToDoList.Migrations\n{\n    public partial class Initial : Migration\n    {\n        protected override void Up(MigrationBuilder migrationBuilder)\n        {\n            ...\n        }\n\n        protected override void Down(MigrationBuilder migrationBuilder)\n        {\n            ...\n        }\n    }\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The migration contains two methods: ",(0,a.jsx)(t.code,{children:"Up"})," and ",(0,a.jsx)(t.code,{children:"Down"}),". In an ideal world, EF Core will create a perfect scaffold of the migration for us based on our models. However, this isn't always the case. We can add further modifications to the ",(0,a.jsx)(t.code,{children:"Up"})," method. The ",(0,a.jsx)(t.code,{children:"Down"})," method provides instructions for reversing the migration if we decide to revert to the previous migration."]}),"\n",(0,a.jsx)(t.p,{children:"We will generally rely on EF Core to take care of migration scaffolding for us, but it's important to be aware that these migrations can be fine-tuned further by modifying the migration file."}),"\n",(0,a.jsx)(t.h3,{id:"updating-the-database-with-the-migration",children:"Updating the Database with the Migration"}),"\n",(0,a.jsx)(t.p,{children:"Once we have verified that the migration looks correct and made any necessary changes, we'll run the following command to update our database"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"$ dotnet ef database update\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Just like with ",(0,a.jsx)(t.code,{children:"dotnet ef migrations add [MigrationName]"}),", we need to run the above command in the production directory of our project. Do so now in the ",(0,a.jsx)(t.code,{children:"ToDoList"})," production directory."]}),"\n",(0,a.jsxs)(t.p,{children:["Running ",(0,a.jsx)(t.code,{children:"dotnet ef database update"})," will automatically update our database to reflect the changes listed in our migrations. There is no longer any need for us to directly modify the database in MySQL Workbench! Go ahead and check MySQL Workbench now and look for the newly created ",(0,a.jsx)(t.code,{children:"to_do_list_with_many_to_many"})," database."]}),"\n",(0,a.jsxs)(t.p,{children:["Remember that migrations provide a record of how our database changes. If we make unwanted changes to our database, we should always use a ",(0,a.jsx)(t.strong,{children:"new"})," migration (or several migrations) to reverse the changes. This helps ensure that our data is safe and that the log of our migrations match the code in our migration files. It also makes it easy to make changes to a database in a large project where many developers are collaborating. We can push our migrations to GitHub and then another developer can pull our updates and run the migrations with a single command."]}),"\n",(0,a.jsx)(t.p,{children:"There is one exception to the rule above: let's say that we made a mistake with our most recent migration and we haven't pushed the changes to GitHub. In this case, we can use the following command to revert the migration:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"$ dotnet ef migrations remove\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Note that if you've already updated your database with the migration that you want to remove, you'll need to run ",(0,a.jsx)(t.code,{children:"dotnet ef database update"})," after you remove the last migration with ",(0,a.jsx)(t.code,{children:"dotnet ef migrations remove"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["For more information on migrations in EF Core, see ",(0,a.jsx)(t.a,{href:"https://docs.microsoft.com/en-us/ef/core/managing-schemas/migrations/",children:"the official documentation"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Up next, we'll learn how to create a many-to-many association."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},28453:(e,t,o)=>{o.d(t,{R:()=>r,x:()=>s});var n=o(96540);const a={},i=n.createContext(a);function r(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);