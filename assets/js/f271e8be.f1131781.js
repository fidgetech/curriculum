"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[79615],{21991:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"react/react-with-redux/4-3-0-2-introduction-to-redux","title":"\ud83d\udcd3 4.3.0.2 Introduction to Redux","description":"State in React applications can get complicated very quickly. Fortunately, React community members have developed open-source tools to make managing state easier. In this course section, we\'ll focus on learning Redux, which is one of the most popular tools for managing state in React.","source":"@site/docs/4_react/3_react-with-redux/4-3-0-02-introduction-to-redux.md","sourceDirName":"4_react/3_react-with-redux","slug":"/react/react-with-redux/4-3-0-2-introduction-to-redux","permalink":"/v1.2/react/react-with-redux/4-3-0-2-introduction-to-redux","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 4.3.0.2 Introduction to Redux","day":"weekend","id":"4-3-0-2-introduction-to-redux","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 4.3.0.1 React with Redux Objectives","permalink":"/v1.2/react/react-with-redux/4-3-0-1-react-with-redux-objectives"},"next":{"title":"\ud83d\udcd3 4.3.0.3 Setting Up Our First Project","permalink":"/v1.2/react/react-with-redux/4-3-0-3-setting-up-our-first-project"}}');var o=n(74848),i=n(28453);const r={title:"\ud83d\udcd3 4.3.0.2 Introduction to Redux",day:"weekend",id:"4-3-0-2-introduction-to-redux",hide_table_of_contents:!0},a=void 0,c={},d=[{value:"Introduction to Redux",id:"introduction-to-redux",level:2},{value:"Three Principles of Redux",id:"three-principles-of-redux",level:2},{value:"1. Single Source of Truth",id:"1-single-source-of-truth",level:3},{value:"2. State is Read-Only",id:"2-state-is-read-only",level:3},{value:"3. Changes are Made with Pure Functions",id:"3-changes-are-made-with-pure-functions",level:3},{value:"Anatomy of Redux",id:"anatomy-of-redux",level:2},{value:"Stores",id:"stores",level:3},{value:"Reducers",id:"reducers",level:3},{value:"Actions",id:"actions",level:3}];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",p:"p",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["State in React applications can get complicated very quickly. Fortunately, React community members have developed open-source tools to make managing state easier. In this course section, we'll focus on learning ",(0,o.jsx)(t.strong,{children:"Redux"}),", which is one of the most popular tools for managing state in React."]}),"\n",(0,o.jsx)(t.h2,{id:"introduction-to-redux",children:"Introduction to Redux"}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.a,{href:"https://github.com/gaearon",children:"Dan Abramov"})," and ",(0,o.jsx)(t.a,{href:"https://github.com/acdlite",children:"Andrew Clark"})," developed the open-source library ",(0,o.jsx)(t.strong,{children:"Redux"})," in 2015. As explained in the ",(0,o.jsx)(t.a,{href:"http://redux.js.org/docs/introduction/Motivation.html",children:"Redux documentation"}),", their goal was to simplify managing complex state:"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"As the requirements for JavaScript single-page applications have become increasingly complicated, our code must manage more state than ever before..."}),"\n"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Managing this ever-changing state is hard."})," If a model can update another model, then a view can update a model, which updates another model, and this, in turn, might cause another view to update. At some point, ",(0,o.jsxs)(t.strong,{children:["you no longer understand what happens in your app as you have lost control over the ",(0,o.jsx)(t.em,{children:"when, why,"})," and ",(0,o.jsx)(t.em,{children:"how"})," of its state"]}),"..."]}),"\n"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:["As if this wasn't bad enough, consider the new requirements becoming common in front-end product development. As developers, we are expected to handle optimistic updates, server-side rendering, fetching data before performing route transitions, and so on. ",(0,o.jsx)(t.strong,{children:"We find ourselves trying to manage a complexity that we have never had to deal with before"}),"..."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"The documentation continues on to describe how Redux aims to simplify all this:"}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:["Redux attempts to make state mutations predictable by imposing certain ",(0,o.jsx)(t.strong,{children:"restrictions on how and when updates can happen"}),"."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Essentially, Redux enforces a specific structure as well as conventions for state."}),"\n",(0,o.jsx)(t.h2,{id:"three-principles-of-redux",children:"Three Principles of Redux"}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsxs)(t.p,{children:["As outlined in the ",(0,o.jsx)(t.a,{href:"http://redux.js.org/docs/introduction/ThreePrinciples.html",children:"Three Principles"})," section of its documentation, Redux enforces state management with three main rules:"]}),"\n",(0,o.jsx)(t.h3,{id:"1-single-source-of-truth",children:"1. Single Source of Truth"}),"\n",(0,o.jsxs)(t.p,{children:["In a Redux application, state must be stored as an object tree in a ",(0,o.jsx)(t.strong,{children:"store"}),". An ",(0,o.jsx)(t.strong,{children:"object tree"})," (also commonly referred to as a ",(0,o.jsx)(t.strong,{children:"state tree"}),") is a big object that can contain multiple ",(0,o.jsx)(t.strong,{children:"slices"})," of state (like the state slices we used in the React Fundamentals course section). And a store is exactly what it sounds like: a Redux-managed location to ",(0,o.jsx)(t.em,{children:"store"}),' application state. The store acts as the "single source of truth" for the whole app.']}),"\n",(0,o.jsx)(t.h3,{id:"2-state-is-read-only",children:"2. State is Read-Only"}),"\n",(0,o.jsxs)(t.p,{children:["Redux state is strictly read-only. ",(0,o.jsx)(t.strong,{children:"We cannot modify state directly"}),". The only way to change state in Redux is to dispatch an ",(0,o.jsx)(t.strong,{children:"action"}),". The action communicates our intention to change state to the ",(0,o.jsx)(t.strong,{children:"store"}),". We won't use ",(0,o.jsx)(t.code,{children:"setState()"})," to update state with Redux."]}),"\n",(0,o.jsx)(t.h3,{id:"3-changes-are-made-with-pure-functions",children:"3. Changes are Made with Pure Functions"}),"\n",(0,o.jsx)(t.p,{children:"Redux requires that we make changes to state using pure functions. This makes our code easier to test and we can ensure no unintended side effects will occur."}),"\n",(0,o.jsx)(t.h2,{id:"anatomy-of-redux",children:"Anatomy of Redux"}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsx)(t.p,{children:"So what does this look like in action? Let's discuss each Redux item that needs to be added and configured in a React application to get it up and running."}),"\n",(0,o.jsx)(t.h3,{id:"stores",children:"Stores"}),"\n",(0,o.jsxs)(t.p,{children:["The Redux ",(0,o.jsx)(t.strong,{children:"store"}),' is our "single source of truth" where all application state resides. All application state lives at the "top" of our component tree and trickles down into necessary components.']}),"\n",(0,o.jsx)(t.h3,{id:"reducers",children:"Reducers"}),"\n",(0,o.jsxs)(t.p,{children:["Eventually we'll want to update (or ",(0,o.jsx)(t.em,{children:"mutate"}),") state in our store. In Redux, we do this with ",(0,o.jsx)(t.strong,{children:"reducers"}),". They communicate our intended ",(0,o.jsx)(t.strong,{children:"actions"})," to the store."]}),"\n",(0,o.jsxs)(t.p,{children:["Reducers are just functions that take the current state and an action as arguments. We can use plain old JavaScript to write them. They create a ",(0,o.jsx)(t.em,{children:"new"})," version of state using this information, similar to the manner we constructed new versions of our state in the last course section to provide as arguments to ",(0,o.jsx)(t.code,{children:"setState()"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"Generally, each slice of state in the Redux store has its own dedicated reducer. Because an application can have many slices of state, as we saw in the last course section, Redux applications will often have many different reducers."}),"\n",(0,o.jsxs)(t.p,{children:["Reducers must be ",(0,o.jsx)(t.strong,{children:"pure functions"})," to avoid unintended side effects."]}),"\n",(0,o.jsx)(t.h3,{id:"actions",children:"Actions"}),"\n",(0,o.jsxs)(t.p,{children:["Actions are objects that describe something that happened. They're ",(0,o.jsx)(t.strong,{children:"dispatched"})," to the Redux store and handled by ",(0,o.jsx)(t.strong,{children:"reducers"}),". The reducer receives the action and executes logic based on the action's ",(0,o.jsx)(t.strong,{children:"type"})," that alters state. Data included with the action is called a ",(0,o.jsx)(t.strong,{children:"payload"}),". ",(0,o.jsxs)(t.strong,{children:["Actions are the ",(0,o.jsx)(t.em,{children:"only"})," way to invoke state updates in Redux."]})]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var s=n(96540);const o={},i=s.createContext(o);function r(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);