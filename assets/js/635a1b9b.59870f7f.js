"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[50668],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>c});var a=n(96540);const o={},i=a.createContext(o);function s(e){const t=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(i.Provider,{value:t},e.children)}},96761:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"react/react-fundamentals/4-2-2-3-unidirectional-data-flow","title":"\ud83d\udcd3 4.2.2.3 Unidirectional Data Flow","description":"So far we have only been working with local state. However, when a user inputs data in our form, we somehow need to get that data from our NewTicketForm component to its parent TicketControl component.","source":"@site/versioned_docs/version-v1_3/4_react/2_react-fundamentals/4-2-2-03-unidirectional-data-flow.md","sourceDirName":"4_react/2_react-fundamentals","slug":"/react/react-fundamentals/4-2-2-3-unidirectional-data-flow","permalink":"/v1.3/react/react-fundamentals/4-2-2-3-unidirectional-data-flow","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 4.2.2.3 Unidirectional Data Flow","day":"tuesday","id":"4-2-2-3-unidirectional-data-flow","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 4.2.2.2 Adding a Form","permalink":"/v1.3/react/react-fundamentals/4-2-2-2-adding-a-form"},"next":{"title":"\ud83d\udcd3 4.2.2.4 Passing Data Via Callbacks","permalink":"/v1.3/react/react-fundamentals/4-2-2-4-passing-data-via-callbacks"}}');var o=n(74848),i=n(28453);const s={title:"\ud83d\udcd3 4.2.2.3 Unidirectional Data Flow",day:"tuesday",id:"4-2-2-3-unidirectional-data-flow",hide_table_of_contents:!0},c=void 0,r={},l=[];function d(e){const t={code:"code",em:"em",li:"li",ol:"ol",p:"p",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["So far we have only been working with local state. However, when a user inputs data in our form, we somehow need to get that data from our ",(0,o.jsx)(t.code,{children:"NewTicketForm"})," component to its parent ",(0,o.jsx)(t.code,{children:"TicketControl"})," component."]}),"\n",(0,o.jsxs)(t.p,{children:["Before we do that, we need to learn more about ",(0,o.jsx)(t.strong,{children:"unidirectional data flow"}),". Unidirectional data flow is a language-agnostic term for applications that have data flowing in only one direction."]}),"\n",(0,o.jsxs)(t.p,{children:["In the case of React applications, data can only flow from a parent component ",(0,o.jsx)(t.em,{children:"down"})," to a child component. That's why shared state should always be lifted to a common ancestor. Only the component holding a piece of state and its child components will ever be able to access that state. Components that are higher up the component tree (above a component with state) have no way to know about that state because of unidirectional data flow. In fact, components in React are so modular that they don't even know their parents exist. It's the job of parent components to keep track of their children, not the other way around."]}),"\n",(0,o.jsxs)(t.p,{children:["The same is true with props. We can only pass props ",(0,o.jsx)(t.em,{children:"down"})," from a parent component to a child component. That's the whole point of unidirectional data flow. It may seem like a limiting concept, but it makes planning, building, and debugging an application much easier. If state and props could flow in every direction, our applications would quickly become a mess."]}),"\n",(0,o.jsxs)(t.p,{children:["So if data can only be passed ",(0,o.jsx)(t.em,{children:"down"}),", then how can we get information from a child component up to a parent component?"]}),"\n",(0,o.jsxs)(t.p,{children:["The answer: we need to use ",(0,o.jsx)(t.strong,{children:"callbacks"}),". Here's how it works:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"We define a function in a parent component that has state."}),"\n",(0,o.jsx)(t.li,{children:"The parent component passes this function into the child component as a prop. Functions can be props just like any other data type."}),"\n",(0,o.jsx)(t.li,{children:"We call this function in our child component, passing data as an argument."}),"\n",(0,o.jsx)(t.li,{children:"When the child calls this function, the function in the parent component is invoked. Because the function lives in the parent component, the parent can access any data that's passed into it."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"This may feel like we're breaking the rules of unidirectional data flow because the parent component can access information from the function call in the child component."}),"\n",(0,o.jsxs)(t.p,{children:["However, unidirectional data flow is still being maintained. The parent component passes props ",(0,o.jsx)(t.em,{children:"down"})," using unidirectional data flow. If a function is passed downward as a prop, then the child component can call that function. The child component is not passing any data ",(0,o.jsx)(t.em,{children:"up"})," to the parent component. Instead, the child component is simply invoking a function that was passed ",(0,o.jsx)(t.em,{children:"down"})," to it. The parent component is still in control of what happens with that data."]}),"\n",(0,o.jsx)(t.p,{children:"In our Help Queue application, we'll use this pattern to add new tickets:"}),"\n",(0,o.jsxs)(t.p,{children:["When a user submits the form in ",(0,o.jsx)(t.code,{children:"NewTicketForm"})," (child), we need that ticket data to reach ",(0,o.jsx)(t.code,{children:"TicketControl"})," (parent) where our ticket list lives. So we'll create a function in ",(0,o.jsx)(t.code,{children:"TicketControl"})," (parent) that knows how to add tickets, pass that function down to ",(0,o.jsx)(t.code,{children:"NewTicketForm"})," (child) as a prop, and then call that function when the form is submitted."]}),"\n",(0,o.jsx)(t.p,{children:"In the next lesson, we'll walk through implementing this step-by-step. Don't worry if the concept still feels abstract \u2014 it will make much more sense once you see the actual code and how the pieces connect."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);