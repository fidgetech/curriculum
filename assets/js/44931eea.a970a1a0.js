"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[27667],{28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var t=i(96540);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}},90678:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"c-and-net/lessons-6-18-data-types-and-variables/3-0-0-18-type-casting","title":"\ud83d\udcd3 3.0.0.18 Type Casting","description":"Type casting is the process of transferring a piece of data between types. We\'ll look at an example in the dotnet-script REPL using standard data types.","source":"@site/versioned_docs/version-v1_3/3_c-and-net/0_lessons-6-18-data-types-and-variables/3-0-0-18-type-casting.md","sourceDirName":"3_c-and-net/0_lessons-6-18-data-types-and-variables","slug":"/c-and-net/lessons-6-18-data-types-and-variables/3-0-0-18-type-casting","permalink":"/v1.3/c-and-net/lessons-6-18-data-types-and-variables/3-0-0-18-type-casting","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 3.0.0.18 Type Casting","day":"weekend","id":"3-0-0-18-type-casting","hide_table_of_contents":true,"pagination_next":null},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.0.0.17 Iterators: Foreach and For Loops","permalink":"/v1.3/c-and-net/lessons-6-18-data-types-and-variables/3-0-0-17-iterators-foreach-and-for-loops"}}');var s=i(74848),a=i(28453);const r={title:"\ud83d\udcd3 3.0.0.18 Type Casting",day:"weekend",id:"3-0-0-18-type-casting",hide_table_of_contents:!0,pagination_next:null},o=void 0,c={},l=[{value:"Type Casting",id:"type-casting",level:2},{value:"Explicit Casting",id:"explicit-casting",level:3},{value:"Casting Does Not Always Go As Expected",id:"casting-does-not-always-go-as-expected",level:3},{value:"Implicit casting",id:"implicit-casting",level:3},{value:"Other Implicit Casting",id:"other-implicit-casting",level:3},{value:"Guidelines and Resources",id:"guidelines-and-resources",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Type casting"})," is the process of transferring a piece of data between types. We'll look at an example in the ",(0,s.jsx)(n.code,{children:"dotnet-script"})," REPL using standard data types."]}),"\n",(0,s.jsx)(n.h2,{id:"type-casting",children:"Type Casting"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["Let's try to multiply a decimal-holding number, which is called a ",(0,s.jsx)(n.code,{children:"double"}),", and store it in an ",(0,s.jsx)(n.code,{children:"integer"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"> double myNumber = 12.5;\n> int multipliedNumber = myNumber * 2;\n"})}),"\n",(0,s.jsx)(n.p,{children:"We'll quickly get an error:"}),"\n",(0,s.jsx)(n.p,{children:"<code style={{color:\"red\"}}>\n(1,24): error CS0266: Cannot implicitly convert type 'double' to 'int'. An explicit conversion exists (are you missing a cast?)\n"}),"\n",(0,s.jsxs)(n.p,{children:["When we multiply ",(0,s.jsx)(n.code,{children:"12.5 * 2"})," we get ",(0,s.jsx)(n.code,{children:"25"}),", which should be a valid integer. Well, even though the result of the operation is a whole number, and we're storing that whole number in a variable declared as an ",(0,s.jsx)(n.code,{children:"int"}),", C# throws an error because ",(0,s.jsx)(n.code,{children:"double"})," is not an ",(0,s.jsx)(n.code,{children:"int"}),". Moreover, C# does not make any implicit conversions between ",(0,s.jsx)(n.code,{children:"double"})," and ",(0,s.jsx)(n.code,{children:"int"}),". This is our strongly-typed paradigm at work."]}),"\n",(0,s.jsx)(n.h3,{id:"explicit-casting",children:"Explicit Casting"}),"\n",(0,s.jsxs)(n.p,{children:["The error hints at a solution: ",(0,s.jsx)(n.code,{children:"An explicit conversion exists (are you missing a cast?)"})," What is an explicit conversion? Let's look at how we can use one to compile this code. We've already entered in ",(0,s.jsx)(n.code,{children:"double myNumber = 12.5;"})," to the REPL, so now we'll just fix the arithmetic by adding a data type conversion:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"> int multipliedNumber = (int)myNumber * 2;\n> multipliedNumber\n24\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The syntax ",(0,s.jsx)(n.code,{children:"(int)myNumber"})," is an example of a ",(0,s.jsx)(n.strong,{children:"cast"}),'. Casting, just like in the movies, is the act of turning one thing into another. Just as Audrey Hepburn was cast as Holly Golightly in the movie "Breakfast at Tiffany\'s", we can cast ',(0,s.jsx)(n.code,{children:"double"})," as an ",(0,s.jsx)(n.code,{children:"int"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["This type of cast is called an ",(0,s.jsx)(n.strong,{children:"explicit cast"}),". We're openly telling the compiler to convert ",(0,s.jsx)(n.code,{children:"myNumber"})," into an integer before proceeding.  Since ",(0,s.jsx)(n.code,{children:"myNumber"})," and ",(0,s.jsx)(n.code,{children:"2"})," are both valid integers, their evaluation can be stored in the ",(0,s.jsx)(n.code,{children:"multipliedNumber"})," variable."]}),"\n",(0,s.jsx)(n.h3,{id:"casting-does-not-always-go-as-expected",children:"Casting Does Not Always Go As Expected"}),"\n",(0,s.jsxs)(n.p,{children:["But there's still something wrong! We got ",(0,s.jsx)(n.code,{children:"24"})," instead of ",(0,s.jsx)(n.code,{children:"25"}),", the actual result of ",(0,s.jsx)(n.code,{children:"12.5 * 2"}),". So why doesn't C# return ",(0,s.jsx)(n.code,{children:"25"}),"?"]}),"\n",(0,s.jsxs)(n.p,{children:["Casting can be an imperfect process. When data types are different, casting can sometimes result in a loss in accuracy. In this case, the expression ",(0,s.jsx)(n.code,{children:"(int)myNumber"})," converts ",(0,s.jsx)(n.code,{children:"12.5"})," into an integer ",(0,s.jsx)(n.em,{children:"before"})," performing the multiplication operation. To convert a ",(0,s.jsx)(n.code,{children:"double"})," into an ",(0,s.jsx)(n.code,{children:"int"}),", our cast drops the decimal and turns ",(0,s.jsx)(n.code,{children:"myNumber"})," into ",(0,s.jsx)(n.code,{children:"12"}),". As we know, ",(0,s.jsx)(n.code,{children:"12 * 2"})," equals ",(0,s.jsx)(n.code,{children:"24"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["This is called ",(0,s.jsx)(n.strong,{children:"lossy conversion"}),", as there is a loss of data or accuracy that occurs during the conversion."]}),"\n",(0,s.jsx)(n.p,{children:"We can mitigate this loss by waiting until the operation completes before performing the conversion:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"> double myNumber2 = 12.5;\n> int multipliedNumber2 = (int)(myNumber2 * 2); //CHANGE IS HERE\n> multipliedNumber2\n25\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We perform our mathematical operation ",(0,s.jsx)(n.em,{children:"before"})," making the explicit conversion, which leads to the correct result, ",(0,s.jsx)(n.code,{children:"25"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"implicit-casting",children:"Implicit casting"}),"\n",(0,s.jsxs)(n.p,{children:["There is another cast going on here that we might not spot right away. In our expression ",(0,s.jsx)(n.code,{children:"myNumber * 2"}),", the ",(0,s.jsx)(n.code,{children:"2"})," is declared without a type. It's just a numeric value."]}),"\n",(0,s.jsxs)(n.p,{children:["So what type is ",(0,s.jsx)(n.code,{children:"2"})," exactly if we haven't declared it?"]}),"\n",(0,s.jsx)(n.p,{children:"Let's change our example slightly:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"> int myNumber3 = 12;\n> double multipliedNumber3 = myNumber3 * 2;\n> multipliedNumber3\n24\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When we run this code, we get the correct value ",(0,s.jsx)(n.code,{children:"24"}),". How does a multiplied ",(0,s.jsx)(n.code,{children:"int"})," become a ",(0,s.jsx)(n.code,{children:"double"})," when a multiplied ",(0,s.jsx)(n.code,{children:"double"})," cannot become an ",(0,s.jsx)(n.code,{children:"int"}),"?"]}),"\n",(0,s.jsxs)(n.p,{children:["When we convert ",(0,s.jsx)(n.code,{children:"12.5"})," to an ",(0,s.jsx)(n.code,{children:"int"}),", we lose information. It would make sense to think of a double as a data type that contains ",(0,s.jsx)(n.em,{children:"more"})," information than an ",(0,s.jsx)(n.code,{children:"int"}),". This makes a ",(0,s.jsx)(n.code,{children:"double"})," a ",(0,s.jsx)(n.strong,{children:"larger"})," data type than an ",(0,s.jsx)(n.code,{children:"int"}),". When we convert from an ",(0,s.jsx)(n.code,{children:"int"})," to a ",(0,s.jsx)(n.code,{children:"double"}),", we don't lose any information because we're moving from a ",(0,s.jsx)(n.strong,{children:"smaller"})," data type to a larger one. This is called ",(0,s.jsx)(n.strong,{children:"implicit casting"}),". No special syntax is required and C# will do this automatically."]}),"\n",(0,s.jsxs)(n.p,{children:["So what is ",(0,s.jsx)(n.code,{children:"2"})," in the code above then?"]}),"\n",(0,s.jsxs)(n.p,{children:["It starts as an ",(0,s.jsx)(n.code,{children:"int"}),". However, because it's a smaller data type than a ",(0,s.jsx)(n.code,{children:"double"}),", C# implicitly casts it to a ",(0,s.jsx)(n.code,{children:"double"})," so it can be evaluated."]}),"\n",(0,s.jsx)(n.h3,{id:"other-implicit-casting",children:"Other Implicit Casting"}),"\n",(0,s.jsx)(n.p,{children:"There are other types of implicit conversions that C# performs. For example, if we have an integer and use string interpolation to have the integer evaluated within a string, C# will automatically convert the integer into a string. Here's two examples:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'> $"Hello number {1}"\n"Hello number 1"\n> int num = 2;\n> $"Hello number {num}"\n"Hello number 2"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If you want to learn more, or are ever unsure of whether C# is converting data types implicitly, review all of the cases in which ",(0,s.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/conversions#102-implicit-conversions",children:"C# performs implicit conversions on the Microsoft (MS) Docs"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"guidelines-and-resources",children:"Guidelines and Resources"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"Here are some guidelines for explicit and implicit casting. In general, we shouldn't be using type casting frequently; regular use of type casting is a sign that the code is inefficient."}),"\n",(0,s.jsxs)(n.p,{children:["C# will perform ",(0,s.jsx)(n.strong,{children:"implicit casting"})," when:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Data types are compatible, such as when we are working with two ",(0,s.jsx)(n.code,{children:"int"}),"s;"]}),"\n",(0,s.jsxs)(n.li,{children:["When data of a smaller type is assigned to a bigger data type, such as when an ",(0,s.jsx)(n.code,{children:"int"})," is cast as a ",(0,s.jsx)(n.code,{children:"double"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["We should use ",(0,s.jsx)(n.strong,{children:"explicit casting"})," when:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"We are working with incompatible data types where automatic conversion cannot be done. We explicitly state the data type to which the value should be converted. However, be careful: explicit casting can potentially result in loss of accuracy."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Would you like to see more examples?"})," The Microsoft (MS) Docs has a great article on ",(0,s.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions",children:"casting and type conversion"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);