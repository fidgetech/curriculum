"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[56657],{28453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>a});var n=s(96540);const i={},r=n.createContext(i);function o(e){const t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(r.Provider,{value:t},e.children)}},91058:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-36-testing-a-private-field-through-its-public-property-and-organizing-tests-with-arrange-act-assert","title":"\ud83d\udcd3 3.0.0.36 Testing A Private Field through its Public Property and Organizing Tests with Arrange, Act, Assert","description":"In this lesson, we\'ll begin working on the next simplest behavior our Triangle logic should have","source":"@site/docs/3_c-and-net/0_lessons-32-44-tdd-and-debugging/3-0-0-36-testing-a-private-field-through-its-public-property-and-organizing-tests-with-arrange-act-assert.md","sourceDirName":"3_c-and-net/0_lessons-32-44-tdd-and-debugging","slug":"/c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-36-testing-a-private-field-through-its-public-property-and-organizing-tests-with-arrange-act-assert","permalink":"/v1.2/c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-36-testing-a-private-field-through-its-public-property-and-organizing-tests-with-arrange-act-assert","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 3.0.0.36 Testing A Private Field through its Public Property and Organizing Tests with Arrange, Act, Assert","day":"weekend","id":"3-0-0-36-testing-a-private-field-through-its-public-property-and-organizing-tests-with-arrange-act-assert","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.0.0.35 Using the RGR Workflow to Write our First Test for the Constructor","permalink":"/v1.2/c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-35-using-the-rgr-workflow-to-write-our-first-test-for-the-constructor"},"next":{"title":"\ud83d\udcd3 3.0.0.37 Testing An Auto-Implemented Property","permalink":"/v1.2/c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-37-testing-an-auto-implemented-property"}}');var i=s(74848),r=s(28453);const o={title:"\ud83d\udcd3 3.0.0.36 Testing A Private Field through its Public Property and Organizing Tests with Arrange, Act, Assert",day:"weekend",id:"3-0-0-36-testing-a-private-field-through-its-public-property-and-organizing-tests-with-arrange-act-assert",hide_table_of_contents:!0},a=void 0,l={},c=[{value:"Reference for the &quot;Red, Green, Refactor&quot; (RGR) Workflow",id:"reference-for-the-red-green-refactor-rgr-workflow",level:2},{value:"Testing the Private Field <code>_side1</code> through its Public Property <code>Side1</code>",id:"testing-the-private-field-_side1-through-its-public-property-side1",level:2},{value:"1.  Identify the simplest possible behavior the program must exhibit.",id:"1--identify-the-simplest-possible-behavior-the-program-must-exhibit",level:3},{value:"2.  Write a coded test for this behavior.",id:"2--write-a-coded-test-for-this-behavior",level:3},{value:"Arrange, Act, Assert",id:"arrange-act-assert",level:3},{value:"3. Before coding, confirm the test fails.",id:"3-before-coding-confirm-the-test-fails",level:3},{value:"4. Implement the behavior with the least amount of code possible.",id:"4-implement-the-behavior-with-the-least-amount-of-code-possible",level:3},{value:"5. Run the automated test to confirm it passes. If it doesn&#39;t, revisit step 4.",id:"5-run-the-automated-test-to-confirm-it-passes-if-it-doesnt-revisit-step-4",level:3},{value:"(Again) 4. Implement the behavior with the least amount of code possible.",id:"again-4-implement-the-behavior-with-the-least-amount-of-code-possible",level:3},{value:"5. Confirm the Test Passes, and 6. Confirm all previous tests still pass. If they don&#39;t, revisit step 4.",id:"5-confirm-the-test-passes-and-6-confirm-all-previous-tests-still-pass-if-they-dont-revisit-step-4",level:3},{value:"7.  Check if code can be refactored. If so, refactor and repeat step 6.",id:"7--check-if-code-can-be-refactored-if-so-refactor-and-repeat-step-6",level:3},{value:"8.  Commit your passing code.",id:"8--commit-your-passing-code",level:3},{value:"1.  Identify the simplest possible behavior the program must exhibit.",id:"1--identify-the-simplest-possible-behavior-the-program-must-exhibit-1",level:3},{value:"2.  Write a coded test for this behavior.",id:"2--write-a-coded-test-for-this-behavior-1",level:3},{value:"3.  Before coding, confirm the test fails.",id:"3--before-coding-confirm-the-test-fails",level:3},{value:"4.  Implement the behavior with the least amount of code possible.",id:"4--implement-the-behavior-with-the-least-amount-of-code-possible",level:3},{value:"Steps 5. and 6. Confirm the new test and all previous tests are still passing.",id:"steps-5-and-6-confirm-the-new-test-and-all-previous-tests-are-still-passing",level:3},{value:"7.  Check if code can be refactored. If so, refactor and repeat step 6.",id:"7--check-if-code-can-be-refactored-if-so-refactor-and-repeat-step-6-1",level:3},{value:"8.  Commit your passing code.",id:"8--commit-your-passing-code-1",level:3},{value:"9.  Repeat this process with the next simplest behavior.",id:"9--repeat-this-process-with-the-next-simplest-behavior",level:3}];function d(e){const t={code:"code",div:"div",font:"font",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["In this lesson, we'll begin working on the next simplest behavior our ",(0,i.jsx)(t.code,{children:"Triangle"})," logic should have: three sides. Since the ",(0,i.jsx)(t.code,{children:"Triangle"})," logic we create now will mirror exactly the ",(0,i.jsx)(t.code,{children:"Triangle"})," logic we created at the end of the last pre-work section, we'll test for the following:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Testing the private field ",(0,i.jsx)(t.code,{children:"_side1"})," through its public property ",(0,i.jsx)(t.code,{children:"Side1"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["Testing the auto-implemented public property ",(0,i.jsx)(t.code,{children:"Side2"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["Testing the private field ",(0,i.jsx)(t.code,{children:"_side3"})," through its getter and setter methods."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"We'll tackle each of the above behaviors in multiple lessons. This lesson will focus on two main topics:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Using the RGR workflow to test and create the private field ",(0,i.jsx)(t.code,{children:"_side1"})," through its public property ",(0,i.jsx)(t.code,{children:"Side1"}),"."]}),"\n",(0,i.jsx)(t.li,{children:'Using an organizational trick within our tests called "Arrange, Act, Assert".'}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"reference-for-the-red-green-refactor-rgr-workflow",children:'Reference for the "Red, Green, Refactor" (RGR) Workflow'}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.p,{children:'For reference, here\'s the "Red, Green, Refactor" (RGR) workflow we follow with TDD:'}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Identify the simplest possible behavior the program must exhibit."}),"\n",(0,i.jsx)(t.li,{children:"Write a coded test for this behavior."}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.font,{color:"red",children:"Before coding, confirm the test fails."})}),"\n",(0,i.jsx)(t.li,{children:"Implement the behavior with the least amount of code possible."}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.font,{color:"green",children:"Run the automated test to confirm it passes. If it doesn't, revisit step 4."})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.font,{color:"green",children:"Confirm all previous tests still pass. If it doesn't, revisit step 4."})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.font,{color:"blue",children:"Check if code can be refactored. If so, refactor and repeat step 6."})}),"\n",(0,i.jsx)(t.li,{children:"Commit your passing code."}),"\n",(0,i.jsx)(t.li,{children:"Repeat this process with the next simplest behavior."}),"\n"]}),"\n",(0,i.jsxs)(t.h2,{id:"testing-the-private-field-_side1-through-its-public-property-side1",children:["Testing the Private Field ",(0,i.jsx)(t.code,{children:"_side1"})," through its Public Property ",(0,i.jsx)(t.code,{children:"Side1"})]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"1--identify-the-simplest-possible-behavior-the-program-must-exhibit",children:"1.  Identify the simplest possible behavior the program must exhibit."}),"\n",(0,i.jsxs)(t.p,{children:["The next behavior we want to implement in our ",(0,i.jsx)(t.code,{children:"Triangle"})," class is for triangle objects to save three values to represent the three sides of a triangle. This behavior can actually be broken into three: we can consider implementing one side as one behavior."]}),"\n",(0,i.jsx)(t.p,{children:"However, each side of the triangle can further be broken down into two behaviors: implementing a get action and a set action. We distinguish between the set and get behavior because they are different, and including a set behavior is not required."}),"\n",(0,i.jsxs)(t.p,{children:["So the next simplest behavior we'll tackle is creating a get action for the first side of a triangle. In terms of code, we'll create a private field called ",(0,i.jsx)(t.code,{children:"_side1"}),", which we'll access through the ",(0,i.jsx)(t.code,{children:"get"})," action of a public property called ",(0,i.jsx)(t.code,{children:"Side1"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"2--write-a-coded-test-for-this-behavior",children:"2.  Write a coded test for this behavior."}),"\n",(0,i.jsx)(t.p,{children:"Here's the test we'll write, which we'll add just below the test for the constructor:"}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ShapeTracker.Solution/ShapeTracker.Tests/ModelTests/TriangleTests.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"using Microsoft.VisualStudio.TestTools.UnitTesting;\nusing ShapeTracker.Models;\n\nnamespace ShapeTracker.Tests\n{\n  [TestClass]\n  public class TriangleTests\n  {\n\n    [TestMethod]\n    public void TriangleConstructor_CreatesInstanceOfTriangle_Triangle()\n    {\n      Triangle newTriangle = new Triangle();\n      Assert.AreEqual(typeof(Triangle), newTriangle.GetType());\n    }\n\n    [TestMethod]\n    public void GetSide1_ReturnsSide1_Int()\n    {\n      int length1 = 3;\n      Triangle newTriangle = new Triangle(length1);\n      int result = newTriangle.Side1;\n      Assert.AreEqual(length1, result);\n    }\n\n  }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We've created a new test method called ",(0,i.jsx)(t.code,{children:"GetSide1_ReturnsSide1_Int"}),". Getting the value of a property on an ",(0,i.jsx)(t.code,{children:"Triangle"})," may seem trivial. However, in order to get this test to pass, we'll need to create the public  property, the private field, and also update our constructor. It makes sense to test our property and getter method so we know it's working properly, especially if we utilize custom ",(0,i.jsx)(t.code,{children:"get"})," logic."]}),"\n",(0,i.jsx)(t.p,{children:"Within the test method we do the following:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Create a new ",(0,i.jsx)(t.code,{children:"int"})," called ",(0,i.jsx)(t.code,{children:"length1"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Create a new ",(0,i.jsx)(t.code,{children:"Triangle"})," object, passing in the ",(0,i.jsx)(t.code,{children:"length1"})," value."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Record the result of retrieving the ",(0,i.jsx)(t.code,{children:"Side1"})," property of ",(0,i.jsx)(t.code,{children:"newTriangle"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Confirm the description retrieved from the ",(0,i.jsx)(t.code,{children:"Triangle"})," object matches the ",(0,i.jsx)(t.code,{children:"length1"})," string provided to the constructor."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"arrange-act-assert",children:"Arrange, Act, Assert"}),"\n",(0,i.jsxs)(t.p,{children:["This test is more complex than our previous tests. Thankfully, there's an easy organizational trick that helps demystify this process and keep our tests clean. It's called ",(0,i.jsx)(t.strong,{children:'"Arrange, Act, Assert"'}),". With this organizational method, we break our tests down into three stages:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Arrange"}),": We gather, declare and create all necessary components for the test. In the test above, we create ",(0,i.jsx)(t.code,{children:"length1"})," and ",(0,i.jsx)(t.code,{children:"newTriangle"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Act"}),": We invoke the functionality we're testing, often by calling a method or retrieving a property. In the test above, we call ",(0,i.jsx)(t.code,{children:"newTriangle.Side1;"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Assert"}),": We confirm the functionality works as anticipated by comparing its actual output with the anticipated output. This is when we call ",(0,i.jsx)(t.code,{children:"Assert.AreEqual()"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:'Let\'s take one more look at our test. This time, we add comments to show how we use "Arrange, Act, Assert."'}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ShapeTracker.Solution/ShapeTracker.Tests/ModelTests/TriangleTests.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"...\n\n    [TestMethod]\n    public void GetSide1_ReturnsSide1_Int()\n    {\n      // Arrange\n      int length1 = 3;\n      Triangle newTriangle = new Triangle(length1);\n      // Act\n      int result = newTriangle.Side1;\n      // Assert\n      Assert.AreEqual(length1, result);\n    }\n\n...\n"})}),"\n",(0,i.jsx)(t.p,{children:"We recommend following this same organizational process in your own tests throughout the course."}),"\n",(0,i.jsx)(t.h3,{id:"3-before-coding-confirm-the-test-fails",children:"3. Before coding, confirm the test fails."}),"\n",(0,i.jsxs)(t.p,{children:["If we run ",(0,i.jsx)(t.code,{children:"$ dotnet test"})," in the ",(0,i.jsx)(t.code,{children:"ShapeTracker.Tests"})," directory, we'll see errors:"]}),"\n",(0,i.jsxs)(t.pre,{children:[(0,i.jsx)(t.code,{style:{color:"red"},children:"\nC:\\Users\\staff\\Desktop\\ShapeTracker.Solution\\ShapeTracker.Tests\\ModelTests\\TriangleTests.cs(21,34): error CS1729: 'Triangle' does not contain a constructor that takes 1 arguments [C:\\Users\\staff\\Desktop\\ShapeTracker.Solution\\ShapeTracker.Tests\\ShapeTracker.Tests.csproj]\nC:\\Users\\staff\\Desktop\\ShapeTracker.Solution\\ShapeTracker.Tests\\ModelTests\\TriangleTests.cs(23,32): error CS1061: 'Triangle' does not contain a definition for 'Side1' and no accessible extension method 'Side1' accepting a first argument of type 'Triangle' could be found (are you missing a using directive or an assembly reference?) [C:\\Users\\staff\\Desktop\\ShapeTracker.Solution\\ShapeTracker.Tests\\ShapeTracker.Tests.csproj]\n"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["This isn't actually a test failure message \u2014 it's a ",(0,i.jsx)(t.strong,{children:"compiler error"})," because the ",(0,i.jsx)(t.code,{children:"Triangle"})," class doesn't have a constructor with a ",(0,i.jsx)(t.code,{children:"Side1"})," property. As a result, our test won't even run. However, for C# this compiler error is enough of a confirmation that our test does not have any false positives, so we can move onto the next step within the RGR workflow."]}),"\n",(0,i.jsx)(t.h3,{id:"4-implement-the-behavior-with-the-least-amount-of-code-possible",children:"4. Implement the behavior with the least amount of code possible."}),"\n",(0,i.jsx)(t.p,{children:"Let's add just enough code to get beyond the compiler error. Let's update our code in the following ways:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Create a private field called ",(0,i.jsx)(t.code,{children:"_side1"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["Create a public property called ",(0,i.jsx)(t.code,{children:"Side1"})," with a get action defined."]}),"\n",(0,i.jsxs)(t.li,{children:["Add ",(0,i.jsx)(t.code,{children:"length1"})," as a parameter to our constructor and have it assigned as the value of our ",(0,i.jsx)(t.code,{children:"Side1"})," property."]}),"\n"]}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ShapeTracker/Models/Triangle.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"namespace ShapeTracker.Models\n{\n  public class Triangle\n  {\n    private int _side1;\n    public int Side1\n    {\n      get { return _side1; }\n    }\n\n    public Triangle(int length1)\n    {\n      _side1 = length1;\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"5-run-the-automated-test-to-confirm-it-passes-if-it-doesnt-revisit-step-4",children:"5. Run the automated test to confirm it passes. If it doesn't, revisit step 4."}),"\n",(0,i.jsx)(t.p,{children:"We're now ready to see if the code we implemented passes our new test."}),"\n",(0,i.jsxs)(t.p,{children:["When we run ",(0,i.jsx)(t.code,{children:"dotnet test"})," again, we get another compiler error:"]}),"\n",(0,i.jsxs)(t.pre,{children:[(0,i.jsx)(t.code,{style:{color:"red"},children:"\nC:\\Users\\staff\\Desktop\\ShapeTracker.Solution\\ShapeTracker.Tests\\ModelTests\\TriangleTests.cs(12,34): error CS7036: There is no argument given that corresponds to the required formal parameter 'length1' of 'Triangle.Triangle(int)' [C:\\Users\\staff\\Desktop\\ShapeTracker.Solution\\ShapeTracker.Tests\\ShapeTracker.Tests.csproj]\n"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["If we read the compiler error, we can see there's an issue on line 12 of ",(0,i.jsx)(t.code,{children:"TriangleTests.cs"}),". Line 12 is when we call the ",(0,i.jsx)(t.code,{children:"Triangle"})," constructor in our first test: ",(0,i.jsx)(t.code,{children:"Triangle newTriangle = new Triangle();"}),". Our ",(0,i.jsx)(t.code,{children:"Triangle"})," constructor now expects an argument that corresponds to the ",(0,i.jsx)(t.code,{children:"length1"})," parameter. We need to revisit step 4 and implement more code to get our test to pass."]}),"\n",(0,i.jsx)(t.h3,{id:"again-4-implement-the-behavior-with-the-least-amount-of-code-possible",children:"(Again) 4. Implement the behavior with the least amount of code possible."}),"\n",(0,i.jsxs)(t.p,{children:["Here's how we'll update the first test in ",(0,i.jsx)(t.code,{children:"TriangleTests.cs"}),":"]}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ShapeTracker.Solution/ShapeTracker.Tests/ModelTests/TriangleTests.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"...\n\n    [TestMethod]\n    public void TriangleConstructor_CreatesInstanceOfTriangle_Triangle()\n    {\n      Triangle newTriangle = new Triangle(2); // Updated!\n      Assert.AreEqual(typeof(Triangle), newTriangle.GetType());\n    }\n\n...\n"})}),"\n",(0,i.jsx)(t.h3,{id:"5-confirm-the-test-passes-and-6-confirm-all-previous-tests-still-pass-if-they-dont-revisit-step-4",children:"5. Confirm the Test Passes, and 6. Confirm all previous tests still pass. If they don't, revisit step 4."}),"\n",(0,i.jsxs)(t.p,{children:["We can run ",(0,i.jsx)(t.code,{children:"dotnet test"})," again and confirm all our tests are passing now."]}),"\n",(0,i.jsxs)(t.pre,{children:[(0,i.jsx)(t.code,{style:{color:"green"},children:"\nPassed!  - Failed:     0, Passed:     2, Skipped:     0, Total:     2, Duration: 67 ms - ShapeTracker.Tests.dll (net6.0)\n"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:['When we\'re following "Red, Green, Refactor" we should be identifying behaviors that ',(0,i.jsx)(t.strong,{children:"remain true for the life of the program"}),". Ideally, we should rarely have to go back and edit previous tests. In fact, editing tests to make them pass can be dangerous. We don't want to risk creating falsely-passing tests. However, as applications grow in size, it's occasionally required to edit previous tests. In particular a class's constructor is likely to change a lot until the class logic is done."]}),"\n",(0,i.jsx)(t.h3,{id:"7--check-if-code-can-be-refactored-if-so-refactor-and-repeat-step-6",children:"7.  Check if code can be refactored. If so, refactor and repeat step 6."}),"\n",(0,i.jsx)(t.p,{children:"Our code cannot be refactored at this time, since it is still very basic."}),"\n",(0,i.jsx)(t.h3,{id:"8--commit-your-passing-code",children:"8.  Commit your passing code."}),"\n",(0,i.jsx)(t.p,{children:'Time to commit our passing code. The commit message this time will be "add Side1 get functionality + passing test".'}),"\n",(0,i.jsxs)(t.p,{children:["Remember that you can change the wording of your last commit with the command ",(0,i.jsx)(t.code,{children:"git commit --amend"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"We're now ready for step 9: Repeat this process with the next simplest behavior."}),"\n",(0,i.jsx)(t.h3,{id:"1--identify-the-simplest-possible-behavior-the-program-must-exhibit-1",children:"1.  Identify the simplest possible behavior the program must exhibit."}),"\n",(0,i.jsxs)(t.p,{children:["We want to be able to get and set the value of our ",(0,i.jsx)(t.code,{children:"_side1"})," private field, so the next simplest behavior we want to test for is adding a ",(0,i.jsx)(t.code,{children:"set"})," action to our public ",(0,i.jsx)(t.code,{children:"Side1"})," property."]}),"\n",(0,i.jsx)(t.h3,{id:"2--write-a-coded-test-for-this-behavior-1",children:"2.  Write a coded test for this behavior."}),"\n",(0,i.jsxs)(t.p,{children:["Here's our new test. Note that we don't have to include the comments ",(0,i.jsx)(t.code,{children:"// Arrange"}),", ",(0,i.jsx)(t.code,{children:"// Act"}),", ",(0,i.jsx)(t.code,{children:"// Assert"}),":"]}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ShapeTracker.Solution/ShapeTracker.Tests/ModelTests/TriangleTests.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"using Microsoft.VisualStudio.TestTools.UnitTesting;\nusing ShapeTracker.Models;\n\nnamespace ShapeTracker.Tests\n{\n  [TestClass]\n  public class TriangleTests\n  {\n\n    ... // previous 2 tests omitted for brevity.\n\n    [TestMethod]\n    public void SetSide1_SetsValueOfSide1_Void()\n    {\n      // Arrange\n      Triangle newTriangle = new Triangle(3);\n      int newLength1 = 44;\n      // Act\n      newTriangle.Side1 = newLength1;\n      // Assert\n      Assert.AreEqual(newLength1, newTriangle.Side1);\n    }\n\n  }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"3--before-coding-confirm-the-test-fails",children:"3.  Before coding, confirm the test fails."}),"\n",(0,i.jsxs)(t.p,{children:["Let's confirm that our test fails by running ",(0,i.jsx)(t.code,{children:"dotnet test"})," within the ",(0,i.jsx)(t.code,{children:"ShapeTracker.Tests"})," directory:"]}),"\n",(0,i.jsxs)(t.pre,{children:[(0,i.jsx)(t.code,{style:{color:"red"},children:"\nC:\\Users\\staff\\Desktop\\ShapeTracker.Solution\\ShapeTracker.Tests\\ModelTests\\TriangleTests.cs(35,7): error CS0200: Property or indexer 'Triangle.Side1' cannot be assigned to -- it is read only [C:\\Users\\staff\\Desktop\\ShapeTracker.Solution\\ShapeTracker.Tests\\ShapeTracker.Tests.csproj]\n"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["We get a compiler error, which counts as a test failure. The error clearly lets us know that we cannot assign a value to the ",(0,i.jsx)(t.code,{children:"Side1"})," property."]}),"\n",(0,i.jsx)(t.h3,{id:"4--implement-the-behavior-with-the-least-amount-of-code-possible",children:"4.  Implement the behavior with the least amount of code possible."}),"\n",(0,i.jsxs)(t.p,{children:["We'll add a ",(0,i.jsx)(t.code,{children:"set"})," action to our public ",(0,i.jsx)(t.code,{children:"Side1"})," property, which will handle assigning the private field ",(0,i.jsx)(t.code,{children:"_side1"})," a value."]}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ShapeTracker/Models/Triangle.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"namespace ShapeTracker.Models\n{\n  public class Triangle\n  {\n    private int _side1;\n    public int Side1\n    {\n      get { return _side1; }\n      set { _side1 = value; }\n    }\n\n    public Triangle(int length1)\n    {\n      _side1 = length1;\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"steps-5-and-6-confirm-the-new-test-and-all-previous-tests-are-still-passing",children:"Steps 5. and 6. Confirm the new test and all previous tests are still passing."}),"\n",(0,i.jsx)(t.p,{children:"With the previous update, we can confirm that all of our tests are now passing:"}),"\n",(0,i.jsxs)(t.pre,{children:[(0,i.jsx)(t.code,{style:{color:"green"},children:"\nPassed!  - Failed:     0, Passed:     3, Skipped:     0, Total:     2, Duration: 67 ms - ShapeTracker.Tests.dll (net6.0)\n"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"7--check-if-code-can-be-refactored-if-so-refactor-and-repeat-step-6-1",children:"7.  Check if code can be refactored. If so, refactor and repeat step 6."}),"\n",(0,i.jsx)(t.p,{children:"We're still in the early stages of development, so we won't see an opportunity for refactoring for a while."}),"\n",(0,i.jsx)(t.h3,{id:"8--commit-your-passing-code-1",children:"8.  Commit your passing code."}),"\n",(0,i.jsx)(t.p,{children:'Commit your passing code. We\'ll use the commit message "add passing test, code for Triangle.Side1 SET".'}),"\n",(0,i.jsx)(t.h3,{id:"9--repeat-this-process-with-the-next-simplest-behavior",children:"9.  Repeat this process with the next simplest behavior."}),"\n",(0,i.jsxs)(t.p,{children:["We've completed our get and set behavior for the ",(0,i.jsx)(t.code,{children:"Side1"})," property and private ",(0,i.jsx)(t.code,{children:"_side1"})," field. We've also updated the constructor accordingly. In the next lesson, we'll move on to the next simplest behavior."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);