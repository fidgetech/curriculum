"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[60334],{28453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>o});var n=s(96540);const i={},r=n.createContext(i);function a(e){const t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(r.Provider,{value:t},e.children)}},77131:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-39-testing-a-method-with-multiple-behaviors","title":"\ud83d\udcd3 3.0.0.39 Testing A Method with Multiple Behaviors","description":"At this point we have seven passing tests and a fully tested Triangle constructor, field, property, and auto-implemented property. What\'s the next behavior we want to implement for our Triangle class? I\'d say we\'re ready to work on the Triangle.CheckType() instance method that will determine what type of triangle we have.","source":"@site/docs/3_c-and-net/0_lessons-32-44-tdd-and-debugging/3-0-0-39-testing-a-method-with-multiple-behaviors.md","sourceDirName":"3_c-and-net/0_lessons-32-44-tdd-and-debugging","slug":"/c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-39-testing-a-method-with-multiple-behaviors","permalink":"/v1.2/c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-39-testing-a-method-with-multiple-behaviors","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 3.0.0.39 Testing A Method with Multiple Behaviors","day":"weekend","id":"3-0-0-39-testing-a-method-with-multiple-behaviors","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.0.0.38 Testing A Private Field through its Getter and Setter Methods","permalink":"/v1.2/c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-38-testing-a-private-field-through-its-getter-and-setter-methods"},"next":{"title":"\ud83d\udcd3 3.0.0.40 Part 1: Testing Static Class Members and Collections","permalink":"/v1.2/c-and-net/lessons-32-44-tdd-and-debugging/3-0-0-40-part-1-testing-static-class-members-and-collections"}}');var i=s(74848),r=s(28453);const a={title:"\ud83d\udcd3 3.0.0.39 Testing A Method with Multiple Behaviors",day:"weekend",id:"3-0-0-39-testing-a-method-with-multiple-behaviors",hide_table_of_contents:!0},o=void 0,l={},h=[{value:"Reference for the &quot;Red, Green, Refactor&quot; (RGR) Workflow",id:"reference-for-the-red-green-refactor-rgr-workflow",level:2},{value:"Testing the <code>&quot;not a triangle&quot;</code> Path in the <code>CheckType()</code> Method",id:"testing-the-not-a-triangle-path-in-the-checktype-method",level:2},{value:"1.  Identify the simplest possible behavior the program must exhibit.",id:"1--identify-the-simplest-possible-behavior-the-program-must-exhibit",level:3},{value:"2.  Write a coded test for this behavior.",id:"2--write-a-coded-test-for-this-behavior",level:3},{value:"3.  Before coding, confirm the test fails.",id:"3--before-coding-confirm-the-test-fails",level:3},{value:"4.  Implement the behavior with the least amount of code possible.",id:"4--implement-the-behavior-with-the-least-amount-of-code-possible",level:3},{value:"5.  Run the automated test to confirm it passes. If it doesn&#39;t, revisit step 4.",id:"5--run-the-automated-test-to-confirm-it-passes-if-it-doesnt-revisit-step-4",level:3},{value:"Steps 6 and 7",id:"steps-6-and-7",level:3},{value:"Steps 8 and 9",id:"steps-8-and-9",level:3},{value:"Testing the <code>&quot;scalene triangle&quot;</code> Path in the <code>CheckType()</code> Method",id:"testing-the-scalene-triangle-path-in-the-checktype-method",level:2},{value:"1.  Identify the simplest possible behavior the program must exhibit.",id:"1--identify-the-simplest-possible-behavior-the-program-must-exhibit-1",level:3},{value:"2.  Write a coded test for this behavior.",id:"2--write-a-coded-test-for-this-behavior-1",level:3},{value:"3.  Before coding, confirm the test fails.",id:"3--before-coding-confirm-the-test-fails-1",level:3},{value:"4.  Implement the behavior with the least amount of code possible.",id:"4--implement-the-behavior-with-the-least-amount-of-code-possible-1",level:3},{value:"5.  Run the automated test to confirm it passes. If it doesn&#39;t, revisit step 4.",id:"5--run-the-automated-test-to-confirm-it-passes-if-it-doesnt-revisit-step-4-1",level:3},{value:"(Again) 4.  Implement the behavior with the least amount of code possible.",id:"again-4--implement-the-behavior-with-the-least-amount-of-code-possible",level:3},{value:"5.  Run the automated test to confirm it passes. If it doesn&#39;t, revisit step 4.",id:"5--run-the-automated-test-to-confirm-it-passes-if-it-doesnt-revisit-step-4-2",level:3},{value:"5.  Run the automated test to confirm it passes. If it doesn&#39;t, revisit step 4.",id:"5--run-the-automated-test-to-confirm-it-passes-if-it-doesnt-revisit-step-4-3",level:3},{value:"Steps 6 and 7",id:"steps-6-and-7-1",level:3},{value:"Steps 8 and 9",id:"steps-8-and-9-1",level:3},{value:"Testing the <code>&quot;isosceles triangle&quot;</code> Path in the <code>CheckType()</code> Method",id:"testing-the-isosceles-triangle-path-in-the-checktype-method",level:2},{value:"1.  Identify the simplest possible behavior the program must exhibit.",id:"1--identify-the-simplest-possible-behavior-the-program-must-exhibit-2",level:3},{value:"2.  Write a coded test for this behavior.",id:"2--write-a-coded-test-for-this-behavior-2",level:3},{value:"3.  Before coding, confirm the test fails.",id:"3--before-coding-confirm-the-test-fails-2",level:3},{value:"4.  Implement the behavior with the least amount of code possible.",id:"4--implement-the-behavior-with-the-least-amount-of-code-possible-2",level:3},{value:"5.  Run the automated test to confirm it passes. If it doesn&#39;t, revisit step 4.",id:"5--run-the-automated-test-to-confirm-it-passes-if-it-doesnt-revisit-step-4-4",level:3},{value:"Steps 6 and 7",id:"steps-6-and-7-2",level:3},{value:"Steps 8 and 9",id:"steps-8-and-9-2",level:3},{value:"Testing the <code>&quot;equilateral triangle&quot;</code> Path in the <code>CheckType()</code> Method",id:"testing-the-equilateral-triangle-path-in-the-checktype-method",level:2},{value:"1.  Identify the simplest possible behavior the program must exhibit.",id:"1--identify-the-simplest-possible-behavior-the-program-must-exhibit-3",level:3},{value:"2.  Write a coded test for this behavior.",id:"2--write-a-coded-test-for-this-behavior-3",level:3},{value:"3.  Before coding, confirm the test fails.",id:"3--before-coding-confirm-the-test-fails-3",level:3},{value:"4.  Implement the behavior with the least amount of code possible.",id:"4--implement-the-behavior-with-the-least-amount-of-code-possible-3",level:3},{value:"5.  Run the automated test to confirm it passes. If it doesn&#39;t, revisit step 4.",id:"5--run-the-automated-test-to-confirm-it-passes-if-it-doesnt-revisit-step-4-5",level:3},{value:"Steps 6 and 7",id:"steps-6-and-7-3",level:3},{value:"Steps 8 and 9",id:"steps-8-and-9-3",level:3}];function d(e){const t={code:"code",div:"div",font:"font",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["At this point we have seven passing tests and a fully tested ",(0,i.jsx)(t.code,{children:"Triangle"})," constructor, field, property, and auto-implemented property. What's the next behavior we want to implement for our ",(0,i.jsx)(t.code,{children:"Triangle"})," class? I'd say we're ready to work on the ",(0,i.jsx)(t.code,{children:"Triangle.CheckType()"})," instance method that will determine what type of triangle we have."]}),"\n",(0,i.jsx)(t.p,{children:"What do we know about the functionality we want for this method?"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["It should return one of four values:\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:'"not a triangle"'})," when the three sides can't make an actual triangle. For example the sides 1, 4, and 5000 cannot make an actual triangle."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:'"scalene triangle"'})," when no sides are the same length."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:'"isosceles triangle"'})," when two sides have the same length."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:'"equilateral triangle"'})," when all three sides have the same length."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["The return type is a ",(0,i.jsx)(t.code,{children:"string"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["What's the simplest starting point? It's up to you to decide! However, it's important to recognize that each of the possible return values represents a distinct behavior within the ",(0,i.jsx)(t.code,{children:"Triangle.CheckType()"})," instance method; that means we need to tackle each behavior separately, with a separate test."]}),"\n",(0,i.jsxs)(t.p,{children:["So we'll write four tests, each of which covers a different outcome of the ",(0,i.jsx)(t.code,{children:"CheckType()"})," method. This actually reveals a simple ",(0,i.jsx)(t.strong,{children:"testing guideline"})," to follow: for each method, there should be a separate test for each possible outcome. This may be self-explanatory, but we'll explain more: whenever a method has multiple possible return values, it means it implements branching; each branch in that method is a distinct ",(0,i.jsx)(t.strong,{children:"path"})," that our program can take; the best way to test these distinct paths is to write separate tests for them. This is considered best practice because each test targets distinct application behavior, instead of a distinct application method."]}),"\n",(0,i.jsxs)(t.p,{children:["In this lesson, we'll move down the list, implementing the test and code for ",(0,i.jsx)(t.code,{children:'"not a triangle"'}),", then ",(0,i.jsx)(t.code,{children:'"scalene triangle"'}),", then ",(0,i.jsx)(t.code,{children:'"isosceles triangle"'}),", and finally ",(0,i.jsx)(t.code,{children:'"equilateral triangle"'}),". We'll continue to use the RGR workflow as we go."]}),"\n",(0,i.jsx)(t.h2,{id:"reference-for-the-red-green-refactor-rgr-workflow",children:'Reference for the "Red, Green, Refactor" (RGR) Workflow'}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.p,{children:'For reference, here\'s the "Red, Green, Refactor" (RGR) workflow we follow with TDD:'}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Identify the simplest possible behavior the program must exhibit."}),"\n",(0,i.jsx)(t.li,{children:"Write a coded test for this behavior."}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.font,{color:"red",children:"Before coding, confirm the test fails."})}),"\n",(0,i.jsx)(t.li,{children:"Implement the behavior with the least amount of code possible."}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.font,{color:"green",children:"Run the automated test to confirm it passes. If it doesn't, revisit step 4."})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.font,{color:"green",children:"Confirm all previous tests still pass. If it doesn't, revisit step 4."})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.font,{color:"blue",children:"Check if code can be refactored. If so, refactor and repeat step 6."})}),"\n",(0,i.jsx)(t.li,{children:"Commit your passing code."}),"\n",(0,i.jsx)(t.li,{children:"Repeat this process with the next simplest behavior."}),"\n"]}),"\n",(0,i.jsxs)(t.h2,{id:"testing-the-not-a-triangle-path-in-the-checktype-method",children:["Testing the ",(0,i.jsx)(t.code,{children:'"not a triangle"'})," Path in the ",(0,i.jsx)(t.code,{children:"CheckType()"})," Method"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"1--identify-the-simplest-possible-behavior-the-program-must-exhibit",children:"1.  Identify the simplest possible behavior the program must exhibit."}),"\n",(0,i.jsxs)(t.p,{children:["The first behavior we want to handle is when a triangle is ",(0,i.jsx)(t.code,{children:'"not a triangle"'}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"2--write-a-coded-test-for-this-behavior",children:"2.  Write a coded test for this behavior."}),"\n",(0,i.jsx)(t.p,{children:"Here's our new test:"}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ShapeTracker.Solution/ShapeTracker.Tests/ModelTests/TriangleTests.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'using Microsoft.VisualStudio.TestTools.UnitTesting;\nusing ShapeTracker.Models;\n\nnamespace ShapeTracker.Tests\n{\n  [TestClass]\n  public class TriangleTests\n  {\n\n    ... // 7 tests omitted for brevity\n\n    [TestMethod]\n    public void CheckType_DeterminesWhenNotATriangle_String()\n    {\n      // Arrange\n      Triangle notATriangle = new Triangle(3, 4, 88);\n      // Act\n      string triType = notATriangle.CheckType();\n      // Assert\n      Assert.AreEqual("not a triangle", triType);\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"3--before-coding-confirm-the-test-fails",children:"3.  Before coding, confirm the test fails."}),"\n",(0,i.jsxs)(t.p,{children:["When we run ",(0,i.jsx)(t.code,{children:"dotnet test"})," in the ",(0,i.jsx)(t.code,{children:"ShapeTracker.Tests"})," directory, we'll get a compiler error letting us know that the ",(0,i.jsx)(t.code,{children:"Triangle.CheckType()"})," instance method does not exist:"]}),"\n",(0,i.jsxs)(t.pre,{children:[(0,i.jsx)(t.code,{style:{color:"red"},children:"\nC:\\Users\\staff\\Desktop\\ShapeTracker.Solution\\ShapeTracker.Tests\\ModelTests\\TriangleTests.cs(94,36): error CS1061: 'Triangle' does not contain a definition for 'CheckType' and no accessible extension method 'CheckType' accepting a first argument of type 'Triangle' could be found (are you missing a using directive or an assembly reference?) [C:\\Users\\staff\\Desktop\\ShapeTracker.Solution\\ShapeTracker.Tests\\ShapeTracker.Tests.csproj]\n"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"This compiler error confirms that we do not have any false positives."}),"\n",(0,i.jsx)(t.h3,{id:"4--implement-the-behavior-with-the-least-amount-of-code-possible",children:"4.  Implement the behavior with the least amount of code possible."}),"\n",(0,i.jsx)(t.p,{children:"Here's the least amount of code to get our test passing:"}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ShapeTracker/Models/Triangle.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'namespace ShapeTracker.Models\n{\n  public class Triangle\n  {\n    ... // other code omitted for brevity\n\n    public string CheckType()\n    {\n      return "not a triangle";\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"While the above is technically the very least amount of code to get our test to pass, we may feel more comfortable adding the actual branching logic that tests whether a triangle is not a triangle, since, at some point we will need that logic to accurately determine if a triangle is not a triangle:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'if ((_side1 > (Side2 + _side3)) || (Side2 > (_side1 + _side3)) || (_side3 > (_side1 + Side2)))\n{\n  return "not a triangle";\n} \n'})}),"\n",(0,i.jsx)(t.p,{children:"Both approaches are acceptable."}),"\n",(0,i.jsx)(t.h3,{id:"5--run-the-automated-test-to-confirm-it-passes-if-it-doesnt-revisit-step-4",children:"5.  Run the automated test to confirm it passes. If it doesn't, revisit step 4."}),"\n",(0,i.jsx)(t.p,{children:"We'll run our tests again, and confirm that our tests are passing:"}),"\n",(0,i.jsxs)(t.pre,{children:[(0,i.jsx)(t.code,{style:{color:"green"},children:"\nPassed!  - Failed:     0, Passed:     8, Skipped:     0, Total:     8, Duration: 91 ms - ShapeTracker.Tests.dll (net6.0)\n"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"steps-6-and-7",children:"Steps 6 and 7"}),"\n",(0,i.jsx)(t.p,{children:"We can confirm that all previous tests still pass and there are no opportunities for refactoring yet."}),"\n",(0,i.jsx)(t.h3,{id:"steps-8-and-9",children:"Steps 8 and 9"}),"\n",(0,i.jsx)(t.p,{children:"We'll commit our passing code and move onto the next simplest behavior."}),"\n",(0,i.jsxs)(t.h2,{id:"testing-the-scalene-triangle-path-in-the-checktype-method",children:["Testing the ",(0,i.jsx)(t.code,{children:'"scalene triangle"'})," Path in the ",(0,i.jsx)(t.code,{children:"CheckType()"})," Method"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"1--identify-the-simplest-possible-behavior-the-program-must-exhibit-1",children:"1.  Identify the simplest possible behavior the program must exhibit."}),"\n",(0,i.jsxs)(t.p,{children:["The second behavior we want to handle is when a triangle is ",(0,i.jsx)(t.code,{children:'"scalene triangle"'}),", which is when no side is the same length."]}),"\n",(0,i.jsx)(t.h3,{id:"2--write-a-coded-test-for-this-behavior-1",children:"2.  Write a coded test for this behavior."}),"\n",(0,i.jsx)(t.p,{children:"Here's our new test:"}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ShapeTracker.Solution/ShapeTracker.Tests/ModelTests/TriangleTests.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'using Microsoft.VisualStudio.TestTools.UnitTesting;\nusing ShapeTracker.Models;\n\nnamespace ShapeTracker.Tests\n{\n  [TestClass]\n  public class TriangleTests\n  {\n\n    ... // 8 tests omitted for brevity\n\n    [TestMethod]\n    public void CheckType_DeterminesWhenScalene_String()\n    {\n      // Arrange\n      Triangle scaleneTri = new Triangle(3, 4, 5);\n      // Act\n      string triType = scaleneTri.CheckType();\n      // Assert\n      Assert.AreEqual("scalene triangle", triType);\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"3--before-coding-confirm-the-test-fails-1",children:"3.  Before coding, confirm the test fails."}),"\n",(0,i.jsxs)(t.p,{children:["When we run ",(0,i.jsx)(t.code,{children:"dotnet test"})," in the ",(0,i.jsx)(t.code,{children:"ShapeTracker.Tests"})," directory, we'll finally get our first failed test!"]}),"\n",(0,i.jsxs)(t.pre,{children:[(0,i.jsx)(t.code,{style:{color:"red"},children:"\n  Failed CheckType_DeterminesWhenScalene_String [59 ms]\n  Error Message:\n   Assert.AreEqual failed. Expected:<scalene>. Actual:<not a triangle>.\n  Stack Trace:\n     at ShapeTracker.Tests.TriangleTests.CheckType_DeterminesWhenScalene_String() in C:\\Users\\staff\\Desktop\\ShapeTracker.Solution\\ShapeTracker.Tests\\ModelTests\\TriangleTests.cs:line 107\n\n\nFailed!  - Failed:     1, Passed:     8, Skipped:     0, Total:     9, Duration: 117 ms - ShapeTracker.Tests.dll (net6.0)\n"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"MSTest gives us helpful output about what went wrong:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["We can read the name of the test method that failed, ",(0,i.jsx)(t.code,{children:"CheckType_DeterminesWhenScalene_String"})]}),"\n",(0,i.jsxs)(t.li,{children:["We can see the values for what we expect, ",(0,i.jsx)(t.code,{children:"Expected:<scalene>"}),", versus what we actually got, ",(0,i.jsx)(t.code,{children:"Actual:<not a triangle>"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["We can see a stack trace that takes us to the failed ",(0,i.jsx)(t.code,{children:"Assert.AreEqual()"})," method on line 107 of ",(0,i.jsx)(t.code,{children:"TriangleTests.cs"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"This failed test is confirming there are no false positives. How? Because we haven't implemented any code for our test to pass, and we wrote our test so that it should pass."}),"\n",(0,i.jsx)(t.h3,{id:"4--implement-the-behavior-with-the-least-amount-of-code-possible-1",children:"4.  Implement the behavior with the least amount of code possible."}),"\n",(0,i.jsxs)(t.p,{children:["To implement the behavior with the least amount of code possible, we'll finally need branching, as well as to decide which outcome should come first in our branching, ",(0,i.jsx)(t.code,{children:'"not a triangle"'})," or ",(0,i.jsx)(t.code,{children:'"scalene triangle"'}),". Here's the updated ",(0,i.jsx)(t.code,{children:"Triangle.CheckType()"})," method:"]}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ShapeTracker/Models/Triangle.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'namespace ShapeTracker.Models\n{\n  public class Triangle\n  {\n    ... // other code omitted for brevity\n\n    public string CheckType()\n    {\n      if ((Side1 != Side2) && ((Side1 != _side3)) && ((Side2 != _side3))) \n      {\n        return "scalene triangle";\n      } \n      else \n      {\n        return "not a triangle";\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Within our ",(0,i.jsx)(t.code,{children:"if"})," branch, we've decided to check whether a triangle is scalene first, by verifying that none of the sides have the same value."]}),"\n",(0,i.jsxs)(t.p,{children:["With our ",(0,i.jsx)(t.code,{children:"else"})," branch, we handle all other cases, which so far is when a triangle is not a triangle."]}),"\n",(0,i.jsx)(t.h3,{id:"5--run-the-automated-test-to-confirm-it-passes-if-it-doesnt-revisit-step-4-1",children:"5.  Run the automated test to confirm it passes. If it doesn't, revisit step 4."}),"\n",(0,i.jsx)(t.p,{children:"Let's confirm that our new code passes our new test!"}),"\n",(0,i.jsxs)(t.pre,{children:[(0,i.jsx)(t.code,{style:{color:"red"},children:"\n  Failed CheckType_DeterminesWhenNotATriangle_String [36 ms]\n  Error Message:\n   Assert.AreEqual failed. Expected:<not a triangle>. Actual:<scalene>.\n  Stack Trace:\n     at ShapeTracker.Tests.TriangleTests.CheckType_DeterminesWhenNotATriangle_String() in C:\\Users\\staff\\Desktop\\ShapeTracker.Solution\\ShapeTracker.Tests\\ModelTests\\TriangleTests.cs:line 96\n\n\nFailed!  - Failed:     1, Passed:     8, Skipped:     0, Total:     9, Duration: 130 ms - ShapeTracker.Tests.dll (net6.0)\n"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Hmm... we're getting an error, but it is different than last time: it says our test method ",(0,i.jsx)(t.code,{children:"CheckType_DeterminesWhenNotATriangle_String()"})," has failed, with an expected output of ",(0,i.jsx)(t.code,{children:'"not a triangle"'}),", but an actual output of ",(0,i.jsx)(t.code,{children:'"scalene triangle"'}),". This means the new code we implemented worked for the new test, but broke a previous test!"]}),"\n",(0,i.jsx)(t.p,{children:"This is a good reminder to carefully review the error messages we get to really figure out what's wrong."}),"\n",(0,i.jsx)(t.h3,{id:"again-4--implement-the-behavior-with-the-least-amount-of-code-possible",children:"(Again) 4.  Implement the behavior with the least amount of code possible."}),"\n",(0,i.jsxs)(t.p,{children:["Let's fix this. The issue in our code is that our ",(0,i.jsx)(t.code,{children:"notATriangle"})," variable in our test method ",(0,i.jsx)(t.code,{children:"CheckType_DeterminesWhenNotATriangle_String()"})," (in ",(0,i.jsx)(t.code,{children:"TriangleTests.cs"}),") that has the values of 3, 4, and 88 match with the requirements we set for scalene triangles, which is for none of the sides to have the same value."]}),"\n",(0,i.jsxs)(t.p,{children:["So what's our solution? We need the logic for the ",(0,i.jsx)(t.code,{children:'"not a triangle"'})," path to come first, before the logic for the ",(0,i.jsx)(t.code,{children:'"scalene triangle"'})," path."]}),"\n",(0,i.jsxs)(t.p,{children:["Here's our updated ",(0,i.jsx)(t.code,{children:"CheckType()"})," method:"]}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ShapeTracker/Models/Triangle.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'namespace ShapeTracker.Models\n{\n  public class Triangle\n  {\n    ... // other code omitted for brevity\n\n    public string CheckType()\n    {\n      if ((Side1 > (Side2 + _side3)) || (Side2 > (Side1 + _side3)) || (_side3 > (Side1 + Side2))) \n      {\n        return "not a triangle";\n      } \n      else if ((Side1 != Side2) && ((Side1 != _side3)) && ((Side2 != _side3))) \n      {\n        return "scalene triangle";\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"5--run-the-automated-test-to-confirm-it-passes-if-it-doesnt-revisit-step-4-2",children:"5.  Run the automated test to confirm it passes. If it doesn't, revisit step 4."}),"\n",(0,i.jsx)(t.p,{children:"Let's run our tests again. When we do, we'll get a compiler error, one that we haven't seen before:"}),"\n",(0,i.jsxs)(t.pre,{children:[(0,i.jsx)(t.code,{style:{color:"red"},children:"\nC:\\Users\\staff\\Desktop\\ShapeTracker.Solution\\ShapeTracker\\Models\\Triangle.cs(31,19): error CS0161: 'Triangle.CheckType()': not all code paths return a value [C:\\Users\\staff\\Desktop\\ShapeTracker.Solution\\ShapeTracker\\ShapeTracker.csproj]\n"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The current issue is letting us know that our code is not returning a ",(0,i.jsx)(t.code,{children:"string"})," in all paths of the ",(0,i.jsx)(t.code,{children:"Triangle.CheckType()"})," method. We do return a ",(0,i.jsx)(t.code,{children:"string"})," in the ",(0,i.jsx)(t.code,{children:"if"})," statement and the ",(0,i.jsx)(t.code,{children:"else if"})," statement, but what happens if our triangle's sides do not match with the ",(0,i.jsx)(t.code,{children:"if "})," or ",(0,i.jsx)(t.code,{children:"else if"})," statement? Nothing happens, which violates C#'s strict rules, in this case, that our ",(0,i.jsx)(t.code,{children:"CheckType()"})," method needs to return a ",(0,i.jsx)(t.code,{children:"string"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["We can resolve this compiler error in a few ways. We could turn our ",(0,i.jsx)(t.code,{children:"else if"})," into an ",(0,i.jsx)(t.code,{children:"else"})," statement that returns ",(0,i.jsx)(t.code,{children:'"scalene triangle"'}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'    public string CheckType()\n    {\n      if ((Side1 > (Side2 + _side3)) || (Side2 > (Side1 + _side3)) || (_side3 > (Side1 + Side2))) \n      {\n        return "not a triangle";\n      } \n      else \n      {\n        return "scalene triangle";\n      }\n    }\n'})}),"\n",(0,i.jsx)(t.p,{children:"Doing this makes the most sense in terms of coding incrementally. The downside, however, is that we would lose the work we've already done."}),"\n",(0,i.jsxs)(t.p,{children:["Another option is to keep the code we wrote as-is, and add an new ",(0,i.jsx)(t.code,{children:"else"})," statement that returns an empty string."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'    public string CheckType()\n    {\n      if ((Side1 > (Side2 + _side3)) || (Side2 > (Side1 + _side3)) || (_side3 > (Side1 + Side2))) \n      {\n        return "not a triangle";\n      } \n      else if ((Side1 != Side2) && ((Side1 != _side3)) && ((Side2 != _side3))) \n      {\n        return "scalene triangle";\n      }\n      else\n      {\n        return "";\n      }\n    }\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Either approach is fine. This time, we'll opt for this second approach. Update the ",(0,i.jsx)(t.code,{children:"Triangle.CheckType()"})," accordingly."]}),"\n",(0,i.jsx)(t.h3,{id:"5--run-the-automated-test-to-confirm-it-passes-if-it-doesnt-revisit-step-4-3",children:"5.  Run the automated test to confirm it passes. If it doesn't, revisit step 4."}),"\n",(0,i.jsx)(t.p,{children:"We'll run our tests again, and confirm that our tests are passing:"}),"\n",(0,i.jsxs)(t.pre,{children:[(0,i.jsx)(t.code,{style:{color:"green"},children:"\nPassed!  - Failed:     0, Passed:     9, Skipped:     0, Total:     8, Duration: 91 ms - ShapeTracker.Tests.dll (net6.0)\n"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"steps-6-and-7-1",children:"Steps 6 and 7"}),"\n",(0,i.jsx)(t.p,{children:"We can also confirm that all previous tests still pass and there are no opportunities for refactoring yet."}),"\n",(0,i.jsx)(t.h3,{id:"steps-8-and-9-1",children:"Steps 8 and 9"}),"\n",(0,i.jsx)(t.p,{children:"We'll commit our passing code and move onto the next simplest behavior."}),"\n",(0,i.jsxs)(t.h2,{id:"testing-the-isosceles-triangle-path-in-the-checktype-method",children:["Testing the ",(0,i.jsx)(t.code,{children:'"isosceles triangle"'})," Path in the ",(0,i.jsx)(t.code,{children:"CheckType()"})," Method"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"1--identify-the-simplest-possible-behavior-the-program-must-exhibit-2",children:"1.  Identify the simplest possible behavior the program must exhibit."}),"\n",(0,i.jsxs)(t.p,{children:["The next behavior we want to handle is when a triangle is ",(0,i.jsx)(t.code,{children:'"isosceles triangle"'}),", which is when only two of the sides have the same length, but not the other."]}),"\n",(0,i.jsx)(t.h3,{id:"2--write-a-coded-test-for-this-behavior-2",children:"2.  Write a coded test for this behavior."}),"\n",(0,i.jsx)(t.p,{children:"Here's our new test:"}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ShapeTracker.Solution/ShapeTracker.Tests/ModelTests/TriangleTests.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'using Microsoft.VisualStudio.TestTools.UnitTesting;\nusing ShapeTracker.Models;\n\nnamespace ShapeTracker.Tests\n{\n  [TestClass]\n  public class TriangleTests\n  {\n\n    ... // 9 tests omitted for brevity\n\n    [TestMethod]\n    public void CheckType_DeterminesWhenIsosceles_String()\n    {\n      // Arrange\n      Triangle isoscelesTri = new Triangle(5, 4, 4);\n      // Act\n      string triType = isoscelesTri.CheckType();\n      // Assert\n      Assert.AreEqual("isosceles triangle", triType);\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"3--before-coding-confirm-the-test-fails-2",children:"3.  Before coding, confirm the test fails."}),"\n",(0,i.jsxs)(t.p,{children:["When we run ",(0,i.jsx)(t.code,{children:"dotnet test"})," in the ",(0,i.jsx)(t.code,{children:"ShapeTracker.Tests"})," directory, we'll see we have a failed test, which confirms that we do not have any false positives."]}),"\n",(0,i.jsxs)(t.pre,{children:[(0,i.jsx)(t.code,{style:{color:"red"},children:"\n  Failed CheckType_DeterminesWhenIsosceles_String [55 ms]\n  Error Message:\n   Assert.AreEqual failed. Expected:<isosceles>. Actual:<>.\n  Stack Trace:\n     at ShapeTracker.Tests.TriangleTests.CheckType_DeterminesWhenIsosceles_String() in C:\\Users\\staff\\Desktop\\ShapeTracker.Solution\\ShapeTracker.Tests\\ModelTests\\TriangleTests.cs:line 118\n\n\nFailed!  - Failed:     1, Passed:     9, Skipped:     0, Total:    10, Duration: 197 ms - ShapeTracker.Tests.dll (net6.0)\n"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"4--implement-the-behavior-with-the-least-amount-of-code-possible-2",children:"4.  Implement the behavior with the least amount of code possible."}),"\n",(0,i.jsx)(t.p,{children:"Implementing the behavior in code to get our test passing will be simple this time:"}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ShapeTracker/Models/Triangle.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'namespace ShapeTracker.Models\n{\n  public class Triangle\n  {\n    ... // other code omitted for brevity\n\n    public string CheckType()\n    {\n      if ((Side1 > (Side2 + _side3)) || (Side2 > (Side1 + _side3)) || (_side3 > (Side1 + Side2))) \n      {\n        return "not a triangle";\n      } \n      else if ((Side1 != Side2) && ((Side1 != _side3)) && ((Side2 != _side3))) \n      {\n        return "scalene triangle";\n      }\n      else \n      {\n        return "isosceles triangle";\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["We've simply updated our ",(0,i.jsx)(t.code,{children:"else"})," statement to return ",(0,i.jsx)(t.code,{children:'"isosceles triangle"'}),". When we implement the last behavior (",(0,i.jsx)(t.code,{children:'"equilateral triangle"'}),"), we'll have to update this logic again."]}),"\n",(0,i.jsx)(t.h3,{id:"5--run-the-automated-test-to-confirm-it-passes-if-it-doesnt-revisit-step-4-4",children:"5.  Run the automated test to confirm it passes. If it doesn't, revisit step 4."}),"\n",(0,i.jsx)(t.p,{children:"We'll run our tests again, and confirm that our tests are passing:"}),"\n",(0,i.jsxs)(t.pre,{children:[(0,i.jsx)(t.code,{style:{color:"green"},children:"\nPassed!  - Failed:     0, Passed:     10, Skipped:     0, Total:     8, Duration: 91 ms - ShapeTracker.Tests.dll (net6.0)\n"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"steps-6-and-7-2",children:"Steps 6 and 7"}),"\n",(0,i.jsx)(t.p,{children:"We can also confirm that all previous tests still pass and there are no opportunities for refactoring yet."}),"\n",(0,i.jsx)(t.h3,{id:"steps-8-and-9-2",children:"Steps 8 and 9"}),"\n",(0,i.jsx)(t.p,{children:"We'll commit our passing code and move onto the next simplest behavior."}),"\n",(0,i.jsxs)(t.h2,{id:"testing-the-equilateral-triangle-path-in-the-checktype-method",children:["Testing the ",(0,i.jsx)(t.code,{children:'"equilateral triangle"'})," Path in the ",(0,i.jsx)(t.code,{children:"CheckType()"})," Method"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"1--identify-the-simplest-possible-behavior-the-program-must-exhibit-3",children:"1.  Identify the simplest possible behavior the program must exhibit."}),"\n",(0,i.jsxs)(t.p,{children:["The next behavior we want to handle is when a triangle is ",(0,i.jsx)(t.code,{children:'"equilateral triangle"'}),", which is when all three of the sides have the same length, but not the other."]}),"\n",(0,i.jsx)(t.h3,{id:"2--write-a-coded-test-for-this-behavior-3",children:"2.  Write a coded test for this behavior."}),"\n",(0,i.jsx)(t.p,{children:"Here's our new test:"}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ShapeTracker.Solution/ShapeTracker.Tests/ModelTests/TriangleTests.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'using Microsoft.VisualStudio.TestTools.UnitTesting;\nusing ShapeTracker.Models;\n\nnamespace ShapeTracker.Tests\n{\n  [TestClass]\n  public class TriangleTests\n  {\n\n    ... // 10 tests omitted for brevity\n\n    [TestMethod]\n    public void CheckType_DeterminesWhenEquilateral_String()\n    {\n      // Arrange\n      Triangle equiTri = new Triangle(4, 4, 4);\n      // Act\n      string triType = equiTri.CheckType();\n      // Assert\n      Assert.AreEqual("equilateral triangle", triType);\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"3--before-coding-confirm-the-test-fails-3",children:"3.  Before coding, confirm the test fails."}),"\n",(0,i.jsxs)(t.p,{children:["When we run ",(0,i.jsx)(t.code,{children:"dotnet test"})," in the ",(0,i.jsx)(t.code,{children:"ShapeTracker.Tests"})," directory, we'll see we have a failed test, which confirms that we do not have any false positives."]}),"\n",(0,i.jsxs)(t.pre,{children:[(0,i.jsx)(t.code,{style:{color:"red"},children:"\n  Failed CheckType_DeterminesWhenEquilateral_String [41 ms]\n  Error Message:\n   Assert.AreEqual failed. Expected:<equilateral>. Actual:<isosceles>.\n  Stack Trace:\n     at ShapeTracker.Tests.TriangleTests.CheckType_DeterminesWhenEquilateral_String() in C:\\Users\\staff\\Desktop\\ShapeTracker.Solution\\ShapeTracker.Tests\\ModelTests\\TriangleTests.cs:line 129\n\n\nFailed!  - Failed:     1, Passed:    10, Skipped:     0, Total:    11, Duration: 147 ms - ShapeTracker.Tests.dll (net6.0)\n"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"4--implement-the-behavior-with-the-least-amount-of-code-possible-3",children:"4.  Implement the behavior with the least amount of code possible."}),"\n",(0,i.jsxs)(t.p,{children:["We'll need to update our branching to accommodate a new path for ",(0,i.jsx)(t.code,{children:'"equilateral triangle"'}),". Here's how we'll update our code in ",(0,i.jsx)(t.code,{children:"Triangle.cs"}),":"]}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"ShapeTracker/Models/Triangle.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'namespace ShapeTracker.Models\n{\n  public class Triangle\n  {\n    ... // other code omitted for brevity\n\n    public string CheckType()\n    {\n      if ((Side1 > (Side2 + _side3)) || (Side2 > (Side1 + _side3)) || (_side3 > (Side1 + Side2)))\n      {\n        return "not a triangle";\n      } \n      else if ((Side1 != Side2) && ((Side1 != _side3)) && ((Side2 != _side3))) \n      {\n        return "scalene triangle";\n      }  \n      else if ((Side1 == Side2) && (Side1 == _side3)) \n      {\n        return "equilateral triangle";\n      } \n      else \n      {\n        return "isosceles triangle";\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["It's easier to test for an equilateral triangle than an isosceles triangle, so we've left our ",(0,i.jsx)(t.code,{children:"else"})," statement to return ",(0,i.jsx)(t.code,{children:'"isosceles triangle"'}),", and we've created a new ",(0,i.jsx)(t.code,{children:"else if"})," statement to check for equilateral triangles."]}),"\n",(0,i.jsx)(t.h3,{id:"5--run-the-automated-test-to-confirm-it-passes-if-it-doesnt-revisit-step-4-5",children:"5.  Run the automated test to confirm it passes. If it doesn't, revisit step 4."}),"\n",(0,i.jsx)(t.p,{children:"Let's see if the code we added passes our test!"}),"\n",(0,i.jsxs)(t.pre,{children:[(0,i.jsx)(t.code,{style:{color:"green"},children:"\nPassed!  - Failed:     0, Passed:     11, Skipped:     0, Total:     8, Duration: 91 ms - ShapeTracker.Tests.dll (net6.0)\n"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"And it does! Sweet."}),"\n",(0,i.jsx)(t.h3,{id:"steps-6-and-7-3",children:"Steps 6 and 7"}),"\n",(0,i.jsx)(t.p,{children:"We can also confirm that all previous tests still pass and there are no opportunities for refactoring yet."}),"\n",(0,i.jsx)(t.h3,{id:"steps-8-and-9-3",children:"Steps 8 and 9"}),"\n",(0,i.jsxs)(t.p,{children:["We'll commit our passing code and move onto the next simplest behavior. Up next, we'll write tests for static members and learn how to use the ",(0,i.jsx)(t.code,{children:"CollectionAssert.AreEqual()"})," assertion method from MSTest."]})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);