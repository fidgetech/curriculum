"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[40204],{15840:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/delete-branch-02c2f6df1ba74171e4f361a3acf83134.png"},27297:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/resolved-conflict-60032882625ae13d05a463a9fe7a5f13.png"},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(96540);const a={},i=s.createContext(a);function o(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:t},e.children)}},31455:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/click-resolve-conflicts-6f5fa46e95771d93607ffb2863b46d75.png"},62175:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/list-of-pull-requests-183a5477be8fea76c64c6a24e2d619ce.png"},69829:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"react/team-week/3-6-0-9-pull-requests-with-branches","title":"\ud83d\udcd3 3.6.0.9 Pull Requests with Branches","description":"In this lesson, we\'ll practice making pull requests with branches. This is a common workflow in the industry. In this workflow, a developer pulls down the latest code from the main branch and creates a new branch. When a feature is completed, the new branch is committed and pushed to GitHub. Then the developer makes a pull request so the code can be merged into the main branch via GitHub\'s UI.","source":"@site/versioned_docs/version-WIP/3_react/6_team-week/3-6-0-09-pull-requests-with-branches.md","sourceDirName":"3_react/6_team-week","slug":"/react/team-week/3-6-0-9-pull-requests-with-branches","permalink":"/WIP/react/team-week/3-6-0-9-pull-requests-with-branches","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 3.6.0.9 Pull Requests with Branches","day":"weekend","id":"3-6-0-9-pull-requests-with-branches","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 3.6.0.8 Backend Course Preparation: Software Installation","permalink":"/WIP/react/team-week/3-6-0-8-backend-course-preparation-software-installation"},"next":{"title":"\ud83d\udcd3 3.6.0.10 Pull Requests with Forks","permalink":"/WIP/react/team-week/3-6-0-10-pull-requests-with-forks"}}');var a=n(74848),i=n(28453);const o={title:"\ud83d\udcd3 3.6.0.9 Pull Requests with Branches",day:"weekend",id:"3-6-0-9-pull-requests-with-branches",hide_table_of_contents:!0},r=void 0,l={},h=[{value:"Pull Requests with Branches",id:"pull-requests-with-branches",level:2},{value:"Creating a Pull Request",id:"creating-a-pull-request",level:3},{value:"Approving a Pull Request",id:"approving-a-pull-request",level:3},{value:"Dealing with Merge Conflicts",id:"dealing-with-merge-conflicts",level:2}];function c(e){const t={a:"a",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"In this lesson, we'll practice making pull requests with branches. This is a common workflow in the industry. In this workflow, a developer pulls down the latest code from the main branch and creates a new branch. When a feature is completed, the new branch is committed and pushed to GitHub. Then the developer makes a pull request so the code can be merged into the main branch via GitHub's UI."}),"\n",(0,a.jsxs)(t.p,{children:["We've already learned one way to merge our code into the main branch in ",(0,a.jsx)(t.a,{href:"../../react/team-week/4-6-0-1-team-week-objectives",children:"Practicing the Git Workflow"}),". While it's important to be fluent in this workflow, it doesn't allow for any oversight of the process. All of the merging happens locally."]}),"\n",(0,a.jsxs)(t.p,{children:["In the case of group projects, the entire team should be able to comment on and merge pull requests. In order to do so, everyone must be a collaborator on the project. See the ",(0,a.jsx)(t.a,{href:"../../c-and-net/team-project/3-7-0-2-git-with-collaborators-setup",children:"Git with Collaborators Setup"})," lesson for instructions on adding collaborators."]}),"\n",(0,a.jsx)(t.h2,{id:"pull-requests-with-branches",children:"Pull Requests with Branches"}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.p,{children:"Once again, we'll create a very simple project with a README to walk through the process of making pull requests. After all, the goal isn't to code here \u2014 it's to practice a new git workflow."}),"\n",(0,a.jsxs)(t.p,{children:["Start by creating a repository in GitHub called ",(0,a.jsx)(t.code,{children:"pr-practice"}),". Clone that down to your local machine and add a README with the following text:"]}),"\n",(0,a.jsx)(t.div,{className:"filename",children:"README.md"}),"\n```\nThis code needs some updates. Fork it and make a pull request!\n```\n",(0,a.jsx)(t.p,{children:"Next, commit this code and push it back to the main branch. We need to have some starter code before we practice our new git workflow."}),"\n",(0,a.jsxs)(t.p,{children:["Next, create a branch called ",(0,a.jsx)(t.code,{children:"new-feature"})," locally:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"$ git checkout -b new-feature\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Now let's update our README (in the local ",(0,a.jsx)(t.code,{children:"new-feature"})," branch, not in the GitHub UI):"]}),"\n",(0,a.jsx)(t.div,{className:"filename",children:"README.md"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"This code needs some updates. Fork it and make a pull request!\n\nNew feature added!\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Next, we need to save and commit our code. Finally, we'll push our ",(0,a.jsx)(t.code,{children:"new-feature"})," branch to GitHub. As of now, it only exists locally."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"$ git push origin new-feature\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Now our ",(0,a.jsx)(t.code,{children:"new-feature"})," branch exists both locally and remotely, but it still hasn't been merged into the main branch yet."]}),"\n",(0,a.jsx)(t.p,{children:"At this point, we're ready to make our first pull request."}),"\n",(0,a.jsx)(t.h3,{id:"creating-a-pull-request",children:"Creating a Pull Request"}),"\n",(0,a.jsxs)(t.p,{children:["At this point, we can go to the repository in GitHub and click on the ",(0,a.jsx)(t.em,{children:"Branches"})," tab. This will show all of the branches you've created as well as all of the active branches in the project."]}),"\n",(0,a.jsx)(t.p,{children:"![We can see all the active branches in our project.]\n(/images/Intermediate+JavaScript/making-pr-requests/click-on-pr-request-button.png)"}),"\n",(0,a.jsxs)(t.p,{children:["In the image above, we can also see that our branches have a button on the right side of the screen that reads ",(0,a.jsx)(t.em,{children:"New Pull Request"}),". That's exactly what we want. Click on this button to open a new pull request."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Note:"})," If you don't see the branch you've been working on in GitHub, that probably means it only exists locally. Make sure to commit and push the branch and then refresh GitHub."]}),"\n",(0,a.jsxs)(t.p,{children:["Once we click on the ",(0,a.jsx)(t.em,{children:"New Pull Request"})," button, we'll be taken to a screen that looks like this:"]}),"\n",(0,a.jsx)(t.p,{children:"![Image shows screen with option to add comment and create pull request.]\n(/images/Intermediate+JavaScript/making-pr-requests/add-a-comment-to-pr.png)"}),"\n",(0,a.jsx)(t.p,{children:"There are several important things to note about this screen."}),"\n",(0,a.jsxs)(t.p,{children:["First, at the top, we see two dropdowns. The one on the left reads ",(0,a.jsx)(t.em,{children:"base: main"}),". The one on the right reads _compare: ",(0,a.jsx)(t.em,{children:"new_feature"}),". Then, just to the right of that, we see a green message with a checkbox that says ",(0,a.jsx)(t.em,{children:"Able to merge."})]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Base"})," is the branch we want to merge our new feature ",(0,a.jsx)(t.em,{children:"into"}),". It will often be the main branch but not always. For instance, if we also had a development branch, we might want to target that branch with our PR instead."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Compare"})," is the branch that includes the code we want to merge. In this case, it's the ",(0,a.jsx)(t.code,{children:"new-feature"})," branch. However, we could also change it to be another branch instead. Why is it ",(0,a.jsx)(t.em,{children:"compare"})," instead of ",(0,a.jsx)(t.em,{children:"merge"}),"? Well, just because we are creating a PR doesn't mean the code will eventually be merged. It is just a request. We are asking someone else to review the code and compare it. Based on that, the reviewers will determine whether the PR should be merged, if it needs more changes, or if it should be rejected outright."]}),"\n",(0,a.jsxs)(t.p,{children:["Next, we have an ",(0,a.jsx)(t.em,{children:"Able to merge"})," message. This is important. This verifies that our PR, if it is approved, can be merged without any conflicts. We can still make a PR even if it will cause merge conflicts but in general we want to avoid that if possible. Merge conflicts are often a sign that developers haven't been communicating about the code they are working on, resulting in two sets of code that has conflicts. We will work through an example of a PR with merge conflicts after we are finished creating and merging this PR."]}),"\n",(0,a.jsx)(t.p,{children:"Next, we need to give our PR a title and add a comment. It's important to communicate clearly and concisely. While it's technically optional to add a comment to a PR, doing so (and having a clear title) makes it easier for reviewers to see what your PR is supposed to do. In an actual job, you should always strive to have good communication. Your senior devs will not be happy if they have to review poor PRs that create more work for them."}),"\n",(0,a.jsxs)(t.p,{children:["Once this is done, we can click on ",(0,a.jsx)(t.em,{children:"Create pull request"}),". There are actually two options here. We can click on the dropdown attached to the button to have an option to ",(0,a.jsx)(t.em,{children:"Create Draft Pull Request"}),". This simply means that the PR can't be merged until you mark it ready for review. Generally, we'll be making PRs only when the code is ready to merge. However, a draft pull request can be helpful because it allows others to see the new code \u2014 and comment on it \u2014 while it's still in progress."]}),"\n",(0,a.jsxs)(t.p,{children:["Click on ",(0,a.jsx)(t.em,{children:"Create pull request"})," and we're done making the request."]}),"\n",(0,a.jsx)(t.h3,{id:"approving-a-pull-request",children:"Approving a Pull Request"}),"\n",(0,a.jsxs)(t.p,{children:["After we create the pull request, GitHub will display the page with the pull request. We can also navigate to our new PR, or any other PR in the repository, by clicking on the ",(0,a.jsx)(t.em,{children:"Pull requests"})," tab in the repository."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"See a list of pull requests in the repository.",src:n(62175).A+"",width:"2362",height:"772"})}),"\n",(0,a.jsxs)(t.p,{children:["As we can see in the image above, the ",(0,a.jsx)(t.em,{children:"New feature"})," title isn't so great \u2014 it's fine for practice, but if we had many pull requests, the purpose of this one wouldn't be clear."]}),"\n",(0,a.jsx)(t.p,{children:"The image below shows the page for the PR itself:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"PR page gives us several options which we&#39;ll discuss below.",src:n(79292).A+"",width:"1746",height:"1018"})}),"\n",(0,a.jsx)(t.p,{children:"There are several important things to note about the PR page:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"The PR will show a list of commits. If we need to, we can click on any of the commits to review the code. This is one thing a senior dev would do before approving the PR. (Note that the image above doesn't show the list of commits but you'll see it in your own UI.)"}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["As the image above shows, ",(0,a.jsx)(t.em,{children:"This branch has no conflicts with the base branch"}),". We already know that. The good news here is that we can easily merge without running into conflicts."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["The green button gives us the option to ",(0,a.jsx)(t.em,{children:"Merge pull request"}),". You can also click on the dropdown by this button to choose to ",(0,a.jsx)(t.em,{children:"Squash and merge"})," or ",(0,a.jsx)(t.em,{children:"Rebase and merge"}),". Generally, we will just click ",(0,a.jsx)(t.em,{children:"Merge pull request"}),". The advantage of ",(0,a.jsx)(t.em,{children:"Squash and merge"})," is that it will take all the commits from the PR and squash it down into one commit. This makes the commit history on our main branch tidier. For instance, if we added a navbar, we could ",(0,a.jsx)(t.em,{children:"Squash and merge"})," to a single commit that reads ",(0,a.jsx)(t.code,{children:"complete navbar feature"}),". Finally, ",(0,a.jsx)(t.em,{children:"Rebase and merge"})," means that we can reorganize and rewrite all the commits. However, rebasing should be avoided unless it's necessary due to a poor commit history."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["At the bottom of the page, we can leave a comment. There's also a ",(0,a.jsx)(t.em,{children:"Close pull request"})," button (if you have privileges to close pull requests, which you will in your own account). We'd only click the ",(0,a.jsx)(t.em,{children:"Close pull request"})," button if we want to reject it."]}),"\n",(0,a.jsx)(t.p,{children:"The comments are a great place to discuss the PR, including any changes or updates that should be made to it. Try adding a message for practice."}),"\n",(0,a.jsxs)(t.p,{children:["Now let's click on the ",(0,a.jsx)(t.em,{children:"Merge pull request"})," button to actually merge the pull request. We can name this commit whatever we want and then click ",(0,a.jsx)(t.em,{children:"Confirm merge"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["Once the branch is merged, we'll be given the option to delete it by clicking on the ",(0,a.jsx)(t.em,{children:"Delete Branch"})," button."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"We can click on the Delete Branch button to delete it.",src:n(15840).A+"",width:"1758",height:"218"})}),"\n",(0,a.jsx)(t.p,{children:"Generally, once a feature is complete, the branch should be deleted. Then a new branch should be created for new features. For that reason, it's a good idea to delete the branch so it doesn't clutter the GitHub repository. The branch will still be available locally (unless it is deleted there, too)."}),"\n",(0,a.jsx)(t.p,{children:"If we were to continue working on that branch locally, we could still make a new PR with that branch later. That's actually what we'll do with our second PR \u2014 no need to create a new branch when we are focused on making and accepting pull requests in this lesson."}),"\n",(0,a.jsx)(t.p,{children:"Our first PR is complete! We've learned how to make a PR and approve it."}),"\n",(0,a.jsx)(t.h2,{id:"dealing-with-merge-conflicts",children:"Dealing with Merge Conflicts"}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.p,{children:"Let's create one more PR. This time around, we'll intentionally introduce a merge conflict. That way, we can practice resolving a merge conflict in the GitHub UI. While we want to avoid merge conflicts if possible, they will happen from time to time, and you should be prepared when it does."}),"\n",(0,a.jsx)(t.p,{children:"First, we need to introduce a merge conflict in our code. We'll start by making an update to the README in the GitHub UI. Click on the pencil icon by the README in GitHub and update the final line of the README to the following:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"New feature updated...\n"})}),"\n",(0,a.jsx)(t.p,{children:"Commit this code in GitHub."}),"\n",(0,a.jsxs)(t.p,{children:["Next, we'll make a change in the ",(0,a.jsx)(t.code,{children:"new-feature"})," branch locally. We'll update the final line to this:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"New feature changed...\n"})}),"\n",(0,a.jsx)(t.p,{children:"It's a fairly similar line of text, but just different enough to create a merge conflict."}),"\n",(0,a.jsx)(t.p,{children:"Save and commit this code. Next, push the branch to GitHub:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"$ git push origin new-feature\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Our ",(0,a.jsx)(t.code,{children:"new-feature"})," branch will be in direct conflict with the main branch \u2014 a great opportunity to practice resolving a conflict!"]}),"\n",(0,a.jsxs)(t.p,{children:["Go to the ",(0,a.jsx)(t.em,{children:"Branches"})," tab of the repository in GitHub and click on the ",(0,a.jsx)(t.em,{children:"New Pull Request"})," button to the right of the ",(0,a.jsx)(t.code,{children:"new-feature"})," branch. (In general, all of the steps involved in creating a PR will be the same as they were for our first PR.)"]}),"\n",(0,a.jsx)(t.p,{children:"Now, when we're taken to the page to make a PR, we'll see a message that states we can't automatically merge."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Message states we can&#39;t automatically merge.",src:n(82957).A+"",width:"2028",height:"554"})}),"\n",(0,a.jsx)(t.p,{children:"In our own projects, we should definitely heed this message if we weren't expecting a merge conflict. Generally, this means that two different teams have been working on the same code in different ways, which is a likely sign of a communication breakdown."}),"\n",(0,a.jsx)(t.p,{children:"Go ahead and submit the PR following the same steps as stated for our first PR. The only difference in this entire process is the message that states that we can't automatically merge the PR. If you need assistance, review the steps from when we created our first PR in the previous section of this lesson."}),"\n",(0,a.jsxs)(t.p,{children:["Now we're ready to merge our PR. If you haven't already, navigate to the PR in GitHub. Instead of the green ",(0,a.jsx)(t.em,{children:"Merge pull request"})," button, we'll see a new message:"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"This branch has conflicts that must be resolved.",src:n(31455).A+"",width:"1776",height:"614"})}),"\n",(0,a.jsxs)(t.p,{children:["The message reads ",(0,a.jsx)(t.em,{children:"This branch has conflicts that must be resolved"}),". We can click the button to the right of this message to ",(0,a.jsx)(t.em,{children:"Resolve conflicts"}),". Click that button now. The GitHub UI will allow us to resolve the merge conflicts."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"GitHub UI shows the merge conflict.",src:n(88666).A+"",width:"2350",height:"712"})}),"\n",(0,a.jsxs)(t.p,{children:["In this example, there is only one file with a merge conflict. However, if there are multiple files that have merge conflicts, we'll see the name of each file in the left-hand pane. At the top right hand corner of the pane, we'll see a greyed-out ",(0,a.jsx)(t.em,{children:"Mark as resolved"})," button. We cannot click this button until we remove all lines that indicate where the conflicts are. These lines will always include ",(0,a.jsx)(t.code,{children:"======="}),", ",(0,a.jsx)(t.code,{children:"<<<<<<<"}),", and ",(0,a.jsx)(t.code,{children:">>>>>>>"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["To the left of the ",(0,a.jsx)(t.em,{children:"Mark as resolved"})," button, we'll see a message in red that says ",(0,a.jsx)(t.em,{children:"1 conflict"})," \u2014 and then just to the right of that we'll see we can click ",(0,a.jsx)(t.em,{children:"Prev"})," and ",(0,a.jsx)(t.em,{children:"Next"}),". This is so we can navigate between files with conflicts. We can't do that here because we only have one conflict to resolve."]}),"\n",(0,a.jsx)(t.p,{children:"Fixing the issue itself is a bit more involved than doing so in VS Code. In VS Code, we can click whether we want the current, incoming, or both changes to take effect. In the GitHub UI, we have to modify the code manually."}),"\n",(0,a.jsxs)(t.p,{children:["The code below ",(0,a.jsx)(t.code,{children:"<<<<<<<"})," is the incoming change from the ",(0,a.jsx)(t.code,{children:"new-feature"})," branch. The code below ",(0,a.jsx)(t.code,{children:">>>>>>>"})," is the current change from the main branch. If the arrows mix you up, just focus on the names of the branches instead and keep in mind that the code in the branch you choose will take precedence."]}),"\n",(0,a.jsx)(t.p,{children:"This is how the code currently looks with GitHub's merge messages inserted:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"<<<<<<< new-feature\nNew feature changed...\n=======\nNew feature updated...\n>>>>>>>\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Assuming that we want to accept the code from the ",(0,a.jsx)(t.code,{children:"new-feature"})," (since that's the point of the PR), we'd remove ",(0,a.jsx)(t.code,{children:"<<<<<<< new-feature"})," and then also remove:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"=======\nNew feature updated...\n>>>>>>>\n"})}),"\n",(0,a.jsx)(t.p,{children:"That would leave just:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"New feature changed...\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Alternatively, we can modify the code in other ways as well as long as the GH merge conflict messages are removed. Once again, those are all the lines with ",(0,a.jsx)(t.code,{children:"======="}),", ",(0,a.jsx)(t.code,{children:"<<<<<<<"}),", and ",(0,a.jsx)(t.code,{children:">>>>>>>"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["When the merge conflict lines are removed, the ",(0,a.jsx)(t.em,{children:"Mark as resolved"})," button will no longer be greyed-out and we can click it. This is a nice little feature to ensure we don't accidentally leave any of those lines in our code."]}),"\n",(0,a.jsx)(t.p,{children:"Once our merge conflict is marked as resolved, we'll see some changes in the UI."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"We can now click the commit merge button.",src:n(27297).A+"",width:"2340",height:"594"})}),"\n",(0,a.jsxs)(t.p,{children:["Most importantly, we can now click ",(0,a.jsx)(t.em,{children:"Commit merge"}),". When we click on this button, we'll be able to make a new commit (as always, with a clear, concise commit message) that commits the changes we just made to resolve the conflict. At this point, we've just made a new commit, but we still haven't merged the PR yet! Now that the conflict is resolved, we'll see the green ",(0,a.jsx)(t.em,{children:"Merge pull request"})," button. We can click that button and finish merging the PR."]}),"\n",(0,a.jsx)(t.p,{children:"In this lesson, we made and merged two simple pull requests, including one with a merge conflict. We recommend practicing this workflow as you work on your group project \u2014 and give your project teammates the chance to look at your pull requests, make comments, and then approve them!"})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},79292:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/merge-pull-request-60409f57a3caf0b488b9d2d7bfa0a036.png"},82957:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/cant-automatically-merge-4f383752243d183891ba3ee30048a8ee.png"},88666:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/resolve-merge-conflict-4b5eb8d30ad6dbb323f1eaed74edaa76.png"}}]);