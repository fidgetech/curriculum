"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[9258],{28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var s=n(96540);const r={},a=s.createContext(r);function o(e){const t=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:t},e.children)}},28533:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"capstone/capstone-week-1/binary-search-trees-part-3","title":"\ud83d\udcd3 Binary Search Trees Part 3","description":"In this lesson, we\'ll write a basic method that traverses a binary search tree and lets us know whether the tree holds a value or not. There are actually a number of important algorithms that we can use to search trees \u2014 including depth-first search (DFS) algorithms and breadth-first search (BFS) algorithms, which search all the nodes in a tree. However, we are going to learn about those algorithms in the next section when we learn about graph theory. Because our tree is a binary search tree, it\'s much easier and quicker to find a specific node \u2014 and there is no reason to check every node in the tree to find a value, which is what we\'d need to do with a BFS or DFS.","source":"@site/docs/capstone/1_capstone-week-1/binary-search-trees-part-3.md","sourceDirName":"capstone/1_capstone-week-1","slug":"/capstone/capstone-week-1/binary-search-trees-part-3","permalink":"/v1.2/capstone/capstone-week-1/binary-search-trees-part-3","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":15,"frontMatter":{"title":"\ud83d\udcd3 Binary Search Trees Part 3","id":"binary-search-trees-part-3","slug":"binary-search-trees-part-3","hide_table_of_contents":true,"sidebar_position":15,"day":"monday","type":"lesson","url":"https://github.com/epicodus-curriculum/capstone/blob/main/5_binary_search_trees_part_3.md"},"sidebar":"capstone","previous":{"title":"\ud83d\udcd3 Binary Search Trees Part 2","permalink":"/v1.2/capstone/capstone-week-1/binary-search-trees-part-2"},"next":{"title":"\u270f\ufe0f Binary Search Trees Practice","permalink":"/v1.2/capstone/capstone-week-1/binary-search-trees-practice"}}');var r=n(74848),a=n(28453);const o={title:"\ud83d\udcd3 Binary Search Trees Part 3",id:"binary-search-trees-part-3",slug:"binary-search-trees-part-3",hide_table_of_contents:!0,sidebar_position:15,day:"monday",type:"lesson",url:"https://github.com/epicodus-curriculum/capstone/blob/main/5_binary_search_trees_part_3.md"},i=void 0,l={},h=[];function c(e){const t={code:"code",div:"div",em:"em",img:"img",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"In this lesson, we'll write a basic method that traverses a binary search tree and lets us know whether the tree holds a value or not. There are actually a number of important algorithms that we can use to search trees \u2014 including depth-first search (DFS) algorithms and breadth-first search (BFS) algorithms, which search all the nodes in a tree. However, we are going to learn about those algorithms in the next section when we learn about graph theory. Because our tree is a binary search tree, it's much easier and quicker to find a specific node \u2014 and there is no reason to check every node in the tree to find a value, which is what we'd need to do with a BFS or DFS."}),"\n",(0,r.jsxs)(t.p,{children:["Our method will borrow heavily from our ",(0,r.jsx)(t.code,{children:"BST.prototype.insertNode()"})," method \u2014 after all, just as that method traverses our tree to determine where a node should be inserted, our new method will do something very similar \u2014 except instead of inserting a new node, it will check to see if that node exists."]}),"\n",(0,r.jsxs)(t.p,{children:["As always, we will use TDD to write our method. First, though, we'll add a ",(0,r.jsx)(t.code,{children:"beforeEach"})," block where we'll recreate the perfect binary search tree we built in the last lesson:"]}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"__tests__/bst.test.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"import BST from '../src/bst.js';\nimport BSTNode from '../src/bst-node.js';\n\ndescribe('binarySearchTree', () => {\n\n const pbst = new BST();\n\n  beforeEach(() => {\n    pbst.insertNode(new BSTNode(4));\n    pbst.insertNode(new BSTNode(2));\n    pbst.insertNode(new BSTNode(6));\n    pbst.insertNode(new BSTNode(1));\n    pbst.insertNode(new BSTNode(3));\n    pbst.insertNode(new BSTNode(5));\n    pbst.insertNode(new BSTNode(7));  \n  });\n});\n"})}),"\n",(0,r.jsx)(t.p,{children:"As the diagram in the last lesson shows, this is how we can visually depict this binary search tree:"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"This binary search tree has an equal number of nodes on the left and right hand side.",src:n(67388).A+"",width:"481",height:"281"})}),"\n",(0,r.jsx)(t.p,{children:"Now we have a very basic tree that we can run our tests on."}),"\n",(0,r.jsxs)(t.p,{children:["As always, we should start with the simplest behavior. In this case, the simplest behavior would be no traversal at all \u2014 because the root node ",(0,r.jsx)(t.em,{children:"is"})," the value we are searching for."]}),"\n",(0,r.jsx)(t.p,{children:"Here's the test:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"__tests__/bst.test.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"...\n  test('it should return true if the root node is equal to 4', () => {\n    expect(pbst.search(4)).toEqual(true);\n  });\n...\n"})}),"\n",(0,r.jsx)(t.p,{children:"Getting it passing is simple:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"src/bst.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"class BST {\n...\n  search(value) {\n    return true;\n  }\n...\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"It's a very basic test but as always it's good to start with the simplest behavior. With very difficult problems, it's easy to get overwhelmed \u2014 but this gives us a starting point."}),"\n",(0,r.jsx)(t.p,{children:"What's the next simplest behavior? Well, what if the root node isn't the value we are looking for? We still aren't worried about traversal yet."}),"\n",(0,r.jsx)(t.p,{children:"Here's the test:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"__tests__/bst.test.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"...\n  test('it should return false if the root node is not equal to 31', () => {\n    expect(pbst.search(31)).toEqual(false);\n  });\n...\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Note that we've inputted a value (",(0,r.jsx)(t.code,{children:"31"}),") because this test will still ultimately pass once we are finished building our method."]}),"\n",(0,r.jsx)(t.p,{children:"And here's the code to get this passing:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"src/bst.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"...\n  search(value) {\n    if (this.root.data === value) {\n      return true;\n    }\n    return false;\n  }\n...\n"})}),"\n",(0,r.jsx)(t.p,{children:"We haven't done any traversal yet but we've set the groundwork to incrementally build on our method."}),"\n",(0,r.jsx)(t.p,{children:"Next, let's write a test to see if our method can traverse to the left. If we look at the diagram above, we can see that the left child of the root node of our perfect binary search tree has a value of 2. Our next test will check to see if that value exists:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"__tests__/bst.test.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"...\n  test('it should return true if the first child node on the left is equal to 2', () => {\n    expect(pbst.search(2)).toEqual(true);\n  });\n...\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The modifications we'll make to our method will look very similar to our ",(0,r.jsx)(t.code,{children:"BST.prototype.insertNode()"})," method. We'll need to add a while loop at this point."]}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"src/bst.test.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"search(value) {\n  if (this.root.data === value) {\n    return true;\n  } else {\n    let currentNode = this.root;\n    while (true) {\n      if (currentNode.data === value) {\n        return true;\n      } else if (currentNode.data > value) {\n        currentNode = currentNode.left;\n      }\n    }\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Just as we did with our ",(0,r.jsx)(t.code,{children:"BST.prototype.insertNode()"})," method, we'll start by creating a variable for the ",(0,r.jsx)(t.code,{children:"currentNode"}),". When this variable is declared, it will be assigned to ",(0,r.jsx)(t.code,{children:"this.root"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Then we'll have a loop that runs until a condition is met. Be careful here \u2014 the code above can easily be an infinite loop. In fact, if we run our tests now, there ",(0,r.jsx)(t.em,{children:"will"})," be an infinite loop. We'll fix that in a moment."]}),"\n",(0,r.jsxs)(t.p,{children:["If ",(0,r.jsx)(t.code,{children:"currentNode.data === value"}),", we've found the node \u2014 our method should ",(0,r.jsx)(t.code,{children:"return true"}),". Otherwise, if ",(0,r.jsx)(t.code,{children:"currentNode.data"})," (where we are in the tree) has a value greater than the value we've passed in, we know we need to go left."]}),"\n",(0,r.jsx)(t.p,{children:"Now let's go back to the problem with our tests. Adding this new condition creates an infinite loop. We can comment out the offending test to verify that our new test runs:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"__tests__/bst.test.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"...\n  // test('it should return false if the root node is not equal to 31', () => {\n  //   expect(pbst.search(31)).toEqual(false);\n  // });\n...\n"})}),"\n",(0,r.jsxs)(t.p,{children:["We'll be able to uncomment this test out once we write the code for traversing right in our binary search tree but we aren't there yet. For now, we can only traverse to the left \u2014 and there's no way we'll ever be able to correctly evaluate whether our tree contains the value ",(0,r.jsx)(t.code,{children:"31"})," just by going to the left."]}),"\n",(0,r.jsx)(t.p,{children:"Before we start testing and writing code for traversing to the right, there's one other thing we need to take care of. What if when we traverse to the left, there are no more nodes to traverse? Well, that would mean that the node we are looking for doesn't exist in the tree. Let's write a test for that, too:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"__tests__/bst.test.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"...\n  test('it should return if the value 0 is not in the tree', () => {\n    expect(pbst.search(0)).toEqual(false);\n  });\n...\n"})}),"\n",(0,r.jsx)(t.p,{children:"In order to pass this test, we just need to add one more conditional:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"src/bst.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"search(value) {\n  if (this.root.data === value) {\n    return true;\n  } else {\n    let currentNode = this.root;\n    while (true) {\n      if (currentNode.data === value) {\n        return true;\n      } else if (currentNode.data > value) {\n        currentNode = currentNode.left;\n      }\n      // The conditional below is new.\n      if (currentNode === null) {\n        return false;\n      }\n    }\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["If the ",(0,r.jsx)(t.code,{children:"currentNode === null"}),", that means we've reached the bottom of the tree without finding the value we're looking for. Since there are no more nodes to search, the value doesn't exist in the tree. By the way, note that this is an ",(0,r.jsx)(t.code,{children:"if"})," statement \u2014 not another ",(0,r.jsx)(t.code,{children:"else if"})," \u2014 we ",(0,r.jsx)(t.em,{children:"always"})," want our algorithm to check if the ",(0,r.jsx)(t.code,{children:"currentNode"})," has been updated to ",(0,r.jsx)(t.code,{children:"null"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"The next step is to make sure our method can search to the right. Here's a test:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"__tests__/bst.test.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"...\n  test('it should return true if the tree includes 7', () => {\n    expect(pbst.search(7)).toEqual(true);\n  });\n...\n"})}),"\n",(0,r.jsx)(t.p,{children:"Note that we skip down to the right child's right child \u2014 that shouldn't be a problem, though, since we are already looping."}),"\n",(0,r.jsx)(t.p,{children:"Here's our updated method:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"src/bst.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"...\n  search(value) {\n    if (this.root.data === value) {\n      return true;\n    } else {\n      let currentNode = this.root;\n      while (true) {\n        if (currentNode.data === value) {\n          return true;\n        } else if (currentNode.data > value) {\n          currentNode = currentNode.left;\n        } else if (currentNode.data < value) {\n          currentNode = currentNode.right;\n        }\n        if (currentNode === null) {\n          return false;\n        }\n      }\n    }\n  }\n...\n"})}),"\n",(0,r.jsx)(t.p,{children:"Now our test should be passing."}),"\n",(0,r.jsx)(t.p,{children:"We should also be able to verify that our method can go left and then right (or vice versa):"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"__tests__/bst.test.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"...\n  test('it should return true if the tree includes 5', () => {\n    expect(pbst.search(5)).toEqual(true);\n  });\n...\n"})}),"\n",(0,r.jsxs)(t.p,{children:["It can. Finally, we have one test that's commented out. Now that we can traverse both to the left and right, we can uncomment the test and it will be passing as well. And that's our method for ",(0,r.jsx)(t.code,{children:"BST.prototype.search()"})," \u2014 which is quite similar to our ",(0,r.jsx)(t.code,{children:"BST.prototype.insertNode()"})," method."]}),"\n",(0,r.jsx)(t.p,{children:"On average, inserting, searching and removing nodes from a binary search tree has a Big O of O(log n). That's pretty good \u2014 and better than linear time (O(n)). Of course, there is a worst-case scenario of O(n) if the tree is severely unbalanced \u2014 but this is unlikely, especially in well-designed binary search tree algorithms which include tree rebalancing."})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},67388:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/full_binary_tree-707c7cf49e866466e87a93c3f353be93.png"}}]);