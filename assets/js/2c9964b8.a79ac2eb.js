"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[54160],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var o=t(96540);const i={},r=o.createContext(i);function s(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:n},e.children)}},33785:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/c-sharp-compilation-and-execution-b965b0f8a1aa0af981f06cf65bf5610c.png"},68272:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"c-and-net/test-driven-development-with-c/3-1-1-2--a-closer-look-at-compiling-and-executing-c-programs","title":"\ud83d\udcd3 3.1.1.2- A Closer Look at Compiling and Executing C# Programs","description":"Over the pre-work we learned how to create console apps and test business logic using TDD and MSTest. Let\'s take a closer look at the process of compiling and running code in C#.","source":"@site/docs/3_c-and-net/1_test-driven-development-with-c/3-1-1-02--a-closer-look-at-compiling-and-executing-c-programs.md","sourceDirName":"3_c-and-net/1_test-driven-development-with-c","slug":"/c-and-net/test-driven-development-with-c/3-1-1-2--a-closer-look-at-compiling-and-executing-c-programs","permalink":"/v1.2/c-and-net/test-driven-development-with-c/3-1-1-2--a-closer-look-at-compiling-and-executing-c-programs","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 3.1.1.2- A Closer Look at Compiling and Executing C# Programs","day":"monday","id":"3-1-1-2--a-closer-look-at-compiling-and-executing-c-programs","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\u270f\ufe0f 3.1.1.1 Shape Tracker, Ping Pong, Sphinx, Queen Attack","permalink":"/v1.2/c-and-net/test-driven-development-with-c/3-1-1-1-shape-tracker-ping-pong-sphinx-queen-attack"},"next":{"title":"\ud83d\udcd3 3.1.1.3- Overloading Constructors and Methods","permalink":"/v1.2/c-and-net/test-driven-development-with-c/3-1-1-3--overloading-constructors-and-methods"}}');var i=t(74848),r=t(28453);const s={title:"\ud83d\udcd3 3.1.1.2- A Closer Look at Compiling and Executing C# Programs",day:"monday",id:"3-1-1-2--a-closer-look-at-compiling-and-executing-c-programs",hide_table_of_contents:!0},a=void 0,c={},l=[{value:"Compilation",id:"compilation",level:2},{value:"JIT",id:"jit",level:3},{value:"AOT",id:"aot",level:3},{value:"Steps in the .NET Compilation Process",id:"steps-in-the-net-compilation-process",level:2},{value:"Running C# Code with the Common Language Runtime (CLR)",id:"running-c-code-with-the-common-language-runtime-clr",level:2},{value:"A Diagram of Compiling and Executing C# Programs",id:"a-diagram-of-compiling-and-executing-c-programs",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Over the pre-work we learned how to create console apps and test business logic using TDD and MSTest. Let's take a closer look at the process of compiling and running code in C#."}),"\n",(0,i.jsx)(n.h2,{id:"compilation",children:"Compilation"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Compilation"})," is the process of assembling information from various sources into one location. In software development, this means transforming the code a developer writes into machine readable code which can be executed by a microprocessor."]}),"\n",(0,i.jsx)(n.p,{children:"All code is compiled. But this can happen in more than one way."}),"\n",(0,i.jsx)(n.h3,{id:"jit",children:"JIT"}),"\n",(0,i.jsx)(n.p,{children:"When we write a line of JavaScript code and pass it into the browser, it automatically runs. There is a direct relationship between the code we write and the behaviors we observe and interact with. In fact, the file the browser references is the same file we've written."}),"\n",(0,i.jsxs)(n.p,{children:["However, a ",(0,i.jsx)(n.strong,{children:"compile"})," action ",(0,i.jsx)(n.em,{children:"does"})," happen with JavaScript in the browser. The code is evaluated and the actions within the code are carried out, but this happens live, as the user loads or interacts with the code. This type of compilation is called ",(0,i.jsx)(n.strong,{children:"Just In Time"})," compiling (",(0,i.jsx)(n.strong,{children:"JIT"})," for short) because the code is compiled on-demand at the server or client level."]}),"\n",(0,i.jsx)(n.h3,{id:"aot",children:"AOT"}),"\n",(0,i.jsx)(n.p,{children:"With C#, our computers do not interpret the code we write. Instead, our code is a set of instructions to build a program."}),"\n",(0,i.jsx)(n.p,{children:"With this type of compilation, our code must go through several steps to be compiled into a different format that is optimized for our machines. The code is often compiled to binary files and is saved separately from the code we write. It would be very challenging for humans to read this code."}),"\n",(0,i.jsxs)(n.p,{children:["This compilation happens long before a user ever encounters our program and is called ",(0,i.jsx)(n.strong,{children:"Ahead Of Time"})," compiling or ",(0,i.jsx)(n.strong,{children:"AOT"})," for short."]}),"\n",(0,i.jsx)(n.h2,{id:"steps-in-the-net-compilation-process",children:"Steps in the .NET Compilation Process"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["Several steps occur when we run ",(0,i.jsxs)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-build",children:["the command ",(0,i.jsx)(n.code,{children:"dotnet build"})," to compile our C# code"]}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["First, the build platform ",(0,i.jsx)(n.strong,{children:"MSBuild"})," is invoked. MSBuild looks through our project file and decides what resources it will need to build our program, just as a cook might decide which ingredients are needed for a recipe."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'<Project Sdk="Microsoft.NET.Sdk">\n\n    <PropertyGroup>\n        <OutputType>Exe</OutputType>\n        <TargetFramework>net6.0</TargetFramework>\n    </PropertyGroup>\n\n</Project>\n'})}),"\n",(0,i.jsx)(n.p,{children:"In the project file, we specify configurations that we want MSBuild to use in its compilation process:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["We tell MSBuild we are using ",(0,i.jsx)(n.code,{children:'"Microsoft.NET.Sdk"'}),", a software development kit which contains the C# language and many libraries of information."]}),"\n",(0,i.jsxs)(n.li,{children:["We tell MSBuild that we would like an ",(0,i.jsx)(n.strong,{children:"executable"}),", or ",(0,i.jsx)(n.code,{children:"Exe"})," output, meaning a program that can be run."]}),"\n",(0,i.jsxs)(n.li,{children:["We also specify that we will be using the ",(0,i.jsx)(n.code,{children:"net6.0"})," framework, which contains a lot of built-in libraries (namespaces) that our C# code relies on (like ",(0,i.jsx)(n.code,{children:"System"}),")."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["After MSBuild successfully gathers all of the resources our project needs, it will create a new folder called ",(0,i.jsx)(n.code,{children:"obj"}),", and put all of the resources inside."]}),"\n",(0,i.jsxs)(n.p,{children:["The next thing MSBuild does is compile our project's source code \u2014 the C# code that we write. The goal is to compile multiple C# files into a single executable file. However, if MSBuild encounters an error during this process (like a missing resource), it will fail, stop compiling, and deliver us a ",(0,i.jsx)(n.strong,{children:"compiler error"})," in the terminal. It's our job to resolve compiler errors so that MSBuild can compile our code."]}),"\n",(0,i.jsxs)(n.p,{children:["If there are no compiler errors, MSBuild will end its work by putting all of the compiled code in a ",(0,i.jsx)(n.code,{children:"bin"})," folder, including an executable file that we can run (with the ",(0,i.jsx)(n.code,{children:"dotnet run"})," command). The executable file will end in ",(0,i.jsx)(n.code,{children:".exe"})," or ",(0,i.jsx)(n.code,{children:".dll"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Take note that the executable file no longer contains C# \u2014 it actually contains code written in the ",(0,i.jsx)(n.strong,{children:"Common Intermediate Language (CIL)"}),". What's that? The CLI is a programming language that various higher-level languages (C#, Visual Basic, F#) are turned into during the compilation process. It's an ",(0,i.jsx)(n.strong,{children:"intermediary"})," language, because it will eventually be compiled again into machine code when we run our program. We'll go over that next! To read more about the common intermediate language, visit the ",(0,i.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/standard/managed-code#intermediate-language--execution",children:"MS docs"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"running-c-code-with-the-common-language-runtime-clr",children:"Running C# Code with the Common Language Runtime (CLR)"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["After our C# program is compiled, we run it with the command ",(0,i.jsx)(n.code,{children:"dotnet run"}),". This command invokes the .NET ",(0,i.jsx)(n.strong,{children:"runtime"})," called the ",(0,i.jsx)(n.strong,{children:"Common Language Runtime (CLR)"})," which does a few things:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Compiles the CIL code into machine code, which is code that only our computers can understand and process."}),"\n",(0,i.jsx)(n.li,{children:"Directs our computer to run the code!"}),"\n",(0,i.jsx)(n.li,{children:"Provides services that improve our code's performance."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The CLR exists in order to help developers write quality code that is cross-platform, meaning code that can be run on (most) operating systems (like Mac and Linux). We don't need to understand the extended details of the CLR, but if you want to learn more, start with ",(0,i.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/standard/clr",children:"this article from Microsoft"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"So in the end, our C# code gets compiled twice \u2014 once to the CLI, and a second time to machine code."}),"\n",(0,i.jsx)(n.h2,{id:"a-diagram-of-compiling-and-executing-c-programs",children:"A Diagram of Compiling and Executing C# Programs"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"Here's a diagram of how C# programs are compiled and executed to help you visualize the process:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"A diagram of the process of writing, compiling, and running C# code.",src:t(33785).A+"",width:"525",height:"855"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);