"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[1e4],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>s});var r=t(96540);const o={},c=r.createContext(o);function i(e){const n=r.useContext(c);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(c.Provider,{value:n},e.children)}},78798:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"react/functional-programming-with-javascript/3-1-1-8-storing-state-in-closures","title":"\ud83d\udcd3 3.1.1.8 Storing State in Closures","description":"Now that we\'ve had some practices working with closures, it\'s time to explore another cool thing we can do with closures. We can use them to store basic info about state.","source":"@site/versioned_docs/version-WIP/3_react/1_functional-programming-with-javascript/3-1-1-08-storing-state-in-closures.md","sourceDirName":"3_react/1_functional-programming-with-javascript","slug":"/react/functional-programming-with-javascript/3-1-1-8-storing-state-in-closures","permalink":"/WIP/react/functional-programming-with-javascript/3-1-1-8-storing-state-in-closures","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 3.1.1.8 Storing State in Closures","day":"monday","id":"3-1-1-8-storing-state-in-closures","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 3.1.1.7 State","permalink":"/WIP/react/functional-programming-with-javascript/3-1-1-7-state"},"next":{"title":"\ud83d\udcd3 3.1.1.9 Building a Functional Application (Part 1)","permalink":"/WIP/react/functional-programming-with-javascript/3-1-1-9-building-a-functional-application-part-1"}}');var o=t(74848),c=t(28453);const i={title:"\ud83d\udcd3 3.1.1.8 Storing State in Closures",day:"monday",id:"3-1-1-8-storing-state-in-closures",hide_table_of_contents:!0},s=void 0,a={},l=[];function u(e){const n={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,c.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"Now that we've had some practices working with closures, it's time to explore another cool thing we can do with closures. We can use them to store basic info about state."}),"\n",(0,o.jsx)(n.p,{children:"Let's take a look at how we can use a closure to store basic state. We'll create a function that increments a counter by 1 to demonstrate how this works:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const counterFunction = () => {\n  let counter = 0;\n  return () => {\n    counter ++;\n    return counter;\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In the example above, the outer function ",(0,o.jsx)(n.code,{children:"counterFunction()"})," stores a variable ",(0,o.jsx)(n.code,{children:"counter"})," which is set to ",(0,o.jsx)(n.code,{children:"0"}),". Note that we use ",(0,o.jsx)(n.code,{children:"let"})," here because we will be modifying the value of the counter."]}),"\n",(0,o.jsxs)(n.p,{children:["Our ",(0,o.jsx)(n.code,{children:"counterFunction()"})," function returns an anonymous function that increments the value of ",(0,o.jsx)(n.code,{children:"counter"})," and then returns its value. (We won't worry about the fact that we aren't mutating this in a functional way since this is merely for demonstration purposes.) The inner function has access to the ",(0,o.jsx)(n.code,{children:"counter"})," variable due to ",(0,o.jsx)(n.strong,{children:"lexical scope"}),". Lexical scope means that an inner function has access to the variables of any outer functions that surround it."]}),"\n",(0,o.jsx)(n.p,{children:"Now we can do the following:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const incrementer = counterFunction();\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If we check the value of ",(0,o.jsx)(n.code,{children:"incrementer"})," in the console, we'll see that it stores our inner function:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"() => {\n  counter ++;\n  return counter;\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We can't see the value of ",(0,o.jsx)(n.code,{children:"counter"})," but we know that ",(0,o.jsx)(n.code,{children:"incrementer"})," has access to it due to lexical scope. So what happens if we call this function multiple times?"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"> incrementer()\n1\n> incrementer()\n2\n> incrementer()\n3\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Each time we call ",(0,o.jsx)(n.code,{children:"incrementer()"}),", it modifies the value of ",(0,o.jsx)(n.code,{children:"counter"}),". Since ",(0,o.jsx)(n.code,{children:"incrementer()"})," is inside the outer function's lexical scope, it remembers the value of ",(0,o.jsx)(n.code,{children:"counter"}),". However, the outer function isn't being called again so ",(0,o.jsx)(n.code,{children:"counter"})," never falls out of scope (nor is it reassigned) regardless of how many times we call in the inner function."]}),"\n",(0,o.jsx)(n.p,{children:"What would happen if we created another incrementer and then called our first incrementer again?"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"> const incrementerTwo = counterFunction();\n> incrementerTwo()\n1\n> incrementerTwo()\n2\n> incrementer()\n4\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"incrementerTwo"})," creates a ",(0,o.jsx)(n.em,{children:"new"})," lexical scope that doesn't affect the value of ",(0,o.jsx)(n.code,{children:"counter"})," in ",(0,o.jsx)(n.code,{children:"incrementer"}),". In other words, we could store an indefinite number of counters in functions using our closure."]}),"\n",(0,o.jsx)(n.p,{children:"In the next lesson, we'll build a small application that will use a closure to store state."})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}}}]);