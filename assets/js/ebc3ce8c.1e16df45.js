"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[52179],{25762:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>c,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"c-and-net/lessons-19-31-basic-console-apps/3-0-0-21-the-shape-tracker-project-structure","title":"\ud83d\udcd3 3.0.0.21 The Shape Tracker Project Structure","description":"Now that we know the basics of compiling and executing C# programs, we\'re ready to start building the C# Shape Tracker console app. In this lesson, we\'ll start creating our project\'s structure and discuss how we\'ll organize our code into namespaces and classes.","source":"@site/docs/3_c-and-net/0_lessons-19-31-basic-console-apps/3-0-0-21-the-shape-tracker-project-structure.md","sourceDirName":"3_c-and-net/0_lessons-19-31-basic-console-apps","slug":"/c-and-net/lessons-19-31-basic-console-apps/3-0-0-21-the-shape-tracker-project-structure","permalink":"/v1.2/c-and-net/lessons-19-31-basic-console-apps/3-0-0-21-the-shape-tracker-project-structure","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 3.0.0.21 The Shape Tracker Project Structure","day":"weekend","id":"3-0-0-21-the-shape-tracker-project-structure","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.0.0.20 Hello World! Compiling and Executing C# Programs","permalink":"/v1.2/c-and-net/lessons-19-31-basic-console-apps/3-0-0-20-hello-world-compiling-and-executing-c-programs"},"next":{"title":"\ud83d\udcd3 3.0.0.22 Classes and Namespaces","permalink":"/v1.2/c-and-net/lessons-19-31-basic-console-apps/3-0-0-22-classes-and-namespaces"}}');var t=n(74848),i=n(28453);const c={title:"\ud83d\udcd3 3.0.0.21 The Shape Tracker Project Structure",day:"weekend",id:"3-0-0-21-the-shape-tracker-project-structure",hide_table_of_contents:!0},s=void 0,l={},a=[{value:"Shape Tracker Project Structure",id:"shape-tracker-project-structure",level:2},{value:"The &quot;Parent&quot; or &quot;Root&quot; Directory",id:"the-parent-or-root-directory",level:3},{value:"<code>.gitignore</code> and Initializing Git",id:"gitignore-and-initializing-git",level:3},{value:"The &quot;Project&quot; or &quot;Production&quot; Directory",id:"the-project-or-production-directory",level:3},{value:"The Project File",id:"the-project-file",level:3},{value:"Multiple Code Files",id:"multiple-code-files",level:3},{value:"User Interface Logic in <code>Program.cs</code>",id:"user-interface-logic-in-programcs",level:4},{value:"Business Logic Files in the <code>Models</code> Directory",id:"business-logic-files-in-the-models-directory",level:4},{value:"<code>README.md</code> Documentation",id:"readmemd-documentation",level:3}];function d(e){const r={code:"code",div:"div",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.p,{children:"Now that we know the basics of compiling and executing C# programs, we're ready to start building the C# Shape Tracker console app. In this lesson, we'll start creating our project's structure and discuss how we'll organize our code into namespaces and classes."}),"\n",(0,t.jsx)(r.p,{children:"You are welcome to code along with this pre-work, or just read through it. GitHub repository references for the Shape Tracker console app will be provided periodically throughout this walkthrough."}),"\n",(0,t.jsx)(r.h2,{id:"shape-tracker-project-structure",children:"Shape Tracker Project Structure"}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsxs)(r.p,{children:["We're going to walk through the setup process step by step and explain all of the decisions we're making along the way. As we'll see, much of the setup we did for the \"Hello World\" application will be the same in our new Shape Tracker console app, with some notable differences. ",(0,t.jsx)(r.strong,{children:"You can follow the setup process outlined in this lesson for all of the projects you create in this course section."})," There will also be a project structure configuration reference at the very end of this pre-work section."]}),"\n",(0,t.jsx)(r.p,{children:"By the end of the lesson, we'll have the following file/folder structure:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"ShapeTracker.Solution/\n  \u251c\u2500\u2500 ShapeTracker/\n  \u2502     \u251c\u2500\u2500 Models/\n  \u2502     \u2502     \u2514\u2500\u2500 Triangle.cs\n  \u2502     \u251c\u2500\u2500 ShapeTracker.csproj\n  \u2502     \u2514\u2500\u2500 Program.cs\n  \u251c\u2500\u2500 .gitignore\n  \u2514\u2500\u2500 README.md\n"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:'Notice that we use Pascal case, or "UpperCamelCase", for all .NET files and folders'}),"  (excluding ",(0,t.jsx)(r.code,{children:"README.md"})," and ",(0,t.jsx)(r.code,{children:".gitignore"}),")."]}),"\n",(0,t.jsx)(r.h3,{id:"the-parent-or-root-directory",children:'The "Parent" or "Root" Directory'}),"\n",(0,t.jsxs)(r.p,{children:["We'll start by creating the ",(0,t.jsx)(r.strong,{children:"parent directory"})," called ",(0,t.jsx)(r.code,{children:"ShapeTraker.Solution"}),". We can also call this the ",(0,t.jsx)(r.strong,{children:"root directory"}),", because it is the directory that will contain all of our project's subfiles and subfolders. This will include source code for the console app, as well as another folder that we'll add later that will contain all of the unit tests we write for our source code."]}),"\n",(0,t.jsxs)(r.p,{children:["In the example projects at Epicodus, you'll see that we regularly include the word 'solution' in the name of our parent directory. When we Include 'solution' this indicates that this directory is a complete solution to the given project prompt. In this case ",(0,t.jsx)(r.code,{children:"ShapeTracker.Solution"})," contains all of the code relevant to the Shape Tracker project. Note that ",(0,t.jsx)(r.strong,{children:'it is not required to follow the naming convention of including "solution" in the parent directory\'s name.'})]}),"\n",(0,t.jsxs)(r.h3,{id:"gitignore-and-initializing-git",children:[(0,t.jsx)(r.code,{children:".gitignore"})," and Initializing Git"]}),"\n",(0,t.jsxs)(r.p,{children:["Within the parent directory ",(0,t.jsx)(r.code,{children:"ShapeTracker.Solution"}),", add a ",(0,t.jsx)(r.code,{children:".gitignore"})," file. Within our ",(0,t.jsx)(r.code,{children:".gitignore"})," we'll add our ",(0,t.jsx)(r.code,{children:"obj"})," and ",(0,t.jsx)(r.code,{children:"bin"})," folders because both of these are auto-generated in the process of compiling our console app:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["The ",(0,t.jsx)(r.code,{children:"obj"})," directory contains the resources our code needs."]}),"\n",(0,t.jsxs)(r.li,{children:["The ",(0,t.jsx)(r.code,{children:"bin"})," directory contains our compiled output code."]}),"\n"]}),"\n",(0,t.jsx)(r.div,{className:"filename",children:".gitignore"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"obj\nbin\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Next, we'll want to initialize Git in our parent directory with the command ",(0,t.jsx)(r.code,{children:"git init"}),". The very first thing we'll want to do is track our ",(0,t.jsx)(r.code,{children:".gitignore"})," file so that Git knows to ignore the ",(0,t.jsx)(r.code,{children:"obj"})," and ",(0,t.jsx)(r.code,{children:"bin"})," directories."]}),"\n",(0,t.jsx)(r.p,{children:"Our file/folder structure should now look like this:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"ShapeTracker.Solution/\n  \u2514\u2500\u2500 .gitignore\n"})}),"\n",(0,t.jsx)(r.h3,{id:"the-project-or-production-directory",children:'The "Project" or "Production" Directory'}),"\n",(0,t.jsxs)(r.p,{children:["Next, we'll create a subdirectory within ",(0,t.jsx)(r.code,{children:"ShapeTracker.Solution"})," called ",(0,t.jsx)(r.code,{children:"ShapeTracker"}),". The ",(0,t.jsx)(r.code,{children:"ShapeTracker"})," folder will contain the source code for our project, and because of that, this directory is commonly called the ",(0,t.jsx)(r.strong,{children:"project directory"})," or ",(0,t.jsx)(r.strong,{children:"production directory"}),"."]}),"\n",(0,t.jsx)(r.p,{children:"Our file/folder structure should now look like this:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"ShapeTracker.Solution/\n  \u251c\u2500\u2500 ShapeTracker/\n  \u2514\u2500\u2500 .gitignore\n"})}),"\n",(0,t.jsx)(r.h3,{id:"the-project-file",children:"The Project File"}),"\n",(0,t.jsxs)(r.p,{children:["Within the project directory ",(0,t.jsx)(r.code,{children:"ShapeTracker"}),", create the project file called ",(0,t.jsx)(r.code,{children:"ShapeTracker.csproj"}),'. Note that we also call our project file a "csproj" file.']}),"\n",(0,t.jsx)(r.p,{children:"In every project we create in this course section, the project file for our production source code will contain the same boilerplate code:"}),"\n",(0,t.jsx)(r.div,{className:"filename",children:"ShapeTracker.csproj"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n      <OutputType>Exe</OutputType>\n      <TargetFramework>net6.0</TargetFramework>\n  </PropertyGroup>\n\n</Project>\n'})}),"\n",(0,t.jsx)(r.p,{children:"Keep in mind a few things:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["It is customary for the name of the project file to match the name of the project directory. In our case we have ",(0,t.jsx)(r.code,{children:"ShapeTracker.csproj"})," within the ",(0,t.jsx)(r.code,{children:"ShapeTraker"})," directory."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"<OutputType>Exe</OutputType>"})," directs the C# compiler to create an executable file that we can run using the command ",(0,t.jsx)(r.code,{children:"dotnet run"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"<TargetFramework>net6.0</TargetFramework>"})," specifies the version of the .NET framework we are using."]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"OOur file/folder structure should now look like this:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"ShapeTracker.Solution/\n  \u251c\u2500\u2500 ShapeTracker/\n  \u2502     \u2514\u2500\u2500 ShapeTracker.csproj\n  \u2514\u2500\u2500 .gitignore\n"})}),"\n",(0,t.jsx)(r.h3,{id:"multiple-code-files",children:"Multiple Code Files"}),"\n",(0,t.jsxs)(r.p,{children:["In the last lesson we learned that we need at least one C# code file with a single ",(0,t.jsx)(r.code,{children:"Main()"})," method (the entry point of our application) that contains C# code for our program to run. Well in this lesson, we're going to add multiple code files that will separate our business logic and user interface logic."]}),"\n",(0,t.jsxs)(r.h4,{id:"user-interface-logic-in-programcs",children:["User Interface Logic in ",(0,t.jsx)(r.code,{children:"Program.cs"})]}),"\n",(0,t.jsxs)(r.p,{children:["Within the ",(0,t.jsx)(r.code,{children:"ShapeTracker"})," production directory create a file named ",(0,t.jsx)(r.code,{children:"Program.cs"}),", which will contain our user interface logic as well as the entry point to our console app, the ",(0,t.jsx)(r.code,{children:"Main()"})," method."]}),"\n",(0,t.jsx)(r.div,{className:"filename",children:"Program.cs"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"class Program\n{\n  static void Main()\n  {\n    // We'll add user interface code here.\n  }\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"Let's review conventions and requirements:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["We're required to have a single ",(0,t.jsx)(r.code,{children:"static void Main()"})," method (within a class) to be the entry point to our application. Any code we add within the ",(0,t.jsx)(r.code,{children:"Main()"})," method will be run when we run our console app."]}),"\n",(0,t.jsxs)(r.li,{children:["It's convention to name the file and class that contains our app's entry point ",(0,t.jsx)(r.code,{children:"Program"}),". You do not have to do this, however. In all example projects in LearnHowToProgram.com, we will use the name ",(0,t.jsx)(r.code,{children:"Program"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(r.h4,{id:"business-logic-files-in-the-models-directory",children:["Business Logic Files in the ",(0,t.jsx)(r.code,{children:"Models"})," Directory"]}),"\n",(0,t.jsxs)(r.p,{children:["Within ",(0,t.jsx)(r.code,{children:"ShapeTracker"})," create a subdirectory called ",(0,t.jsx)(r.code,{children:"Models"}),", which will contain all of our business logic files. Next, add one code file called ",(0,t.jsx)(r.code,{children:"Triangle.cs"})," within the ",(0,t.jsx)(r.code,{children:"Models"})," subdirectory. We'll add some basic code now to create a ",(0,t.jsx)(r.code,{children:"Triangle"})," class, which we'll explore more soon!"]}),"\n",(0,t.jsx)(r.div,{className:"filename",children:"Models/Triangle.cs"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"public class Triangle\n{\n  // Code for Triangle business logic will go here.\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"Let's review conventions:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"It's convention to separate business logic into multiple files."}),"\n",(0,t.jsxs)(r.li,{children:["It's convention to store business logic files in a directory called ",(0,t.jsx)(r.code,{children:"Models"}),"."]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"At this point, our file/folder structure should now look like this:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"ShapeTracker.Solution/\n  \u251c\u2500\u2500 ShapeTracker/\n  \u2502     \u251c\u2500\u2500 Models/\n  \u2502     \u2502     \u2514\u2500\u2500 Triangle.cs\n  \u2502     \u251c\u2500\u2500 ShapeTracker.csproj\n  \u2502     \u2514\u2500\u2500 Program.cs\n  \u2514\u2500\u2500 .gitignore\n"})}),"\n",(0,t.jsxs)(r.h3,{id:"readmemd-documentation",children:[(0,t.jsx)(r.code,{children:"README.md"})," Documentation"]}),"\n",(0,t.jsxs)(r.p,{children:["Within the parent directory ",(0,t.jsx)(r.code,{children:"ShapeTracker.Solution/"}),", we'll add a ",(0,t.jsx)(r.code,{children:"README.md"})," as usual. We won't go over everything that should go in your README, since that is the same as always. We will take a quick look at what our setup instructions might look like for a C# console app:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-markdown",children:'### Setup Instructions\n\n1. Clone this repo.\n2. Open your terminal (e.g., Terminal or GitBash) and navigate to this project\'s production directory called "ShapeTracker".\n3. In the command line, run the command "dotnet run" to compile and execute the console application. Since this is a console application, you\'ll interact with it through text commands in your terminal.\n4. Optionally, you can run "dotnet build" to compile this console app without running it.\n'})}),"\n",(0,t.jsx)(r.p,{children:"While you are welcome to use the above text for your setup instructions, you certainly don't have to!"}),"\n",(0,t.jsx)(r.p,{children:"At this point we should have our basic folder and file structure set up for our Shape Tracker app:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"ShapeTracker.Solution/\n  \u251c\u2500\u2500 ShapeTracker/\n  \u2502     \u251c\u2500\u2500 Models/\n  \u2502     \u2502     \u2514\u2500\u2500 Triangle.cs\n  \u2502     \u251c\u2500\u2500 ShapeTracker.csproj\n  \u2502     \u2514\u2500\u2500 Program.cs\n  \u251c\u2500\u2500 .gitignore\n  \u2514\u2500\u2500 README.md\n"})}),"\n",(0,t.jsx)(r.p,{children:"In the next lesson, we'll learn more about classes, namespaces, and access level modifiers."})]})}function h(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>c,x:()=>s});var o=n(96540);const t={},i=o.createContext(t);function c(e){const r=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),o.createElement(i.Provider,{value:r},e.children)}}}]);