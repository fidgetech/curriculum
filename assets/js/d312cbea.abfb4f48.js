"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[97032],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var s=n(96540);const i={},o=s.createContext(i);function r(e){const t=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:t},e.children)}},98345:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"c-and-net/lessons-32-44-tdd-and-debugging/5-0-0-32-what-well-learn-in-this-section","title":"\ud83d\udcd3 5.0.0.32 What We\'ll Learn in this Section","description":"In this C# and .NET pre-work section, we\'ll learn about testing and debugging tools, and in this lesson, we\'ll get a sense of what exactly we\'ll be doing in this section.","source":"@site/versioned_docs/version-WIP/c-and-net/0_lessons-32-44-tdd-and-debugging/3-0-0-32-what-well-learn-in-this-section.md","sourceDirName":"c-and-net/0_lessons-32-44-tdd-and-debugging","slug":"/c-and-net/lessons-32-44-tdd-and-debugging/5-0-0-32-what-well-learn-in-this-section","permalink":"/WIP/c-and-net/lessons-32-44-tdd-and-debugging/5-0-0-32-what-well-learn-in-this-section","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 5.0.0.32 What We\'ll Learn in this Section","day":"weekend","id":"5-0-0-32-what-well-learn-in-this-section","hide_table_of_contents":true,"pagination_prev":null},"sidebar":"c-and-net","next":{"title":"\ud83d\udcd3 5.0.0.33 Review: the Red, Green, Refactor Workflow and Testing Best Practices","permalink":"/WIP/c-and-net/lessons-32-44-tdd-and-debugging/5-0-0-33-review-the-red-green-refactor-workflow-and-testing-best-practices"}}');var i=n(74848),o=n(28453);const r={title:"\ud83d\udcd3 5.0.0.32 What We'll Learn in this Section",day:"weekend",id:"5-0-0-32-what-well-learn-in-this-section",hide_table_of_contents:!0,pagination_prev:null},a=void 0,l={},c=[{value:"Automated Unit Testing",id:"automated-unit-testing",level:2},{value:"The Benefits of TDD",id:"the-benefits-of-tdd",level:3},{value:"Plan for Learning",id:"plan-for-learning",level:3},{value:"Debugging",id:"debugging",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"In this C# and .NET pre-work section, we'll learn about testing and debugging tools, and in this lesson, we'll get a sense of what exactly we'll be doing in this section."}),"\n",(0,i.jsx)(t.h2,{id:"automated-unit-testing",children:"Automated Unit Testing"}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsxs)(t.p,{children:["In this section, we'll review the Test-Driven Development (TDD) principles and practices that we learned in Intermediate JavaScript. Then, we'll write automated unit tests for our C# and .NET Shape Tracker app. Notably, most of this curriculum will be a ",(0,i.jsx)(t.em,{children:"review"})," and not brand new information \u2014 that's because the core concepts of TDD, the Red-Green-Refactor (RGR) workflow, and general testing best practices are the same across languages and testing frameworks."]}),"\n",(0,i.jsx)(t.p,{children:"Let's review terminology:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Test-Driven Development (TDD):"})," In TDD, the process of writing code is intertwined with writing tests for that code. When we use TDD, we break our code down into the smallest pieces of functionality we can. Next, we write a test for a piece of functionality before we add that functionality to our code. Finally, we add the code to make that test pass."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Red-Green-Refactor (RGR) Workflow:"})," The RGR workflow helps us follow best practices for testing. When we use the RGR workflow, we complete three phases for each test we write:\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"(Red phase.) After writing a test, we first confirm the test we've written is failing first to ensure there are no false positives (a test that is passing when it should not be). The test should be failing because there should be no code in place to make the test pass."}),"\n",(0,i.jsx)(t.li,{children:"(Green phase.) After confirming that the test is failing, we write just enough code to make the test pass and run our automated testing software to ensure that the test is passing."}),"\n",(0,i.jsx)(t.li,{children:"(Refactor phase.) After completing the red and green phases, we can optionally refactor our code. After refactoring our code, we need to run our automated tests to make sure that all are still passing."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Automated versus Manual Testing:"})," When we write ",(0,i.jsx)(t.strong,{children:"automated"})," tests, we are writing coded tests that are run by software (like Jest or MSTest). When we perform ",(0,i.jsx)(t.strong,{children:"manual testing"}),", we are clicking around our application (or something similar) to confirm that our code is running as expected."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Unit Tests:"})," A unit test focuses on testing a single component of our source code, like a class field or method."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Integration Tests:"}),' An integration test focuses on testing how multiple source code components work as a group, typically a combination of business logic and user interface logic. For example, an integration test might check that a user can properly fill out a form, submit it, and be re-routed to a "success page".']}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"MSTest:"})," The testing framework we'll use to write unit tests for our C#/.NET code. Within each unit test, we can list an expected result and then our test will let us know whether that expected result is achieved or not. Just like with Jest and JavaScript, MSTest is just ",(0,i.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/dotnet/core/testing/",children:"one of many .NET testing frameworks we can use."})," Visit ",(0,i.jsx)(t.a,{href:"https://github.com/microsoft/testfx",children:"the MSTest GitHub repo"})," to access additional documentation."]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"the-benefits-of-tdd",children:"The Benefits of TDD"}),"\n",(0,i.jsxs)(t.p,{children:["It's important to review why we bother writing tests at all. Frankly, even if you don't write tests, your code will still be tested. Can you guess who will do this? The customer, of course! That's ",(0,i.jsx)(t.strong,{children:"not"})," something we want, and precisely why we write tests: to ensure that the code we write functions as expected."]}),"\n",(0,i.jsx)(t.p,{children:"But writing tests is just one very obvious aspect of Test-Driven Development. Let's take a moment to review all of the advantages of TDD:"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"TDD helps us create a plan."})," By taking time to think through a program, identify behaviors, and tackle the simplest first, we're creating a game plan. We are laying out each step we need to take in detail, which leads to the next benefit."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"It's easier to tackle complex problems."})," Even the most experienced coders can struggle with approaching complex issues. By identifying and testing the smallest possible behavior at a time, we can take baby steps towards solving bigger problems."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"It prevents errors and makes bugs easier to locate."})," When we implement and test a single behavior at a time, we're preventing errors. Testing each behavior before moving on allows us to spot bugs as soon as they're introduced. Without TDD, we might not spot some of these bugs until they break our application. To make matters worse, if we add more code after introducing a bug, other parts of our application will likely be reliant on our buggy code. To resolve this issue, we'd need to locate the bug, resolve it, and potentially alter all the code that depends on the buggy code. That's a lot of work."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"It allows us to create projects faster."})," Starting a complex project can be daunting. Even if we aren't sure how to code the more difficult features of our application, we can hit the ground running by implementing smaller, identifiable functionality. As we work, the bigger picture will come into focus."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"New features are built upon reliable code."})," By testing functionality as it's implemented and ensuring previous tests still pass when new functionality is introduced, new features are always built on a foundation of reliable, tested code."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"It keeps code DRY."})," By implementing the least amount of code to pass each test, we keep our code DRY. By approaching each piece of our project's functionality individually, we are likely to write more modular code. Modular code is easier to maintain, update, and debug."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"It's employable."})," Testing is an important part of the tech industry and many tech careers rely on it \u2014 ranging from developers and QA testers to devops specialists and site reliability engineers."]}),"\n",(0,i.jsx)(t.h3,{id:"plan-for-learning",children:"Plan for Learning"}),"\n",(0,i.jsxs)(t.p,{children:["To learn how to use MSTest, we'll revisit our Shape Tracker app and write automated unit tests for all of the ",(0,i.jsx)(t.code,{children:"Triangle"})," class business logic. We'll start by removing the class entirely so that we can practice true TDD where we write the test before writing the corresponding source code. In the end, we'll learn how to test the following:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"A class constructor."}),"\n",(0,i.jsx)(t.li,{children:"A private field via getter and setter methods."}),"\n",(0,i.jsx)(t.li,{children:"A private field via a public property."}),"\n",(0,i.jsx)(t.li,{children:"An auto-implemented public property (which implicitly creates a private field)."}),"\n",(0,i.jsx)(t.li,{children:"Static class members."}),"\n",(0,i.jsx)(t.li,{children:"Collections (like lists and dictionaries)."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"We'll also learn how to use the following MSTest tools:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:'How to use "arrange, act, assert" to organize tests.'}),"\n",(0,i.jsx)(t.li,{children:"The test methods for collections (like lists) versus non-collections."}),"\n",(0,i.jsx)(t.li,{children:"How to implement a teardown method that is run between each test."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"debugging",children:"Debugging"}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.p,{children:"We'll end this pre-work section by reviewing debugging and development tools that we can use in C# .NET console apps. When we begin to learn how to create web applications, we'll revisit debugging and learn about other tools at our disposal."})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);