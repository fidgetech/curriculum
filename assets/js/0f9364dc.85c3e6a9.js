"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[47512],{28453:(e,s,t)=>{t.d(s,{R:()=>o,x:()=>l});var n=t(96540);const a={},i=n.createContext(a);function o(e){const s=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(i.Provider,{value:s},e.children)}},52533:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>r});const n=JSON.parse('{"id":"c-and-net/lessons-19-31-basic-console-apps/3-0-0-26-apie-encapsulation","title":"\ud83d\udcd3 3.0.0.26 APIE: Encapsulation","description":"You might still be wondering why we need to use private fields. Why use getters and setters at all, especially since we had access to get and set fields when they were public?","source":"@site/versioned_docs/version-v1_3/3_c-and-net/0_lessons-19-31-basic-console-apps/3-0-0-26-apie-encapsulation.md","sourceDirName":"3_c-and-net/0_lessons-19-31-basic-console-apps","slug":"/c-and-net/lessons-19-31-basic-console-apps/3-0-0-26-apie-encapsulation","permalink":"/v1.3/c-and-net/lessons-19-31-basic-console-apps/3-0-0-26-apie-encapsulation","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 3.0.0.26 APIE: Encapsulation","day":"weekend","id":"3-0-0-26-apie-encapsulation","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.0.0.25 Access Modifiers, Best Practices with Fields, and Getter and Setter Methods","permalink":"/v1.3/c-and-net/lessons-19-31-basic-console-apps/3-0-0-25-access-modifiers-best-practices-with-fields-and-getter-and-setter-methods"},"next":{"title":"\ud83d\udcd3 3.0.0.27 Static Class Members","permalink":"/v1.3/c-and-net/lessons-19-31-basic-console-apps/3-0-0-27-static-class-members"}}');var a=t(74848),i=t(28453);const o={title:"\ud83d\udcd3 3.0.0.26 APIE: Encapsulation",day:"weekend",id:"3-0-0-26-apie-encapsulation",hide_table_of_contents:!0},l=void 0,c={},r=[{value:"An Example of Encapsulation",id:"an-example-of-encapsulation",level:2},{value:"Benefits of Encapsulation",id:"benefits-of-encapsulation",level:2},{value:"When Should I Use Encapsulation? Almost always...",id:"when-should-i-use-encapsulation-almost-always",level:2},{value:"APIE: Abstraction, Polymorphism, Inheritance, Encapsulation",id:"apie-abstraction-polymorphism-inheritance-encapsulation",level:2}];function d(e){const s={a:"a",code:"code",em:"em",h2:"h2",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.p,{children:"You might still be wondering why we need to use private fields. Why use getters and setters at all, especially since we had access to get and set fields when they were public?"}),"\n",(0,a.jsxs)(s.p,{children:["The short answer is that making fields private to a class uses ",(0,a.jsx)(s.strong,{children:"encapsulation"}),", one of the four basic principles of Object-Oriented Programming (OOP)."]}),"\n",(0,a.jsxs)(s.p,{children:["What is encapsulation? We use ",(0,a.jsx)(s.strong,{children:"encapsulation"})," when we hide the internal state and functionality of an object and only allow access through a public set of methods. Well, that's exactly what we're doing with ",(0,a.jsx)(s.code,{children:"private"})," fields \u2014 we are encapsulating them within the class and managing all data manipulation inside of the class. Like a pill capsule closes over medicine, a class closes over its members, functionality, and the data contained within it."]}),"\n",(0,a.jsx)(s.p,{children:"In this lesson, we'll better understand encapsulation and get introduced to the other three principles of object-oriented programming. We'll also take a moment to acknowledge that a best practice isn't a silver bullet \u2014 that is, exactly how you write your code depends on the application you are building."}),"\n",(0,a.jsx)(s.h2,{id:"an-example-of-encapsulation",children:"An Example of Encapsulation"}),"\n",(0,a.jsx)(s.hr,{}),"\n",(0,a.jsxs)(s.p,{children:["Imagine a ",(0,a.jsx)(s.code,{children:"User"})," class with a private ",(0,a.jsx)(s.code,{children:"_password"})," field. As developers, we wouldn't want to expose that field, making it public. Instead, we would want to provide a public ",(0,a.jsx)(s.code,{children:"CheckPassword()"})," method that returns a ",(0,a.jsx)(s.code,{children:"bool"})," that tells us if an entered password is correct."]}),"\n",(0,a.jsxs)(s.p,{children:["Outside the class, I can only determine if a provided password is correct by using the ",(0,a.jsx)(s.code,{children:"CheckPassword()"})," method. This means the sensitive information stored in the ",(0,a.jsx)(s.code,{children:"_password"})," field is never exposed."]}),"\n",(0,a.jsxs)(s.p,{children:["This is what getters and setters allow us to do: control ",(0,a.jsx)(s.em,{children:"how"})," information is managed. A setter could perform a validation action before modifying a value, for example."]}),"\n",(0,a.jsx)(s.p,{children:"We can also debug more easily when we have methods that perform data manipulation. If there's an error, the bug will be traced to that method."}),"\n",(0,a.jsxs)(s.p,{children:["This is why the best practice of setting fields to ",(0,a.jsx)(s.code,{children:"private"})," is a best practice. It encapsulates private data and functionality within a class and only exposes what's needed outside of the class."]}),"\n",(0,a.jsx)(s.h2,{id:"benefits-of-encapsulation",children:"Benefits of Encapsulation"}),"\n",(0,a.jsx)(s.hr,{}),"\n",(0,a.jsx)(s.p,{children:"Encapsulating class members is considered the best, most professional practice for several reasons:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:"It allows a class to have total control over its own fields, which is more secure."}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:"It prevents other classes from accessing and altering fields, which can lead to difficult bugs."}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:"Managing all aspects of a class within the class itself leads to more organized code. Organized code allows other developers to comprehend, collaborate, and implement your logic much more easily."}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:"While we may not see this benefit until our applications become larger, encapsulation leads to more maintainable code."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["Imagine we eventually need to change the variable name of an object's public field. If outside classes were directly accessing a field (eg: ",(0,a.jsx)(s.code,{children:"testTriangle.Side1;"}),", instead of ",(0,a.jsx)(s.code,{children:"testTriangle.GetSide1();"}),"), we would need to update all the code in outside classes that reference this field. This might not seem like a big deal, but imagine a C# application with tens or ",(0,a.jsx)(s.em,{children:"hundreds"})," of classes. We would have to comb through each one and change all references to this field. However, if the field were ",(0,a.jsx)(s.code,{children:"private"})," and outside classes accessed it through its getter method, only the object's getter method and class would need to be altered. We could update this class ",(0,a.jsx)(s.em,{children:"independently"})," without affecting other classes that rely on it."]}),"\n",(0,a.jsx)(s.h2,{id:"when-should-i-use-encapsulation-almost-always",children:"When Should I Use Encapsulation? Almost always..."}),"\n",(0,a.jsx)(s.hr,{}),"\n",(0,a.jsxs)(s.p,{children:["Just because encapsulation is a best practice, that doesn't always mean it's always the right choice. Sometimes using a public field is entirely appropriate. To get a sense of the use cases for getters and setters, we recommend that you pause now and read as much of ",(0,a.jsx)(s.a,{href:"https://stackoverflow.com/questions/1568091/why-use-getters-and-setters-accessors",children:"this stack overflow post"})," as you have the time for. The stack overflow article will list many reasons why using encapsulating fields is a best practice. The article also lists a few reasons why they are not always a good choice."]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Because we're just getting started with encapsulation, we're still going to follow best practice by making all fields private and exposing them through getter and setter methods."})}),"\n",(0,a.jsx)(s.h2,{id:"apie-abstraction-polymorphism-inheritance-encapsulation",children:"APIE: Abstraction, Polymorphism, Inheritance, Encapsulation"}),"\n",(0,a.jsx)(s.hr,{}),"\n",(0,a.jsx)(s.p,{children:"The acronym APIE stands for the four principles of object-oriented programming:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Abstraction"}),"\n",(0,a.jsx)(s.li,{children:"Polymorphism"}),"\n",(0,a.jsx)(s.li,{children:"Inheritance"}),"\n",(0,a.jsx)(s.li,{children:"Encapsulation"}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["We'll get to know each of these principles as we go along in the curriculum. If you are ready to read more now, we recommend checking out ",(0,a.jsx)(s.a,{href:"https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/oop",children:"this article on the MS Docs"}),"."]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);