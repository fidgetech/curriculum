"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[55789],{28453:(e,s,t)=>{t.d(s,{R:()=>r,x:()=>o});var n=t(96540);const a={},i=n.createContext(a);function r(e){const s=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(i.Provider,{value:s},e.children)}},76940:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-2-3-es6-classes","title":"\ud83d\udcd3 2.2.2.3 ES6 Classes","description":"We\'ve already covered ES6 support for modules, which are implemented with import and export. In this lesson, we\'ll go over ES6\'s native support for classes. Classes make JavaScript more accessible and easier to read from an object-oriented (OO) perspective. However, they don\'t fundamentally change the way JavaScript works.","source":"@site/docs/2_intermediate-javascript/2_test-driven-development-and-environments-with-javascript/2-2-2-03-es6-classes.md","sourceDirName":"2_intermediate-javascript/2_test-driven-development-and-environments-with-javascript","slug":"/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-2-3-es6-classes","permalink":"/v1.2/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-2-3-es6-classes","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 2.2.2.3 ES6 Classes","day":"tuesday","id":"2-2-2-3-es6-classes","hide_table_of_contents":true},"sidebar":"intermediate-javascript","previous":{"title":"\ud83d\udcd3 2.2.2.2 Introduction to ES6","permalink":"/v1.2/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-2-2-introduction-to-es6"},"next":{"title":"\ud83d\udcd3 2.2.2.4 ES6 Arrow Notation","permalink":"/v1.2/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-2-4-es6-arrow-notation"}}');var a=t(74848),i=t(28453);const r={title:"\ud83d\udcd3 2.2.2.3 ES6 Classes",day:"tuesday",id:"2-2-2-3-es6-classes",hide_table_of_contents:!0},o=void 0,c={},l=[{value:"<code>class</code> Syntax",id:"class-syntax",level:2},{value:"Inheritance in JavaScript",id:"inheritance-in-javascript",level:2},{value:"Using Variables in ES6 Classes",id:"using-variables-in-es6-classes",level:2}];function d(e){const s={blockquote:"blockquote",code:"code",div:"div",em:"em",h2:"h2",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(s.p,{children:["We've already covered ES6 support for modules, which are implemented with ",(0,a.jsx)(s.code,{children:"import"})," and ",(0,a.jsx)(s.code,{children:"export"}),". In this lesson, we'll go over ES6's native support for classes. Classes make JavaScript more accessible and easier to read from an object-oriented (OO) perspective. However, they don't fundamentally change the way JavaScript works."]}),"\n",(0,a.jsxs)(s.h2,{id:"class-syntax",children:[(0,a.jsx)(s.code,{children:"class"})," Syntax"]}),"\n",(0,a.jsx)(s.hr,{}),"\n",(0,a.jsxs)(s.p,{children:["Classes are a cornerstone of many OO languages, including Ruby, Java, and C#, but JavaScript didn't include support for classes until ES6. A class is used to define an object type. So far, we've used constructor functions to define object types, and added functionality to those objects via prototype methods. Using ",(0,a.jsx)(s.code,{children:"class"})," syntax will do the exact same thing, just with different syntax."]}),"\n",(0,a.jsxs)(s.p,{children:["Let's look at how we can refactor our ",(0,a.jsx)(s.code,{children:"Triangle"})," object to use ",(0,a.jsx)(s.code,{children:"class"})," syntax. To do this, we'll reference the business logic for ",(0,a.jsx)(s.code,{children:"triangle.js"})," in our Shape Tracker project:"]}),"\n",(0,a.jsx)(s.div,{className:"filename",children:"src/triangle.js"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-javascript",children:"function Triangle(side1, side2, side3) {\n  this.side1 = side1;\n  this.side2 = side2;\n  this.side3 = side3;\n}\n\nTriangle.prototype.checkType = function() {\n  ...\n};\n"})}),"\n",(0,a.jsxs)(s.p,{children:["Here we create a ",(0,a.jsx)(s.code,{children:"Triangle"})," constructor and then a prototype method for that constructor. Let's update this code to use ",(0,a.jsx)(s.code,{children:"class"})," syntax."]}),"\n",(0,a.jsx)(s.div,{className:"filename",children:"src/triangle.js"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-javascript",children:"class Triangle {\n  constructor(side1, side2, side3) {\n    this.side1 = side1;\n    this.side2 = side2;\n    this.side3 = side3;\n  }\n\n  checkType() {\n    //Function body goes here.\n  }    \n}\n"})}),"\n",(0,a.jsxs)(s.p,{children:["Our ",(0,a.jsx)(s.code,{children:"class Triangle"})," now contains both the ",(0,a.jsx)(s.code,{children:"Triangle"})," constructor and all its prototype methods. The ",(0,a.jsx)(s.code,{children:"Triangle()"})," constructor function now uses the ",(0,a.jsx)(s.code,{children:"constructor()"})," function, and we no longer need to specify the object type and ",(0,a.jsx)(s.code,{children:"prototype"})," when we declare the ",(0,a.jsx)(s.code,{children:"checkType()"})," method."]}),"\n",(0,a.jsx)(s.p,{children:"This code looks very similar to how we might construct a class in other OO languages such as Ruby and C#."}),"\n",(0,a.jsxs)(s.p,{children:["However, it's important to remember that JavaScript classes are syntactic sugar. ",(0,a.jsx)(s.strong,{children:"Syntactic sugar"})," is a term developers use for added functionality in a programming language that makes it easier to write and read."]}),"\n",(0,a.jsxs)(s.p,{children:["JavaScript classes are syntactic sugar because they don't operate in the same way that classes do in other OO languages such as Ruby. The biggest difference is that JavaScript doesn't directly use ",(0,a.jsx)(s.strong,{children:"classical inheritance"})," where classes inherit functionality from other classes. Instead, JavaScript uses what's commonly referred to as ",(0,a.jsx)(s.strong,{children:"prototypal inheritance"}),", where object types inherit from other object types through a prototype object."]}),"\n",(0,a.jsx)(s.h2,{id:"inheritance-in-javascript",children:"Inheritance in JavaScript"}),"\n",(0,a.jsx)(s.hr,{}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.strong,{children:"Classical inheritance"})," simply means that one class inherits from another class. While classical inheritance has its advantages, it has one major disadvantage: when one class inherits from another, it inherits ",(0,a.jsx)(s.em,{children:"everything"}),". The coder Joe Armstrong explains this problem with an apt metaphor:"]}),"\n",(0,a.jsxs)(s.blockquote,{children:["\n",(0,a.jsx)(s.p,{children:"You wanted a banana, but what you got was a gorilla holding the banana and the entire jungle."}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["With ",(0,a.jsx)(s.strong,{children:"prototypal inheritance"}),", objects inherit from other objects through a prototype object. The prototype object is saved in the ",(0,a.jsx)(s.code,{children:"__proto__"})," property on any JavaScript object, and it contains the functionality that it's inheriting from another object. Prototypal inheritance is an advanced topic beyond the scope of this lesson, but what's important in comparison to classical inheritance is that the scope of prototypal inheritance is more limited. In other words, if you want a banana, you'll just get a banana."]}),"\n",(0,a.jsxs)(s.p,{children:["The new ES6 ",(0,a.jsx)(s.code,{children:"class"})," syntax fakes classical inheritance by building it on top of prototypal inheritance. In other words, we can use this functionality to have one class inherit from another. To draw this connection, we use the ",(0,a.jsx)(s.code,{children:"extends"})," keyword:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-javascript",children:"class Shape {\n  ...\n}\n\nclass Triangle extends Shape {\n  ...\n}\n"})}),"\n",(0,a.jsx)(s.p,{children:"You won't be expected to create one class that inherits from another for any code review, but you're welcome to explore inheritance further in your multi-day project."}),"\n",(0,a.jsxs)(s.p,{children:["However, you will be expected to use ",(0,a.jsx)(s.code,{children:"class"})," syntax to create object types for the upcoming code review."]}),"\n",(0,a.jsx)(s.h2,{id:"using-variables-in-es6-classes",children:"Using Variables in ES6 Classes"}),"\n",(0,a.jsx)(s.hr,{}),"\n",(0,a.jsxs)(s.p,{children:["There is one important thing to note about ES6 ",(0,a.jsx)(s.code,{children:"class"})," syntax. Variables cannot be scoped to the class itself. The following will not work:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-javascript",children:"class Triangle {\n  let variableScopedToClass = 0;\n}\n"})}),"\n",(0,a.jsxs)(s.p,{children:["Scoping a variable inside a class (regardless of whether using ",(0,a.jsx)(s.code,{children:"var"}),", ",(0,a.jsx)(s.code,{children:"let"})," or ",(0,a.jsx)(s.code,{children:"const"}),") will result in the following error: ",(0,a.jsx)(s.code,{children:"Parsing error: Unexpected token"}),". It's not a very helpful error, which is why we mention it here. Students coming from other languages (such as C# or Ruby) may expect that JS will also have class variables, but that is not the case."]}),"\n",(0,a.jsx)(s.p,{children:"Instead, variables should always be scoped to methods inside the class (including the constructor). For instance, this is fine:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-javascript",children:"class Triangle {\n  \n  constructor() {\n    this.variableScopedToConstructor = 0;\n  }\n\n  checkType() {\n    let variableScopedToMethod = 0;\n  }    \n}\n"})}),"\n",(0,a.jsx)(s.p,{children:"The people behind ES6 made a conscious choice not to include class variables. The reasons for this are beyond the scope of this lesson; for now, it's enough to say that class variables simply don't fit JavaScript's prototypal inheritance model. In any case, variables should be scoped as tightly as possible as a best practice, so avoiding class variables (and global variables) is always a good idea."}),"\n",(0,a.jsx)(s.p,{children:"While ES6's implementation of classes is mostly syntactic sugar, utilizing classes can make your code cleaner, more organized, and easier to read!"})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);