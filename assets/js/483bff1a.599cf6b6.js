"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[59338],{28453:(e,r,o)=>{o.d(r,{R:()=>i,x:()=>s});var t=o(96540);const n={},a=t.createContext(n);function i(e){const r=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),t.createElement(a.Provider,{value:r},e.children)}},49752:(e,r,o)=>{o.r(r),o.d(r,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"introduction-to-programming/arrays-looping/1-3-4-1-array-mapping","title":"\ud83d\udcd3 1.3.4.1 Array Mapping","description":"Note: While you are not required to use Array.prototype.map() for this independent project, it is one of the most powerful JavaScript looping methods. We will be covering it more in depth in the React curriculum as well.","source":"@site/docs/1_introduction-to-programming/3_arrays-looping/1-3-4-01-array-mapping.md","sourceDirName":"1_introduction-to-programming/3_arrays-looping","slug":"/introduction-to-programming/arrays-looping/1-3-4-1-array-mapping","permalink":"/v1.2/introduction-to-programming/arrays-looping/1-3-4-1-array-mapping","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 1.3.4.1 Array Mapping","day":"thursday","id":"1-3-4-1-array-mapping","hide_table_of_contents":true},"sidebar":"introduction-to-programming","previous":{"title":"\ud83d\udcd3 1.3.3.10 Further Exploration: Regular Expressions with Text Analyzer","permalink":"/v1.2/introduction-to-programming/arrays-looping/1-3-3-10-further-exploration-regular-expressions-with-text-analyzer"},"next":{"title":"\u270f\ufe0f 1.3.4.2 Practice: Array Mapping","permalink":"/v1.2/introduction-to-programming/arrays-looping/1-3-4-2-practice-array-mapping"}}');var n=o(74848),a=o(28453);const i={title:"\ud83d\udcd3 1.3.4.1 Array Mapping",day:"thursday",id:"1-3-4-1-array-mapping",hide_table_of_contents:!0},s=void 0,l={},c=[{value:"<code>Array.prototype.map()</code>",id:"arrayprototypemap",level:2},{value:"When to Use <code>Array.prototype.map()</code>",id:"when-to-use-arrayprototypemap",level:3},{value:"Documentation on MDN",id:"documentation-on-mdn",level:3}];function d(e){const r={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"Note:"})," While you are not required to use ",(0,n.jsx)(r.code,{children:"Array.prototype.map()"})," for this independent project, it is one of the most powerful JavaScript looping methods. We will be covering it more in depth in the React curriculum as well."]}),"\n",(0,n.jsx)(r.p,{children:"So far, we've explored two commonly used JavaScript functions for looping:"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.code,{children:"Array.prototype.forEach()"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.code,{children:"for"})}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:"Both of the JavaScript techniques for looping we've learned are very open-ended. They simply loop until a condition is met. We can do whatever we want with that loop, whether that's create a new array with modified elements, sum a value, and so on."}),"\n",(0,n.jsxs)(r.p,{children:["However, JavaScript also provides some other high level methods that don't just iterate \u2014 they ",(0,n.jsx)(r.em,{children:"transform"})," the array they are looping over. In this lesson, we'll discuss ",(0,n.jsx)(r.code,{children:"Array.prototype.map()"}),", a high level method. Later when we learn about functional programming in the React course, we'll learn about other higher level looping methods like ",(0,n.jsx)(r.code,{children:"Array.prototype.reduce()"})," and ",(0,n.jsx)(r.code,{children:"Array.prototype.filter()"}),"."]}),"\n",(0,n.jsx)(r.h2,{id:"arrayprototypemap",children:(0,n.jsx)(r.code,{children:"Array.prototype.map()"})}),"\n",(0,n.jsx)(r.hr,{}),"\n",(0,n.jsxs)(r.p,{children:["First, what do we mean by ",(0,n.jsx)(r.em,{children:"high level"}),"? Well, in the sense of a programming language, a ",(0,n.jsx)(r.em,{children:"low level"})," language is one that's close to how a machine operates (such as the assembly language) while a ",(0,n.jsx)(r.em,{children:"high level"})," language is one that's closer to how humans think and communicate \u2014 such as JavaScript."]}),"\n",(0,n.jsxs)(r.p,{children:["While methods like ",(0,n.jsx)(r.code,{children:"for"})," aren't ",(0,n.jsx)(r.em,{children:"low level"}),", they are a little bit closer to how our machine thinks: we have to set the start and end conditions as well as an incrementer. We also have to write out all the code that dictates what will happen during each iteration."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"Array.prototype.forEach()"})," is higher level \u2014 we don't have to specify start and end conditions or an incrementer \u2014 ",(0,n.jsx)(r.code,{children:"Array.prototype.forEach()"}),' will automatically iterate through every element in the array. While this makes it "easier" to use in many ways, it\'s also a bit more abstract \u2014 which can be challenging for beginning coders.']}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"Array.prototype.map()"})," takes this one step further. If we want to have a new array with modified elements, this method will handle that for us. There is no need to first initialize a new array and then push modified elements into it. For that reason, it's cleaner and uses less code."]}),"\n",(0,n.jsxs)(r.p,{children:["Let's return to our element-doubling example. We can double each element in an array and save the doubled elements using ",(0,n.jsx)(r.code,{children:"Array.prototype.forEach()"}),":"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-js",children:"> const array = [0,1,2,3,4,5];\n> let doubledArray = [];\n> array.forEach(function(element) {\n  doubledArray.push(element * 2);\n});\n> doubledArray;\n(6) [0,2,4,6,8,10]\n"})}),"\n",(0,n.jsxs)(r.p,{children:["Let's see how we can do the same thing with ",(0,n.jsx)(r.code,{children:"Array.prototype.map()"}),":"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-js",children:"> const array = [0,1,2,3,4,5];\n> const doubledArray = array.map(function(element) {\n  return element * 2;\n});\n> doubledArray;\n(6) [0,2,4,6,8,10]\n"})}),"\n",(0,n.jsxs)(r.p,{children:["As we can see here, we no longer need to initialize an empty array. Instead, we can save the results of ",(0,n.jsx)(r.code,{children:"Array.prototype.map()"})," inside a variable (which we call ",(0,n.jsx)(r.code,{children:"doubledArray"}),")."]}),"\n",(0,n.jsxs)(r.p,{children:["Like ",(0,n.jsx)(r.code,{children:"Array.prototype.forEach()"}),", ",(0,n.jsx)(r.code,{children:"Array.prototype.map"})," takes a function as an argument, which is called a callback function."]}),"\n",(0,n.jsxs)(r.p,{children:["However, there's a huge difference here: we can't use a ",(0,n.jsx)(r.code,{children:"return"})," statement with ",(0,n.jsx)(r.code,{children:"Array.prototype.forEach()"}),". With ",(0,n.jsx)(r.code,{children:"Array.prototype.map()"}),", we ",(0,n.jsx)(r.em,{children:"must"})," use a ",(0,n.jsx)(r.code,{children:"return"})," statement."]}),"\n",(0,n.jsxs)(r.p,{children:["Each time we iterate with ",(0,n.jsx)(r.code,{children:"Array.prototype.map()"}),", we are specifying how the element should be transformed. The transformation occurs and the transformed element will be placed in a new array for us. That's why we need to have a ",(0,n.jsx)(r.code,{children:"return"})," statement within ",(0,n.jsx)(r.code,{children:"Array.prototype.map()"})," \u2014 to make sure the transformed element gets saved to the new array."]}),"\n",(0,n.jsxs)(r.p,{children:['It should be clear how this even more "higher level" than ',(0,n.jsx)(r.code,{children:"Array.prototype.forEach()"})," \u2014 ",(0,n.jsx)(r.code,{children:"Array.prototype.map()"})," does more for us, abstracting away the need to initialize a new array and push elements into it."]}),"\n",(0,n.jsxs)(r.p,{children:["While we ",(0,n.jsx)(r.em,{children:"could"})," omit the ",(0,n.jsx)(r.code,{children:"return"})," keyword from our ",(0,n.jsx)(r.code,{children:"Array.prototype.map()"})," callback (JavaScript won't complain), it will break our code. Without the ",(0,n.jsx)(r.code,{children:"return"})," keyword, ",(0,n.jsx)(r.code,{children:"doubledArray"})," will look like this:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-js",children:"[undefined, undefined, undefined, undefined, undefined, undefined]\n"})}),"\n",(0,n.jsxs)(r.p,{children:["This is exactly what happens when we forget to return from a function: the value of the variable storing the invoked function will be ",(0,n.jsx)(r.code,{children:"undefined"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["Another big thing to note here \u2014 ",(0,n.jsx)(r.code,{children:"Array.prototype.map()"})," returns a transformed array. We can't use it to sum the values of an array (as we can with ",(0,n.jsx)(r.code,{children:"Array.prototype.forEach()"}),"). There's actually another method we can use to sum values called ",(0,n.jsx)(r.code,{children:"Array.prototype.reduce()"}),". While you're welcome to explore that method on your own, we won't cover it until we discuss functional programming."]}),"\n",(0,n.jsxs)(r.h3,{id:"when-to-use-arrayprototypemap",children:["When to Use ",(0,n.jsx)(r.code,{children:"Array.prototype.map()"})]}),"\n",(0,n.jsxs)(r.p,{children:["When should we favor ",(0,n.jsx)(r.code,{children:"Array.prototype.map()"})," over ",(0,n.jsx)(r.code,{children:"Array.prototype.forEach()"}),"? Well, first a word of caution \u2014 you should really feel solid using ",(0,n.jsx)(r.code,{children:"Array.prototype.forEach()"})," before you start experimenting with ",(0,n.jsx)(r.code,{children:"Array.prototype.map()"})," too much. At this stage in your coding development, it's fine if you only use ",(0,n.jsx)(r.code,{children:"Array.prototype.forEach()"}),", at least until you feel very comfortable with it."]}),"\n",(0,n.jsxs)(r.p,{children:["However, in your long-term development as a coder, there will come a point (sooner rather than later) where you should favor ",(0,n.jsx)(r.code,{children:"Array.prototype.map()"})," any time you want to create a new array where all the elements have been transformed."]}),"\n",(0,n.jsx)(r.p,{children:"We can't use it to return a string as we do when we determine things we like. However, we could do this instead:"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-js",children:'> const arrayOfThingsILike = ["bubble baths", "kittens", "good books", "clean code"];\n> const thingsILike = arrayOfThingsILike.map(function(thing) {\n  return "I like " + thing + "!";\n});\n> thingsILike.join(" ");\n> thingsILike;\n(4) [\'I like bubble baths!\', \'I like kittens!\', \'I like good books!\', \'I like clean code!\']\n'})}),"\n",(0,n.jsx)(r.p,{children:"In this example, we create an array of transformed strings and then join the elements in the array to get 4 separate sentences."}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"Array.prototype.map()"})," is extremely powerful. It is, in fact, one of the most powerful and important methods in JavaScript. If you feel comfortable using ",(0,n.jsx)(r.code,{children:"for"})," and ``Array.prototype.forEach()",(0,n.jsx)(r.code,{children:"loops, you can experiment with"}),"Array.prototype.map()",(0,n.jsx)(r.code,{children:"now. If you are still getting the hang of"}),"for",(0,n.jsx)(r.code,{children:"and"}),"Array.prototype.forEach()",(0,n.jsx)(r.code,{children:"(which is completely expected and even likely considering we've just started learning about loops), store this information away for now and focus on"}),"for",(0,n.jsx)(r.code,{children:"and"}),"Array.prototype.forEach()`."]}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"While you are expected to loop for the next independent project, you are not expected to use ``Array.prototype.map()` \u2014 though you may do so if you wish."})}),"\n",(0,n.jsx)(r.h3,{id:"documentation-on-mdn",children:"Documentation on MDN"}),"\n",(0,n.jsxs)(r.p,{children:["For more information, check out ",(0,n.jsxs)(r.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map",children:["the Mozilla documentation on ",(0,n.jsx)(r.code,{children:"Array.prototype.map()"}),"."]})]})]})}function h(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}}}]);