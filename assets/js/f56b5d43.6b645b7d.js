"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[90568],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>s});var o=n(96540);const i={},a=o.createContext(i);function r(e){const t=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(a.Provider,{value:t},e.children)}},42281:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"c-and-net/many-to-many-relationships/customizing-entity-properties-with-data-annotations","title":"\ud83d\udcd3 Customizing Entity Properties with Data Annotations","description":"At the end of the lesson on model validation with validation attributes, we added two validation attributes to our Item model: we made the Item.Description property [Required], and we set a [Range] between 1 and the integer\'s max value for the Item.CategoryId property.","source":"@site/versioned_docs/version-v1_3/3_c-and-net/4_many-to-many-relationships/customizing-entity-properties-with-data-annotations.md","sourceDirName":"3_c-and-net/4_many-to-many-relationships","slug":"/c-and-net/many-to-many-relationships/customizing-entity-properties-with-data-annotations","permalink":"/v1.3/c-and-net/many-to-many-relationships/customizing-entity-properties-with-data-annotations","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 Customizing Entity Properties with Data Annotations","day":"monday","id":"customizing-entity-properties-with-data-annotations","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.4.1.2 Model Validation with Validation Attributes","permalink":"/v1.3/c-and-net/many-to-many-relationships/3-4-1-2-model-validation-with-validation-attributes"},"next":{"title":"\ud83d\udcd3 3.4.2.1 Creating a Splash Page with Data from Multiple Database Tables","permalink":"/v1.3/c-and-net/many-to-many-relationships/3-4-2-1-creating-a-splash-page-with-data-from-multiple-database-tables"}}');var i=n(74848),a=n(28453);const r={title:"\ud83d\udcd3 Customizing Entity Properties with Data Annotations",day:"monday",id:"customizing-entity-properties-with-data-annotations",hide_table_of_contents:!0},s=void 0,d={},l=[{value:"How Entity Properties Are Configured in our Database",id:"how-entity-properties-are-configured-in-our-database",level:2},{value:"Seeing How an Entity Property Is Customized with Data Annotations",id:"seeing-how-an-entity-property-is-customized-with-data-annotations",level:2},{value:"Takeaways",id:"takeaways",level:2},{value:"Repository Reference",id:"repository-reference",level:3}];function c(e){const t={a:"a",code:"code",div:"div",h2:"h2",h3:"h3",hr:"hr",i:"i",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["At the end of the lesson on model validation with validation attributes, we added two validation attributes to our ",(0,i.jsx)(t.code,{children:"Item"})," model: we made the ",(0,i.jsx)(t.code,{children:"Item.Description"})," property ",(0,i.jsx)(t.code,{children:"[Required]"}),", and we set a ",(0,i.jsx)(t.code,{children:"[Range]"})," between 1 and the integer's max value for the ",(0,i.jsx)(t.code,{children:"Item.CategoryId"})," property."]}),"\n",(0,i.jsxs)(t.p,{children:["Well, in the process of adding the ",(0,i.jsx)(t.code,{children:"[Required]"})," validation attribute to the ",(0,i.jsx)(t.code,{children:"Item.Description"})," property, we were also specifying how ",(0,i.jsx)(t.code,{children:"Item.Description"})," as an ",(0,i.jsx)(t.strong,{children:"entity property"})," should be configured in our database. That's right \u2014 ",(0,i.jsx)(t.strong,{children:"data annotations can be used to configure our entities in code-first development with EF Core"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["In the case of ",(0,i.jsx)(t.code,{children:"Item.Description"})," having the ",(0,i.jsx)(t.code,{children:"[Required]"})," data annotation, this now updates our entity property to be non-nullable. When a database column is non-nullable, it means it can't be ",(0,i.jsx)(t.code,{children:"null"}),", or have no value. This means that each entry in that table must have a value for that column, because the values for that column can't be ",(0,i.jsx)(t.code,{children:"null"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"However, to make this change reflected in our database, we need to create a migration and then update our database. Let's walkthrough this whole process. We'll also pause to look at the migration we create to see how to can verify how data annotations change our entity properties. At the end of this lesson, we'll talk about the important takeaways."}),"\n",(0,i.jsx)(t.h2,{id:"how-entity-properties-are-configured-in-our-database",children:"How Entity Properties Are Configured in our Database"}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsxs)(t.p,{children:["The first thing to understand about entity properties is that EF Core handles creating all of the default configurations based on the code within our models. And usually those default configurations are sufficient! For example, the default configurations for our ",(0,i.jsx)(t.code,{children:"Item.Description"})," entity property is for there to be a column called ",(0,i.jsx)(t.code,{children:"Description"})," of type ",(0,i.jsx)(t.code,{children:"longtext"})," that is ",(0,i.jsx)(t.code,{children:"nullable"})," added to our ",(0,i.jsx)(t.code,{children:"Items"})," table."]}),"\n",(0,i.jsxs)(t.p,{children:["There are also specific default configurations for primary keys (like ",(0,i.jsx)(t.code,{children:"Item.ItemId"}),") and foreign keys (like ",(0,i.jsx)(t.code,{children:"Item.CategoryId"}),"). Again, these defaults are more than sufficient \u2014 they are set up in order for our code-first migrations to set up conventional tables and columns as well as relationships within our MySQL database."]}),"\n",(0,i.jsxs)(t.p,{children:["When we add a data annotation to the ",(0,i.jsx)(t.code,{children:"Item.Description"})," property, we're creating a custom configuration for our entity property. We can do this as-needed. As we've already covered, adding ",(0,i.jsx)(t.code,{children:"[Required]"})," to our ",(0,i.jsx)(t.code,{children:"Item.Description"})," entity property will cause it to be non-nullable. The next steps are to create a new migration and update the database, which we'll cover more about in a moment."]}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"Models/Item.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'using System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace ToDoList.Models\n{\n    public class Item\n    {\n        public int ItemId { get; set; }\n        [Required(ErrorMessage = "The item\'s description can\'t be empty!")]\n        public string Description { get; set; }\n        [Range(1, int.MaxValue, ErrorMessage = "You must add your item to a category. Have you created a category yet?")]\n        public int CategoryId { get; set; }\n        public Category Category { get; set; }\n        public List<ItemTag> JoinEntities { get;}\n    }\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"[Required]"})," data annotation is a part of ",(0,i.jsxs)(t.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations?view=net-6.0",children:["the ",(0,i.jsx)(t.code,{children:"System.ComponentModel.DataAnnotations"})," namespace"]}),". However, ",(0,i.jsxs)(t.strong,{children:["not all data annotations listed within the ",(0,i.jsx)(t.code,{children:"System.ComponentModel.DataAnnotations"})," namespace apply to entity properties."]})," For example, the ",(0,i.jsx)(t.code,{children:"[Range]"})," data annotation does not do anything to entity properties."]}),"\n",(0,i.jsxs)(t.p,{children:["To see a complete list of different ways we can configure entity properties, review the MS Docs on ",(0,i.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/ef/core/modeling/entity-properties?tabs=data-annotations%2Cwithout-nrt",children:"entity properties"}),". This documentation covers default configurations, as well as data annotations that are a part of ",(0,i.jsxs)(t.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.schema?view=net-6.0",children:["the ",(0,i.jsx)(t.code,{children:"System.ComponentModel.DataAnnotations.Schema"})," namespace"]})," that are used with EF Core entities."]}),"\n",(0,i.jsx)(t.h2,{id:"seeing-how-an-entity-property-is-customized-with-data-annotations",children:"Seeing How an Entity Property Is Customized with Data Annotations"}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsxs)(t.p,{children:["We can see exactly how an entity property is customized with a data annotation by creating a new migration and reviewing the changes within. Remember that a ",(0,i.jsx)(t.strong,{children:"migration"})," is simply a file that describes an update to the database. Every time we change our entities in our code, we need to make a new migration that describes that change, which we can then use to update our database."]}),"\n",(0,i.jsx)(t.p,{children:"Let's create a new migration now. In the production directory of our To Do List app, run the following command:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"dotnet ef migrations add RequireItemDescription\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Keep in mind that the name of our migration should be descriptive! We could have also chosen a name like ",(0,i.jsx)(t.code,{children:"MakeItemDescriptionNonNullable"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Next, let's take a look at the new migration we created. Open the newly created migration file and take a look at the changes described within. It should be named something similar to ",(0,i.jsx)(t.code,{children:"Migrations/20221222195805_RequireItemDescription.cs"}),"."]}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"Migrations/20221222195805_RequireItemDescription.cs"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cs",children:'using Microsoft.EntityFrameworkCore.Migrations;\n\n#nullable disable\n\nnamespace ToDoList.Migrations\n{\n    public partial class RequireItemDescription : Migration\n    {\n        protected override void Up(MigrationBuilder migrationBuilder)\n        {\n            migrationBuilder.UpdateData(\n                table: "Items",\n                keyColumn: "Description",\n                keyValue: null,\n                column: "Description",\n                value: "");\n\n            migrationBuilder.AlterColumn<string>(\n                name: "Description",\n                table: "Items",\n                type: "longtext",\n                nullable: false,\n                oldClrType: typeof(string),\n                oldType: "longtext",\n                oldNullable: true)\n                .Annotation("MySql:CharSet", "utf8mb4")\n                .OldAnnotation("MySql:CharSet", "utf8mb4");\n        }\n\n        protected override void Down(MigrationBuilder migrationBuilder)\n        {\n            migrationBuilder.AlterColumn<string>(\n                name: "Description",\n                table: "Items",\n                type: "longtext",\n                nullable: true,\n                oldClrType: typeof(string),\n                oldType: "longtext")\n                .Annotation("MySql:CharSet", "utf8mb4")\n                .OldAnnotation("MySql:CharSet", "utf8mb4");\n        }\n    }\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["First, a refresher: the ",(0,i.jsx)(t.code,{children:"Up()"})," method describes how to update our database with the new change, and the ",(0,i.jsx)(t.code,{children:"Down()"})," method describes how to remove that change from our database. The ",(0,i.jsx)(t.code,{children:"Down()"})," method would be used if we were to update our database with ",(0,i.jsx)(t.code,{children:"dotnet ef database update"})," and then later remove the last migration with the command ",(0,i.jsx)(t.code,{children:"dotnet ef migrations remove"}),". As needed, we can directly update the code within these migrations files, though you likely won't have a reason to in your projects."]}),"\n",(0,i.jsxs)(t.p,{children:["If we take a closer look at the ",(0,i.jsx)(t.code,{children:"Up()"})," method, we can see the exact update we're making to our database:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["With ",(0,i.jsx)(t.code,{children:"nullable: false"}),", the ",(0,i.jsx)(t.code,{children:"Description"})," column within the ",(0,i.jsx)(t.code,{children:"Items"})," table is being updated to not allow ",(0,i.jsx)(t.code,{children:"null"})," values."]}),"\n",(0,i.jsxs)(t.li,{children:["With ",(0,i.jsx)(t.code,{children:"oldNullable: true"}),", we can see the previous state for the ",(0,i.jsx)(t.code,{children:"Description"})," column as accepting ",(0,i.jsx)(t.code,{children:"null"})," values."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The process of looking inside the migration file just verifies that the ",(0,i.jsx)(t.code,{children:"[Required]"})," validation attribute for ",(0,i.jsx)(t.code,{children:"Item.Description"})," not only provided model validation in our apps, but also re-configured our entity property to be non-nullable."]}),"\n",(0,i.jsx)(t.p,{children:"To complete the process of updating our entity property, we simply need to update our database:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"dotnet ef database update\n"})}),"\n",(0,i.jsx)(t.h2,{id:"takeaways",children:"Takeaways"}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.p,{children:"The big takeaway of this lesson is that we need to be aware of how data annotations used for model validation can also change how our entity properties are configured. When this happens, we'll want to track the new configuration with a new migration and an update to our database."}),"\n",(0,i.jsx)(t.p,{children:"There won't be many cases in which we'll want to directly configure our entity properties, though you are welcome to experiment more on your own. Generally, we'll end up configuring our entity properties because we want to add model validation to our project's models."}),"\n",(0,i.jsx)(t.h3,{id:"repository-reference",children:"Repository Reference"}),"\n",(0,i.jsx)(t.p,{children:"Follow the link below to view how a sample version of the project should look at this point. Note that this is a link to a specific branch in the repository."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:(0,i.jsxs)(t.a,{href:"https://github.com/epicodus-lessons/section-4-to-do-list-with-many-to-many-csharp-net6/tree/5_model_validation",children:[(0,i.jsx)(t.i,{className:"glyphicon glyphicon-folder-open"}),"  GitHub Repo for To Do List with EF Core Migrations and a Many-to-Many Relationship: 5_model_validation"]})})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);