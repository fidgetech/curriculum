"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[47728],{28453:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>a});var o=n(96540);const i={},r=o.createContext(i);function c(e){const t=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),o.createElement(r.Provider,{value:t},e.children)}},37228:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/click-pencil-icon-56d96af3b4844eeb244d1513ad17eb0a.png"},53829:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/merge-conflict-4bdf9768bd18f8d9c46901d41fc03373.png"},83870:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>d,frontMatter:()=>c,metadata:()=>o,toc:()=>s});const o=JSON.parse('{"id":"capstone/capstone-week-6/practicing-the-git-workflow","title":"\ud83d\udcd3 Practicing the Git Workflow","description":"We\'ve covered the basics of using a git workflow \u2014 now it\'s time to practice a little. We recommend going through this practice before you actually start working on your group project. This way, you\'ll be more equipped to use this workflow, and to deal with any issues that come up.","source":"@site/docs/capstone/6_capstone-week-6/practicing-the-git-workflow.md","sourceDirName":"capstone/6_capstone-week-6","slug":"/capstone/capstone-week-6/practicing-the-git-workflow","permalink":"/v1.2/capstone/capstone-week-6/practicing-the-git-workflow","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"\ud83d\udcd3 Practicing the Git Workflow","id":"practicing-the-git-workflow","slug":"practicing-the-git-workflow","hide_table_of_contents":true,"sidebar_position":6,"day":"weekend","type":"lesson","url":"https://github.com/epicodus-curriculum/shared-full-stack/blob/main/practicing_git_workflow.md"},"sidebar":"capstone","previous":{"title":"\ud83d\udcd3 Learning More About Git","permalink":"/v1.2/capstone/capstone-week-6/learning-more-about-git"},"next":{"title":"\ud83d\udcd3 Pull Requests with Branches","permalink":"/v1.2/capstone/capstone-week-6/pull-requests-with-branches"}}');var i=n(74848),r=n(28453);const c={title:"\ud83d\udcd3 Practicing the Git Workflow",id:"practicing-the-git-workflow",slug:"practicing-the-git-workflow",hide_table_of_contents:!0,sidebar_position:6,day:"weekend",type:"lesson",url:"https://github.com/epicodus-curriculum/shared-full-stack/blob/main/practicing_git_workflow.md"},a=void 0,h={},s=[];function l(e){const t={a:"a",code:"code",div:"div",em:"em",img:"img",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["We've covered the basics of using a git workflow \u2014 now it's time to practice a little. We recommend going through this practice ",(0,i.jsx)(t.em,{children:"before"})," you actually start working on your group project. This way, you'll be more equipped to use this workflow, and to deal with any issues that come up."]}),"\n",(0,i.jsx)(t.p,{children:"This will be an extremely simple exercise \u2014 we will just make some small modifications to a README. That's because the goal here isn't to code, but to practice the workflow itself and also deal with a merge conflict."}),"\n",(0,i.jsxs)(t.p,{children:["Start by creating a new directory called ",(0,i.jsx)(t.code,{children:"workflow-practice"}),". It will have just one file: ",(0,i.jsx)(t.code,{children:"README.md"}),"."]}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"README.md"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Hello!\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Next, let's run the ",(0,i.jsx)(t.code,{children:"git init"})," command. Create a ",(0,i.jsx)(t.code,{children:"git-workflow"})," repository in GitHub and then connect it to this project using ",(0,i.jsx)(t.code,{children:"git remote add origin git-workflow"}),". This will be a repository we can throw away later \u2014 it's just for practice!"]}),"\n",(0,i.jsx)(t.p,{children:"Save the code in the README and make your first commit:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'$ git add .\n$ git commit -m "add greeting"\n'})}),"\n",(0,i.jsx)(t.p,{children:"Once the code is committed, push it to GitHub."}),"\n",(0,i.jsxs)(t.p,{children:["Next, let's create a new ",(0,i.jsx)(t.em,{children:"local"})," branch called ",(0,i.jsx)(t.code,{children:"development"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"$ git checkout -b development\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This will create a new branch ",(0,i.jsx)(t.em,{children:"locally"})," (the ",(0,i.jsx)(t.code,{children:"-b"})," flag), and then ",(0,i.jsx)(t.code,{children:"checkout"})," will automatically take us to that branch."]}),"\n",(0,i.jsxs)(t.p,{children:["It's common for large companies to have a ",(0,i.jsx)(t.code,{children:"development"})," branch. This isn't the production branch \u2014 instead, the developers will merge code into this branch, test that it works, and so on \u2014 ",(0,i.jsx)(t.em,{children:"before"})," it gets merged into the main branch, which is usually the production code. In this example, we'll just have the development branch along with the main branch to keep things simple. But in real world applications, there'd be additional feature branches which would get merged into the development branch first, and then tested, all before they are ever merged into main."]}),"\n",(0,i.jsxs)(t.p,{children:["It's always a good idea to verify the branch we are on with ",(0,i.jsx)(t.code,{children:"$ git branch"}),". That way, we won't accidentally start modifying code in the wrong branch."]}),"\n",(0,i.jsxs)(t.p,{children:["If we run ",(0,i.jsx)(t.code,{children:"$ git log"}),", we'll see that our first commit is in this branch as well. This is expected \u2014 when we create a new branch, it copies the code of the branch we are in along with its commit history. This is great for creating experimental features or for testing code."]}),"\n",(0,i.jsx)(t.p,{children:"Now let's modify our README:"}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"README.md"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Hola!\n"})}),"\n",(0,i.jsx)(t.p,{children:"Save and commit this code:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'$ git add .\n$ git commit -m "change greeting to Spanish"\n'})}),"\n",(0,i.jsx)(t.p,{children:"At this point, this branch has diverged from the main branch. Couldn't we just merge it into main?"}),"\n",(0,i.jsxs)(t.p,{children:["Well, if we are working on the project alone, that would probably be fine. But that's not how development teams work in the real world. Other teams are ",(0,i.jsx)(t.em,{children:"also"})," making changes to the code."]}),"\n",(0,i.jsxs)(t.p,{children:["So let's simulate that process. We'll make another change to our code, this time ",(0,i.jsx)(t.em,{children:"directly in GitHub"}),". This represents a second team working on the same code as us. They finished their update first and they've already merged their code into the main branch and pushed it to GitHub."]}),"\n",(0,i.jsx)(t.p,{children:"We can imitate this process by going to the repository in GitHub and clicking on the pencil icon, which allows us to modify the code directly in GitHub's UI."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Click on the pencil icon to make an update to the code.",src:n(37228).A+"",width:"1858",height:"352"})}),"\n",(0,i.jsx)(t.p,{children:"Now let's change the greeting to French in GitHubs:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Bonjour!\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Name the commit ",(0,i.jsx)(t.code,{children:'"change greeting to French"'}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Now we are getting closer to a real world process."}),"\n",(0,i.jsxs)(t.p,{children:["We now have a remote main branch in GitHub which has two commits. We have a local main branch which has one commit. And we have a local development branch which has two commits. All three of these branches ",(0,i.jsx)(t.em,{children:"have different greetings"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"So now let's say we want to merge our development branch into main and push that code to GitHub. How would we go about doing that?"}),"\n",(0,i.jsx)(t.p,{children:"Well, we need to switch back to the main branch and pull the latest code from GitHub. Then we need to switch back to the development branch, merge the code from main, make sure it is good to go, and then switch back to main and merge the development branch into main before we push it to GitHub. We'll walk through this whole process more slowly in a moment."}),"\n",(0,i.jsx)(t.p,{children:"Why this convoluted workflow?"}),"\n",(0,i.jsx)(t.p,{children:"Well, we don't ever want to merge experimental code into main until we know it works. If we have any merge conflicts or other problems, we want them to happen in the development branch. Once everything is fixed and good to go, we'll be ready to merge the code into the main branch, but not before then."}),"\n",(0,i.jsx)(t.p,{children:"So now let's slow this down. Here's what we need to do locally. We are currently on the development branch. We need to switch over to the main branch."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"$ git checkout main\n"})}),"\n",(0,i.jsx)(t.p,{children:"Next, we need to pull the latest code from GitHub:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"$ git pull origin main\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Now the main branch is up to date with the code that the other development team has already merged into main. We ",(0,i.jsx)(t.em,{children:"could"})," merge our development branch into the main branch, but that could potentially lead to a big mess, especially if there are merge conflicts. That's not a good workflow. Instead, we need to play it safe and switch over to the development branch. Alternatively, if we're really worried about making a mistake and messing up code on either the main or development branch, we could create a safety branch called something like ",(0,i.jsx)(t.code,{children:"savepoint"}),". This is one of the techniques suggested in ",(0,i.jsx)(t.a,{href:"http://think-like-a-git.net/sections/testing-out-merges/the-savepoint-pattern.html",children:"Think Like A Git"}),". It's not necessary to do this but it does create an extra layer of security when you're new to merging branches."]}),"\n",(0,i.jsxs)(t.p,{children:["Now let's go back to the development branch. We're ready to merge the code from main ",(0,i.jsx)(t.em,{children:"into"})," development. This is a really good time to verify that we are on the correct branch with ",(0,i.jsx)(t.code,{children:"$ git branch"}),". If we are on the wrong branch, we could seriously mess up our code when we try to merge!"]}),"\n",(0,i.jsx)(t.p,{children:"Once we've verified that we are on the development branch, we can run the following command:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"$ git merge main\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This will merge the main branch ",(0,i.jsx)(t.em,{children:"into"})," the branch we are on \u2014 the development branch."]}),"\n",(0,i.jsx)(t.p,{children:"Before we move on to the next step, what do you think is going to happen?"}),"\n",(0,i.jsx)(t.p,{children:"If you guessed that there will be a merge conflict, you're correct."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"$ git merge main\nAuto-merging README.md\nCONFLICT (content): Merge conflict in README.md\nAutomatic merge failed; fix conflicts and then commit the result.\n"})}),"\n",(0,i.jsx)(t.p,{children:"There have been two recent changes made to the code \u2014 how is Git supposed to know whether the greeting should be hola or bonjour?"}),"\n",(0,i.jsxs)(t.p,{children:["When there is a merge conflict, a list with the file (or files) that have merge conflicts will be printed to the command line. We can see this above: ",(0,i.jsx)(t.code,{children:"CONFLICT (content): Merge conflict in README.md"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Merge conflicts can be scary. Fortunately, VS Code makes managing conflicts much easier. If we navigate to the application in VS Code, we'll see the following:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Image shows the merge conflict in VS Code.",src:n(53829).A+"",width:"3192",height:"692"})}),"\n",(0,i.jsxs)(t.p,{children:["VS Code has helpfully organized the code into two parts: the ",(0,i.jsx)(t.em,{children:"Current Change"}),", which is the code from the branch we are on, and the ",(0,i.jsx)(t.em,{children:"Incoming Change"}),", which is the code coming from the branch we are merging. It's easy to remember which is which by thinking of the branch we are merging as being the ",(0,i.jsx)(t.em,{children:"incoming"})," branch and the branch we are on as being the ",(0,i.jsx)(t.em,{children:"current"})," branch."]}),"\n",(0,i.jsxs)(t.p,{children:["We have several choices here. If we click ",(0,i.jsx)(t.em,{children:"Accept Current Change"}),", the text will just be ",(0,i.jsx)(t.code,{children:"Hola!"})," If we click ",(0,i.jsx)(t.em,{children:"Accept Incoming Change"}),", the code will just be ",(0,i.jsx)(t.code,{children:"Bonjour!"})," And if we ",(0,i.jsx)(t.em,{children:"Accept Both Changes"}),", the code will read:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Hola!\nBonjour!\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Alternatively, we can modify the code directly \u2014 but if we do so, we have to make sure we remove ",(0,i.jsx)(t.code,{children:"======="})," and ",(0,i.jsx)(t.code,{children:">>>>>>> main"})," from our code in addition to making the changes. Git inserts these lines automatically to show where the code diverges in each branch."]}),"\n",(0,i.jsxs)(t.p,{children:["Because we are collaborative and both teams have done great work, we are going to ",(0,i.jsx)(t.em,{children:"Accept Both Changes"}),". Note that your use cases will vary greatly depending on the situation \u2014 sometimes you'll want both changes, sometimes you'll want just one, and sometimes you'll want parts of both \u2014 which means you'll need to update some of the code manually before declaring the merge a success and committing it."]}),"\n",(0,i.jsx)(t.p,{children:"Next, we are ready to save and commit our code."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'$ git add .\n$ git commit -m "update code to include both greetings"\n'})}),"\n",(0,i.jsx)(t.p,{children:"At this point, we've cleared up the merge conflict on the development branch, and we've made sure that the conflict posed no risk to the main branch. Once we've verified our code looks good (hopefully by testing it), it's ready to merge into main. Now we can switch over to the main branch and merge our code again:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"$ git checkout main\n$ git merge development\n"})}),"\n",(0,i.jsx)(t.p,{children:"As we'll see, the merge will go smoothly. That's because we've taken care of the merge conflict in the other branch!"}),"\n",(0,i.jsx)(t.p,{children:"At this point, we can safely push our code to the main branch."}),"\n",(0,i.jsx)(t.p,{children:"While this example is very simple, it should hopefully make the whole process of merging code a bit clearer. Ideally, when working with your group, you should be working on different parts of the code and create different features \u2014 which means you won't run into as many merge conflicts. Make sure you practice a good git workflow by following the steps above when merging and dealing with merge conflicts."}),"\n",(0,i.jsx)(t.p,{children:"If you're still feeling a bit foggy on these concepts, go ahead and repeat the process \u2014 add a few more files and then make different changes directly on GitHub and then on your development branch. This will give you the chance to work through a few more simple merge conflicts before you run into one that is potentially bigger and more confusing during your group project."})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);