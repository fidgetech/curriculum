"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[3080],{28453:(e,t,o)=>{o.d(t,{R:()=>i,x:()=>s});var n=o(96540);const a={},r=n.createContext(a);function i(e){const t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(r.Provider,{value:t},e.children)}},30526:(e,t,o)=>{o.d(t,{A:()=>n});const n=o.p+"assets/images/contact-prototype-chain-5b32ea24bbfd5c776d940d1294fa784d.png"},44102:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"intermediate-javascript/object-oriented-javascript/2-1-1-3-looping-through-objects-and-prototypal-inheritance","title":"\ud83d\udcd3 2.1.1.3 Looping Through Objects and Prototypal Inheritance","description":"In order to display all of the contacts in our application, we\'re going to need to loop through our address book\'s contacts. However, since our contacts are all stored in an object, we have to do this differently than we would with looping through an array.","source":"@site/docs/2_intermediate-javascript/1_object-oriented-javascript/2-1-1-03-looping-through-objects-and-prototypal-inheritance.md","sourceDirName":"2_intermediate-javascript/1_object-oriented-javascript","slug":"/intermediate-javascript/object-oriented-javascript/2-1-1-3-looping-through-objects-and-prototypal-inheritance","permalink":"/v1.2/intermediate-javascript/object-oriented-javascript/2-1-1-3-looping-through-objects-and-prototypal-inheritance","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 2.1.1.3 Looping Through Objects and Prototypal Inheritance","day":"monday","id":"2-1-1-3-looping-through-objects-and-prototypal-inheritance","hide_table_of_contents":true},"sidebar":"intermediate-javascript","previous":{"title":"\ud83d\udcd3 2.1.1.2 Address Book: User Interface","permalink":"/v1.2/intermediate-javascript/object-oriented-javascript/2-1-1-2-address-book-user-interface"},"next":{"title":"\ud83d\udcd3 2.1.1.4 Address Book: Adding Interactivity","permalink":"/v1.2/intermediate-javascript/object-oriented-javascript/2-1-1-4-address-book-adding-interactivity"}}');var a=o(74848),r=o(28453);const i={title:"\ud83d\udcd3 2.1.1.3 Looping Through Objects and Prototypal Inheritance",day:"monday",id:"2-1-1-3-looping-through-objects-and-prototypal-inheritance",hide_table_of_contents:!0},s=void 0,c={},h=[{value:"Looping Through Objects with <code>Object.keys()</code>",id:"looping-through-objects-with-objectkeys",level:2},{value:"Looping through Objects with <code>for...in</code>",id:"looping-through-objects-with-forin",level:2},{value:"A Review of Prototypes",id:"a-review-of-prototypes",level:3}];function l(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"In order to display all of the contacts in our application, we're going to need to loop through our address book's contacts. However, since our contacts are all stored in an object, we have to do this differently than we would with looping through an array."}),"\n",(0,a.jsx)(t.p,{children:"In this lesson, we'll learn exactly how to do that. Then, in the next lesson, we'll apply what we've learned here to actually loop through our contacts."}),"\n",(0,a.jsx)(t.p,{children:"In the process of learning about looping through object properties, we'll also do a deeper dive into prototypal inheritance \u2014 though not too deep!"}),"\n",(0,a.jsxs)(t.h2,{id:"looping-through-objects-with-objectkeys",children:["Looping Through Objects with ",(0,a.jsx)(t.code,{children:"Object.keys()"})]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.p,{children:"Let's say we have an object that stores information about the mathematician Ada Lovelace in our address book application. (Don't add any of the following code to the address book application \u2014 we are just using this as an example.) We want to take this information and convert it all into a single string which we'll display on our website."}),"\n",(0,a.jsx)(t.p,{children:"Let's take a look at our object:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'let mathematician = {\n  firstName: "Ada",\n  lastName: "Lovelace",\n  profession: "Mathematician",\n  funFact: "Daughter of Lord Byron",\n  countryOfBirth: "England",\n  yearOfBirth: 1815,\n  yearOfDeath: 1852\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["We ",(0,a.jsx)(t.em,{children:"could"})," just display each property individually (such as by doing ",(0,a.jsx)(t.code,{children:"mathematician.firstName"}),") but that becomes less and less feasible the more properties our objects have \u2014 and results in more and more work."]}),"\n",(0,a.jsxs)(t.p,{children:["So let's turn it into one long string instead. In ",(0,a.jsx)(t.a,{href:"../../intermediate-javascript/object-oriented-javascript/2-1-0-10-address-book-finding-and-deleting-contacts",children:"Address Book: Finding and Deleting Contacts"}),", we learned about ",(0,a.jsx)(t.code,{children:"Object.keys()"}),", a method that returns an array of all the keys in an object. We can take advantage of this method to grab the keys in an array and then loop over them:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'> const adaKeys = Object.keys(mathematician);\n> let adaString = "";\n> adaKeys.forEach(function(key) {\n  adaString = adaString.concat(key + ": " + mathematician[key] + "\\n"); \n});\n'})}),"\n",(0,a.jsxs)(t.p,{children:["This isn't too bad \u2014 we create a constant called ",(0,a.jsx)(t.code,{children:"adaKeys"})," that holds an array of the ",(0,a.jsx)(t.code,{children:"mathematician"})," object's keys. Next we initialize an empty string called ",(0,a.jsx)(t.code,{children:"adaString"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["Finally, we loop over our array of keys. For each key, we use ",(0,a.jsx)(t.code,{children:"String.prototype.concat()"})," to add a stringified key and value along with a new line after each key-value pair."]}),"\n",(0,a.jsxs)(t.p,{children:["If we print the values of ",(0,a.jsx)(t.code,{children:"adaString"})," to the DevTools console, we get the following string:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"> adaString;\n'firstName: Ada\\nlastName: Lovelace\\nprofession: Mathematician\\nfunFact: Daughter of Lord Byron\\ncountryOfBirth: England\\nyearOfBirth: 1815\\nyearOfDeath: 1852\\n'\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Something is wrong! I don't see any new lines, only the symbol ",(0,a.jsx)(t.code,{children:"\\n"})," that represents a new line. Well, in order to have the new line symbols be evaluated as new lines, we need them to be processed through a ",(0,a.jsx)(t.code,{children:"console.log()"})," in the DevTools or our HTML."]}),"\n",(0,a.jsxs)(t.p,{children:["If we log ",(0,a.jsx)(t.code,{children:"adaString"})," to the DevTools console, we get the following string:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"> console.log(adaString);\nfirstName: Ada\nlastName: Lovelace\nprofession: Mathematician\nfunFact: Daughter of Lord Byron\ncountryOfBirth: England\nyearOfBirth: 1815\nyearOfDeath: 1852\n"})}),"\n",(0,a.jsxs)(t.p,{children:["That looks better! And while this output may ",(0,a.jsx)(t.em,{children:"look"})," the same as our object, we now have a string. This could be helpful if we wanted to append many different objects to the DOM, especially if they have different keys. There's no need to specify each key in our code."]}),"\n",(0,a.jsx)(t.p,{children:"You might be thinking that the keys above don't look very pretty \u2014 they are formatted like JavaScript variables, not syntactically correct English. Well, our loop could also format the keys, automatically capitalizing the first letter and then using a regular expression to identify capital letters and then add separators so there is a space between each word. Only a little bit of code would be necessary to \"prettify\" this string so we could easily append entire objects to the DOM. We won't demonstrate how to do this in this lesson \u2014 after all, it has nothing to do with looping \u2014 but you may want to experiment with this in your own code!"}),"\n",(0,a.jsxs)(t.p,{children:["In general, using ",(0,a.jsx)(t.code,{children:"Object.keys()"})," is a very effective way to loop over properties in JavaScript. In fact, it's generally the best way to do so \u2014 and it's exactly what we'll do in the next lesson."]}),"\n",(0,a.jsxs)(t.h2,{id:"looping-through-objects-with-forin",children:["Looping through Objects with ",(0,a.jsx)(t.code,{children:"for...in"})]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsxs)(t.p,{children:["Now let's take a look at some syntactic sugar that JavaScript provides for looping through objects: the ",(0,a.jsx)(t.code,{children:"for...in"})," loop. ",(0,a.jsx)(t.strong,{children:"Caution:"})," There is an important use case where we won't want to use ",(0,a.jsx)(t.code,{children:"for...in"}),", which we will cover in a moment. Using ",(0,a.jsx)(t.code,{children:"Object.keys()"})," will generally be better! Going over this gotcha will give us further insights into prototypal inheritance."]}),"\n",(0,a.jsxs)(t.p,{children:["Here's an example of a ",(0,a.jsx)(t.code,{children:"for...in"})," loop:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'> let adaString = "";\n> for (const key in mathematician) {\n  adaString = adaString.concat(key + ": " + mathematician[key] + "\\n");\n}\n> console.log(adaString);\nfirstName: Ada\nlastName: Lovelace\nprofession: Mathematician\nfunFact: Daughter of Lord Byron\ncountryOfBirth: England\nyearOfBirth: 1815\nyearOfDeath: 1852\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The only thing we had to change here is the following syntax: ",(0,a.jsx)(t.code,{children:"for (const key in mathematician)"}),". The code inside the curly brackets ",(0,a.jsx)(t.code,{children:"{ }"})," remains the same, and so does the output when we log the value of ",(0,a.jsx)(t.code,{children:"adaString"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["As we can see, this is a special kind of ",(0,a.jsx)(t.code,{children:"for"})," loop. We first specify a variable name \u2014 here we call it ",(0,a.jsx)(t.code,{children:"key"})," but we could call it ",(0,a.jsx)(t.code,{children:"property"})," or something else. Then, we specify the object we are iterating over, which is ",(0,a.jsx)(t.code,{children:"mathematician"}),". In pseudocode, the syntax of the ",(0,a.jsx)(t.code,{children:"for...in"})," loop looks like so:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"for (const property in object) {\n  // execute code for each property in the object\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This all seems great, right? Well, now for the gotcha \u2014 and it's a big one. Let's see what happens if we use ",(0,a.jsx)(t.code,{children:"for...in"})," with a contact created using our ",(0,a.jsx)(t.code,{children:"Contact"})," prototype. First, add this code to your DevTools console:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'> function Contact(firstName, lastName, phoneNumber) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n  this.phoneNumber = phoneNumber;\n}\n> Contact.prototype.fullName = function() {\n  return this.firstName + " " + this.lastName;\n};\n> let newContact = new Contact("Ada", "Lovelace", "111-111-1111");\n'})}),"\n",(0,a.jsxs)(t.p,{children:["Now try looping over the contact object, looking at each ",(0,a.jsx)(t.code,{children:"key"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'> for (const key in newContact) {\n  console.log(newContact[key]);\n}\nAda\nLovelace\n111-111-1111\n\u0192 () {\n  return this.firstName + " " + this.lastName;\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"And what do we get? Well, the first three values make sense \u2014 but why is the following listed as a property?"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'\u0192 () {\n  return this.firstName + " " + this.lastName;\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["This is a method that's listed in our ",(0,a.jsx)(t.code,{children:"Contact"})," object! The ",(0,a.jsx)(t.code,{children:"Contact.prototype.fullName()"})," method to be precise. Now is a good time to review prototypes and prototypal inheritance, along with exploring more about ",(0,a.jsx)(t.code,{children:"for...in"})," loops."]}),"\n",(0,a.jsx)(t.h3,{id:"a-review-of-prototypes",children:"A Review of Prototypes"}),"\n",(0,a.jsxs)(t.p,{children:["Let's take a closer look at the ",(0,a.jsx)(t.code,{children:"newContact"})," object in the console:"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"This object contains a &quot;proto&quot; property which in turn contains the &quot;fullName&quot; function.",src:o(74845).A+"",width:"1446",height:"374"})}),"\n",(0,a.jsxs)(t.p,{children:["In the above image, we see that in addition to the three properties we created, ",(0,a.jsx)(t.code,{children:"Contact"})," also has a ",(0,a.jsx)(t.code,{children:"__proto__"})," property. If you are following along now in your DevTools console, note that this property may also be labeled as ",(0,a.jsx)(t.code,{children:"[[Prototype]]"})," instead of ",(0,a.jsx)(t.code,{children:"__proto__"}),". As we learned in a previous lesson, if we want to access an object's prototype, we do so by accessing the ",(0,a.jsx)(t.code,{children:"__proto__"})," property like so:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"> newContact.__proto__;\nfullName: \u0192 ()\nconstructor: \u0192 Contact(firstName, lastName, phoneNumber)\n[[Prototype]]: Object\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Both ",(0,a.jsx)(t.code,{children:"fullName"})," and ",(0,a.jsx)(t.code,{children:"constructor"})," are properties of this ",(0,a.jsx)(t.code,{children:"__proto__"})," object. This is how our humble ",(0,a.jsx)(t.code,{children:"newContact"})," object uses prototypal inheritance to get access to the ",(0,a.jsx)(t.code,{children:"Contact"})," constructor and the ",(0,a.jsx)(t.code,{children:"Contact.prototype.fullName()"})," method."]}),"\n",(0,a.jsxs)(t.p,{children:["In turn, we can see that ",(0,a.jsx)(t.code,{children:"__proto__"})," ",(0,a.jsx)(t.em,{children:"also"})," has a ",(0,a.jsx)(t.code,{children:"__proto__"})," property, which contains the functionality of basic objects in JavaScript. In a previous lesson, we learned that this chain of ",(0,a.jsx)(t.code,{children:"__proto__"})," objects makes ",(0,a.jsx)(t.strong,{children:"prototypal inheritance"})," possible in JavaScript. Let's review it now. Say we call this method on our ",(0,a.jsx)(t.code,{children:"newContact"})," object:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'> newContact.fullName();\n"Ada Lovelace"\n'})}),"\n",(0,a.jsxs)(t.p,{children:["When we call ",(0,a.jsx)(t.code,{children:"newContact.fullName()"}),", JavaScript will first look at our ",(0,a.jsx)(t.code,{children:"newContact"})," object to see if that method is attached to it. If it's not, it will look in the ",(0,a.jsx)(t.code,{children:"__proto__"})," property to see if the method is there. If it isn't, it will look at that ",(0,a.jsx)(t.code,{children:"__proto__"}),"'s ",(0,a.jsx)(t.code,{children:"__proto__"})," \u2014 until it finds the method."]}),"\n",(0,a.jsxs)(t.p,{children:["And if it doesn't find the method, it will return ",(0,a.jsx)(t.code,{children:"Uncaught TypeError: [functionName] is not a function"})," \u2014 where ",(0,a.jsx)(t.code,{children:"[functionName]"})," is the name of the function it couldn't find."]}),"\n",(0,a.jsxs)(t.p,{children:["Well, this is the problem with ",(0,a.jsx)(t.code,{children:"for...in"})," \u2014 it doesn't just iterate over properties of an object \u2014 it iterates over all the ",(0,a.jsx)(t.strong,{children:"enumerable"})," properties of the object as well as enumerable properties in the prototype chain. (",(0,a.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties",children:"Enumerable"})," just means that the property has an internal enumerable flag set to ",(0,a.jsx)(t.code,{children:"true"}),".)"]}),"\n",(0,a.jsxs)(t.p,{children:["In the case of our ",(0,a.jsx)(t.code,{children:"newContact"})," object, that means ",(0,a.jsx)(t.code,{children:"for...in"})," also enumerates over the properties of the ",(0,a.jsx)(t.code,{children:"Contact"})," object type \u2014 specifically ",(0,a.jsx)(t.code,{children:"Contact.prototype.fullName()"}),",  which we do not want!"]}),"\n",(0,a.jsxs)(t.p,{children:["This is actually a pretty annoying behavior \u2014 and it's too bad that ",(0,a.jsx)(t.code,{children:"for...in"})," loops do this."]}),"\n",(0,a.jsx)(t.p,{children:"We can fix the issue by doing the following:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'> let newContact = new Contact("Ada", "Lovelace", "111-111-1111");\n> for (const key in newContact) {\n  if (newContact.hasOwnProperty(key)) {\n    console.log(newContact[key]);\n  }\n}\nAda\nLovelace\n111-111-1111\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"Object.prototype.hasOwnProperty()"})," method returns a boolean. If a property belongs directly to an object (as ",(0,a.jsx)(t.code,{children:"firstName"})," belongs to our ",(0,a.jsx)(t.code,{children:"newContact"})," object), it will return ",(0,a.jsx)(t.code,{children:"true"}),". If the property doesn't belong to the object (as is the case of ",(0,a.jsx)(t.code,{children:"Contact.prototype.fullName()"}),", which belongs to the ",(0,a.jsx)(t.code,{children:"Contact"})," object type), it will return ",(0,a.jsx)(t.code,{children:"false"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["By the way, notice that the method ",(0,a.jsx)(t.code,{children:"Object.prototype.hasOwnProperty()"})," belongs to ",(0,a.jsxs)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",children:["the  ",(0,a.jsx)(t.code,{children:"Object"})," type"]})," and not ",(0,a.jsx)(t.code,{children:"Contact"}),", or ",(0,a.jsx)(t.code,{children:"newContact"})," for that matter. We can call ",(0,a.jsx)(t.code,{children:"Object.prototype.hasOwnProperty()"})," on ",(0,a.jsx)(t.code,{children:"newContact"}),", because ",(0,a.jsx)(t.code,{children:"newContact"})," has access to this method through prototypal inheritance."]}),"\n",(0,a.jsxs)(t.p,{children:["For every object in JavaScript, the ",(0,a.jsx)(t.code,{children:"Object"})," type ends the chain of prototypes. This means that every object in JavaScript inherits functionality from the ",(0,a.jsx)(t.code,{children:"Object"})," type through prototypal inheritance. In order for ",(0,a.jsx)(t.code,{children:"newContact"})," to access ",(0,a.jsx)(t.code,{children:"Object.prototype.hasOwnProperty()"}),", it has to go to its own ",(0,a.jsx)(t.code,{children:"__proto__"})," property, and then to the ",(0,a.jsx)(t.code,{children:"__proto__"}),"'s ",(0,a.jsx)(t.code,{children:"__proto__"})," property. The following image shows this, highlighting which properties are returned from which object:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["The orange box highlights the properties belonging to ",(0,a.jsx)(t.code,{children:"newContact;"}),"."]}),"\n",(0,a.jsxs)(t.li,{children:["The green box highlights the properties belonging to ",(0,a.jsx)(t.code,{children:"Contact"}),", accessed through ",(0,a.jsx)(t.code,{children:"newContact.__proto__;"}),"."]}),"\n",(0,a.jsxs)(t.li,{children:["The blue box highlights the properties belonging to ",(0,a.jsx)(t.code,{children:"Object"}),", accessed through ",(0,a.jsx)(t.code,{children:"newContact.__proto__.__proto__;"}),"."]}),"\n",(0,a.jsxs)(t.li,{children:["The red underline highlights the ",(0,a.jsx)(t.code,{children:"Object.prototype.hasOwnProperty()"})," method."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"This image shows newContact expanded in the DevTools console and the two __proto__ properties that need to be accessed to get to Object.prototype.hasOwnProperty().",src:o(30526).A+"",width:"499",height:"391"})}),"\n",(0,a.jsxs)(t.p,{children:["Well, so much for the syntactic sugar of a ",(0,a.jsx)(t.code,{children:"for...in"})," loop. While we can verify that properties actually belong to objects, it's probably just better to iterate using ",(0,a.jsx)(t.code,{children:"Object.keys()"})," instead. In fact, the Mozilla documentation mostly recommends ",(0,a.jsx)(t.code,{children:"for...in"})," loops for debugging. Check out the ",(0,a.jsxs)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in",children:["documentation on ",(0,a.jsx)(t.code,{children:"for...in"})]})," for more information."]}),"\n",(0,a.jsxs)(t.p,{children:["However, this dive into ",(0,a.jsx)(t.code,{children:"for...in"})," hopefully provides a good reminder about how prototypal inheritance works. If you are feeling especially brave, you might even want to read more about ",(0,a.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain",children:"Inheritance and the prototype chain"}),". At this point, it's enough to have a very basic understanding of how JavaScript objects inherit from other objects."]}),"\n",(0,a.jsx)(t.p,{children:"In this lesson, we've learned a few ways to iterate over properties in an object. We've also reviewed how prototypal inheritance works, a key and often very confusing topic for developers. In the next lesson, we'll use what we've learned to actually loop through the contacts in our address book application."})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},74845:(e,t,o)=>{o.d(t,{A:()=>n});const n=o.p+"assets/images/contact-properties-2214e06a259b898a62283691117fb48d.png"}}]);