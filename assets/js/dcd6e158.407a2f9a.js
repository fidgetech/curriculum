"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[45647],{28453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>i});var n=s(96540);const a={},r=n.createContext(a);function o(e){const t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(r.Provider,{value:t},e.children)}},98654:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>h,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"capstone/capstone-week-1/breadth-first-algorithms","title":"\ud83d\udcd3 Breadth First Algorithms","description":"In the last lesson, we used a depth-first algorithm to determine if a target node in our friendship network is reachable from a starting node. In this lesson, we\'ll test and write a Graph.prototype.breadthFirstReachable() method. This method will do the exact same thing as our Graph.prototype.depthFirstReachable() method. The only difference is how the method will work. Instead of using a depth-first search, the method will use a breadth-first search.","source":"@site/versioned_docs/version-WIP/capstone/1_capstone-week-1/breadth-first-algorithms.md","sourceDirName":"capstone/1_capstone-week-1","slug":"/capstone/capstone-week-1/breadth-first-algorithms","permalink":"/WIP/capstone/capstone-week-1/breadth-first-algorithms","draft":false,"unlisted":false,"tags":[],"version":"WIP","sidebarPosition":24,"frontMatter":{"title":"\ud83d\udcd3 Breadth First Algorithms","id":"breadth-first-algorithms","slug":"breadth-first-algorithms","hide_table_of_contents":true,"sidebar_position":24,"day":"tuesday","type":"lesson","url":"https://github.com/epicodus-curriculum/capstone/blob/main/8_breadth_first_algorithm.md"},"sidebar":"capstone","previous":{"title":"\ud83d\udcd3 Depth First Algorithms","permalink":"/WIP/capstone/capstone-week-1/depth-first-algorithms"},"next":{"title":"\u270f\ufe0f Graph Theory Practice","permalink":"/WIP/capstone/capstone-week-1/graph-theory-practice"}}');var a=s(74848),r=s(28453);const o={title:"\ud83d\udcd3 Breadth First Algorithms",id:"breadth-first-algorithms",slug:"breadth-first-algorithms",hide_table_of_contents:!0,sidebar_position:24,day:"tuesday",type:"lesson",url:"https://github.com/epicodus-curriculum/capstone/blob/main/8_breadth_first_algorithm.md"},i=void 0,h={},d=[];function l(e){const t={code:"code",div:"div",em:"em",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["In the last lesson, we used a depth-first algorithm to determine if a target node in our friendship network is reachable from a starting node. In this lesson, we'll test and write a ",(0,a.jsx)(t.code,{children:"Graph.prototype.breadthFirstReachable()"})," method. This method will do the exact same thing as our ",(0,a.jsx)(t.code,{children:"Graph.prototype.depthFirstReachable()"})," method. The only difference is how the method will work. Instead of using a depth-first search, the method will use a breadth-first search."]}),"\n",(0,a.jsxs)(t.p,{children:["This will feel a little bit different than our usual TDD process because we will use the exact same tests that we used in the last lesson. In other words, our tests are already written for us! Go ahead a create a ",(0,a.jsx)(t.code,{children:"bfs.test.js"})," file in ",(0,a.jsx)(t.code,{children:"__tests__"})," with the exact same tests that are in the ",(0,a.jsx)(t.code,{children:"dfs.test.js"})," file. Then update the name of the ",(0,a.jsx)(t.code,{children:"Graph.prototype.depthFirstReachable()"})," method to ",(0,a.jsx)(t.code,{children:"Graph.prototype.breadthFirstReachable()"}),". Our goal here is just to verify that everything in our method works correctly as we won't get tests passing one at a time. That's because the method itself is extremely similar to the one we wrote in the last lesson."]}),"\n",(0,a.jsx)(t.p,{children:"The only difference is that we'll use a queue instead of a stack. That means each time we add new nodes to traverse, they will go to the end of the queue instead of the top of the stack. We will still evaluate the first element in the collection \u2014 but because it's a queue (and new items are being pushed to the end of the queue), this will be first-in, first-out (FIFO) instead of last-in, first-out (LIFO)."}),"\n",(0,a.jsx)(t.p,{children:"Here's the full updated method:"}),"\n",(0,a.jsx)(t.div,{className:"filename",children:"src/bfs.js"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"breadthFirstReachable(startingNode, targetNode) {\n    if ((!this.adjacencyList.has(startingNode)) || (!this.adjacencyList.has(targetNode))) {\n      return false;\n    }\n    let queue = [startingNode];\n    let traversedNodes = new Set();\n    while (queue.length) {\n      const currentNode = queue.shift();\n      if (currentNode === targetNode) {\n        return true;\n      } else {\n        traversedNodes.add(currentNode);\n        const adjacencyList = this.adjacencyList.get(currentNode);\n        adjacencyList.forEach(function(node) {\n          if (!traversedNodes.has(node)) {\n            queue.push(node);\n          }\n        });\n      }\n    }\n    return false;\n  }\n"})}),"\n",(0,a.jsx)(t.p,{children:"The first three lines in the method look exactly the same as our previous method:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"if ((!this.adjacencyList.has(startingNode)) || (!this.adjacencyList.has(targetNode))) {\n  return false;\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This just ensures that both the ",(0,a.jsx)(t.code,{children:"startingNode"})," and the ",(0,a.jsx)(t.code,{children:"targetNode"})," exist in the graph and will get our first two tests passing. Once again, we don't want the overhead of doing a search algorithm if we can quickly determine whether a node exists in the list or not (which has O(1) time)."]}),"\n",(0,a.jsx)(t.p,{children:"Now let's take a look at the very subtle difference between DFS and BFS:"}),"\n",(0,a.jsx)(t.div,{className:"filename",children:"src/bfs.js"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"...\n  let queue = [startingNode];\n  let traversedNodes = new Set();\n  while (queue.length) {\n    const currentNode = queue.shift();\n    if (currentNode === targetNode) {\n      return true;\n    } else {\n      traversedNodes.add(currentNode);\n      const adjacencyList = this.adjacencyList.get(currentNode);\n      adjacencyList.forEach(function(node) {\n        if (!traversedNodes.has(node)) {\n          queue.push(node);\n        }\n      });\n    }\n  }\n  return false;\n}\n...\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Other than the fact that we changed the name of our collection from ",(0,a.jsx)(t.code,{children:"stack"})," to ",(0,a.jsx)(t.code,{children:"queue"}),", there is only one small change in the method. Can you find it?"]}),"\n",(0,a.jsx)(t.p,{children:"The only difference is inside our inner loop when we do the following:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"queue.push(node);\n"})}),"\n",(0,a.jsx)(t.p,{children:"Meanwhile, in the last lesson, we did the following instead:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"stack.unshift(node);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["In both algorithms, we always traverse the first element in the collection each iteration through the loop. The difference is that when we add new elements to the queue, they go to the ",(0,a.jsx)(t.em,{children:"end"})," of the collection, which means they will be traversed last (a breadth-first search). Meanwhile, with the stack, they go to the ",(0,a.jsx)(t.em,{children:"beginning"})," of the collection, when means they will be traversed first (a depth-first search)."]}),"\n",(0,a.jsx)(t.p,{children:"That is really the only difference between a DFS and a BFS. Despite that fact, the order at which items are traversed can make a huge impact on the overall efficiency of an algorithm. For instance, if we knew there was a high probability that a node is a friend or a friend of a friend, we probably won't want to do a DFS. Instead, we could just use a BFS to first check all friends and then check all friends of friends."}),"\n",(0,a.jsx)(t.p,{children:"It may seem hard to believe that such a small change has such a big difference on how we'd search a graph. However, it does. If we implement a queue, it's the equivalent of saying \"let's completely take a look at everything on this level before we go to the next level\". Meanwhile, if we implement a stack, it's the equivalent of saying, \"hang on, I'm going to completely explore everything in this branch before going to the next one.\""}),"\n",(0,a.jsx)(t.p,{children:"Now that we've learned the basics of DFS and BFS, we're well on our way to having a basic understanding of graphs and how we can traverse them. We also have some new problem-solving tools to work with. In addition to our knowledge of two new algorithms (DFS and BFS), we can also see how we can use queues and stacks, two different data structures, to solve different kinds of problems. Whether that is using JavaScript's event loop or writing an algorithm, these data structures are absolutely essential."})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);