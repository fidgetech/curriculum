"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[82577],{19080:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-10-configuring-webpack-and-using-npm-scripts","title":"\ud83d\udcd3 2.2.0.10 Configuring webpack and Using npm Scripts","description":"Before we get started with configuring webpack, let\'s take a look at our shape tracker application so far. It should have the following:","source":"@site/versioned_docs/version-WIP/2_intermediate-javascript/2_test-driven-development-and-environments-with-javascript/2-2-0-10-configuring-webpack-and-using-npm-scripts.md","sourceDirName":"2_intermediate-javascript/2_test-driven-development-and-environments-with-javascript","slug":"/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-10-configuring-webpack-and-using-npm-scripts","permalink":"/WIP/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-10-configuring-webpack-and-using-npm-scripts","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 2.2.0.10 Configuring webpack and Using npm Scripts","day":"weekend","id":"2-2-0-10-configuring-webpack-and-using-npm-scripts","hide_table_of_contents":true},"sidebar":"intermediate-javascript","previous":{"title":"\ud83d\udcd3 2.2.0.9 Introduction to webpack","permalink":"/WIP/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-9-introduction-to-webpack"},"next":{"title":"\ud83d\udcd3 2.2.0.11 ES6 Imports and Exports","permalink":"/WIP/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-11-es6-imports-and-exports"}}');var s=i(74848),o=i(28453);const a={title:"\ud83d\udcd3 2.2.0.10 Configuring webpack and Using npm Scripts",day:"weekend",id:"2-2-0-10-configuring-webpack-and-using-npm-scripts",hide_table_of_contents:!0},r=void 0,c={},d=[{value:"Creating an npm Script",id:"creating-an-npm-script",level:2},{value:"Bundling JavaScript with webpack",id:"bundling-javascript-with-webpack",level:2},{value:"Development and Production Modes",id:"development-and-production-modes",level:3},{value:"Configuring webpack",id:"configuring-webpack",level:2}];function l(e){const n={code:"code",div:"div",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Before we get started with configuring webpack, let's take a look at our shape tracker application so far. It should have the following:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The basic project files of html, JS, and CSS."}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:".gitignore"})," file."]}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"package.json"}),", ",(0,s.jsx)(n.code,{children:"package-lock.json"}),", and ",(0,s.jsx)(n.code,{children:"node_modules"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"package.json"})," should show two dev dependencies installed: webpack and webpack-cli."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If you haven't already created a repo on GitHub, do so now and push your local project to your remote repo."}),"\n",(0,s.jsxs)(n.p,{children:["Then, follow along with this lesson to create an npm script and ",(0,s.jsx)(n.code,{children:"webpack.config.js"})," file in your project."]}),"\n",(0,s.jsx)(n.h2,{id:"creating-an-npm-script",children:"Creating an npm Script"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["Remember that ",(0,s.jsx)(n.code,{children:'"scripts"'})," field in our ",(0,s.jsx)(n.code,{children:"package.json"}),"? It's time to add our first script. npm scripts let us use the ",(0,s.jsx)(n.code,{children:"npm run [NAME-OF-SCRIPT]"})," command to run routine processes related to development. In many cases, we'll create a script that calls on a package that's been downloaded to our project."]}),"\n",(0,s.jsxs)(n.p,{children:["Since we're using webpack to build our applications, we'll write a ",(0,s.jsx)(n.code,{children:"build"})," script. What does it mean to build our code? Generally speaking, building a project's code means to compile it so that it is prepared to run. With webpack, it specifically means to take all the different files in our ",(0,s.jsx)(n.code,{children:"src"})," directory, which are easy for humans to read and organize, and then bundle them into a single file that's much leaner and more efficient for browsers."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's get rid of the ",(0,s.jsx)(n.code,{children:"test"})," script for now (we'll add one back later when we start writing tests). The ",(0,s.jsx)(n.code,{children:"scripts"})," section of our ",(0,s.jsx)(n.code,{children:"package.json"})," file should look like this:"]}),"\n",(0,s.jsx)(n.div,{className:"filename",children:"package.json"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'...\n\n"scripts": {\n    "build": "webpack"\n  },\n...\n'})}),"\n",(0,s.jsx)(n.h2,{id:"bundling-javascript-with-webpack",children:"Bundling JavaScript with webpack"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["Now that we have a ",(0,s.jsx)(n.code,{children:'"build"'})," script defined, we can invoke it in our terminal:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"$ npm run build\n"})}),"\n",(0,s.jsx)(n.p,{children:"What this npm script does is find webpack amongst our project's dependencies, and then run webpack so it bundles our code."}),"\n",(0,s.jsx)(n.p,{children:"When we do this, we should get output similar to what follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"$ npm run build\n\n> shape-tracker@1.0.0 build\n> webpack\n\nHash: eefb8d2c5f73122ea6b3\nVersion: webpack 4.46.0\nTime: 338ms\nBuilt at: 06/01/2022 7:44:46 PM\n  Asset      Size  Chunks             Chunk Names\nmain.js  1.31 KiB       0  [emitted]  main\nEntrypoint main = main.js\n[0] ./src/index.js 677 bytes {0} [built]\n\nWARNING in configuration\nThe 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.\nYou can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This output contains information about webpack's bundling process, including what files it has found to bundle (in this case just ",(0,s.jsx)(n.code,{children:"./src/index.js"}),"), and the name of the bundle it has created (",(0,s.jsx)(n.code,{children:"main.js"}),"). If we look in our project's file tree, we'll see a new folder called ",(0,s.jsx)(n.code,{children:"dist"})," with a file inside called ",(0,s.jsx)(n.code,{children:"main.js"}),". And if we look inside ",(0,s.jsx)(n.code,{children:"main.js"}),", we'll see minified JavaScript! This is the essence of what webpack does: bundle and optimize code."]}),"\n",(0,s.jsxs)(n.p,{children:["Stop and take a look at the minified JavaScript in ",(0,s.jsx)(n.code,{children:"main.js"})," now \u2014 we'll be comparing it to other code in just a second."]}),"\n",(0,s.jsxs)(n.p,{children:["You might be thinking, great, this is webpack at work \u2014 so what? Well, what's notable about this is that webpack will bundle our JavaScript without any configuration as long as we have one JS file called ",(0,s.jsx)(n.code,{children:"index.js"}),". That's because without a configuration file, webpack assumes our project's entry point is called ",(0,s.jsx)(n.code,{children:"index.js"})," and the bundled code should be output to ",(0,s.jsx)(n.code,{children:"dist/main.js"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["However, webpack has just bundled one single file in our project \u2014 ",(0,s.jsx)(n.code,{children:"index.js"}),", but not ",(0,s.jsx)(n.code,{children:"triangle.js"}),", and that's just not going to cut it for us. So, if we want webpack to include all of our JS files, and other dependencies, we're going to have to configure webpack and learn a new way of connecting files to each other."]}),"\n",(0,s.jsx)(n.p,{children:"As for the warning, let's resolve that next."}),"\n",(0,s.jsx)(n.h3,{id:"development-and-production-modes",children:"Development and Production Modes"}),"\n",(0,s.jsxs)(n.p,{children:["The warning message is decently clear: we need to set whether we're building our code for development or production. We can set the mode by altering the npm script for ",(0,s.jsx)(n.code,{children:'"build"'})," in ",(0,s.jsx)(n.code,{children:'"scripts"'}),":"]}),"\n",(0,s.jsx)(n.div,{className:"filename",children:"package.json"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'  "scripts": {\n    "build": "webpack --mode=development"\n  },\n'})}),"\n",(0,s.jsxs)(n.p,{children:["As we can see, the ",(0,s.jsx)(n.code,{children:"--mode"})," flag lets us specify a development environment. We could instead set ",(0,s.jsx)(n.code,{children:"--mode=production"})," to specify a production environment, but we're in development, so we don't want that right now."]}),"\n",(0,s.jsxs)(n.p,{children:["However, setting webpack to bundle code in development mode changes how webpack bundles our code. Let's see how this works. Run ",(0,s.jsx)(n.code,{children:"$ npm run build"})," again in the command line. Now there's no warning and that's because we've set a value for mode."]}),"\n",(0,s.jsxs)(n.p,{children:["Next, look inside ",(0,s.jsx)(n.code,{children:"dist/main.js"})," \u2014 the bundled JavaScript now looks radically different! It has NOT been minified. Well, minification provides optimization benefits for production websites but it's not a priority for development, because we want to be able to look inside the bundle and debug it if necessary."]}),"\n",(0,s.jsx)(n.p,{children:"In the coming lessons, we'll revisit the topic of production versus development code."}),"\n",(0,s.jsx)(n.h2,{id:"configuring-webpack",children:"Configuring webpack"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["We configure webpack through a configuration file. This file should go in the top level (or 'root') of our project directory. In order for webpack to find this configuration file, it must be named ",(0,s.jsx)(n.code,{children:"webpack.config.js"}),". Let's create it now."]}),"\n",(0,s.jsxs)(n.p,{children:["First create a new file called ",(0,s.jsx)(n.code,{children:"webpack.config.js"})," in the root of the Shape Tracker directory. With this addition, your Shape Tracker project structure should look like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"shape-tracker/\n\u251c\u2500\u2500 dist\n\u2502\xa0\xa0 \u2514\u2500\u2500 main.js\n\u251c\u2500\u2500 node_modules\n\u251c\u2500\u2500 index.html\n\u251c\u2500\u2500 src\n\u2502\xa0\xa0 \u251c\u2500\u2500 index.js\n\u2502\xa0\xa0 \u2514\u2500\u2500 triangle.js\n\u251c\u2500\u2500 css\n\u2502   \u2514\u2500\u2500 styles.css\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 package-lock.json\n\u251c\u2500\u2500 package.json\n\u2514\u2500\u2500 webpack.config.js\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Then, add the following contents to ",(0,s.jsx)(n.code,{children:"webpack.config.js"}),":"]}),"\n",(0,s.jsx)(n.div,{className:"filename",children:"webpack.config.js"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const path = require('path');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist')\n  }\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This is a very basic configuration, and we'll continue to add to it in coming lessons. The syntax may seem confusing at first, but we can break this down a bit. For instance, we can see that ",(0,s.jsx)(n.code,{children:"module.exports"})," is a property that holds an object with key-value pairs. When we come across code that looks different, don't forget that we can always apply our basic understanding of JavaScript to make it a bit less overwhelming."]}),"\n",(0,s.jsxs)(n.p,{children:["When webpack creates the bundled code, it will use the instructions in ",(0,s.jsx)(n.code,{children:"webpack.config.js"})," to do so. This is just like how npm uses the instructions in ",(0,s.jsx)(n.code,{children:"package.json"})," to install a project's dependencies."]}),"\n",(0,s.jsx)(n.p,{children:"Let's go over the main points of this new code:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Anything webpack requires to run goes at the top of our configuration file. For now, we only have ",(0,s.jsx)(n.code,{children:"require('path')"}),", which we add to configure the path where our output files will be saved. We save this in a ",(0,s.jsx)(n.code,{children:"const"})," variable. We'll soon be adding more ",(0,s.jsx)(n.code,{children:"require"})," statements, which we will cover further in the next lesson."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["We specify an ",(0,s.jsx)(n.strong,{children:"entry point"}),". This is the JS file where webpack will enter our application and then use a dependency graph to load all other required JS files. That just means webpack is going to gather all the files that our entry point depends on, then gather all the files that those files depend on, and so on \u2014 until all the dependencies have been gathered. As we can see, webpack will enter through the file where we store our user interface logic: ",(0,s.jsx)(n.code,{children:"'./src/index.js'"}),". The file name ",(0,s.jsx)(n.code,{children:"index.js"})," is a default entry point for webpack."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["We also specify an ",(0,s.jsx)(n.strong,{children:"output"}),". This is where all our code will go after it's been processed and bundled. Instead of relying on the default file name of ",(0,s.jsx)(n.code,{children:"main.js"}),", we'll use ",(0,s.jsx)(n.code,{children:"bundle.js"}),".  Every time we run ",(0,s.jsx)(n.code,{children:"$ npm run build"}),", webpack will follow the instructions in ",(0,s.jsx)(n.code,{children:"webpack.config.js"})," and create a ",(0,s.jsx)(n.code,{children:"dist/bundle.js"})," file."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Note that we only have access to ",(0,s.jsx)(n.code,{children:"path.resolve()"})," because we required it at the top of our configuration file. ",(0,s.jsx)(n.code,{children:"path"})," is a part of webpack's internal tooling."]}),"\n",(0,s.jsxs)(n.p,{children:["In short, the instructions above tell webpack to go into our entry point file ",(0,s.jsx)(n.code,{children:"src/index.js"}),', gather all its dependencies (and its dependencies\' dependencies...), "webpackify" them (concatenate them into one file), call the concatenated file ',(0,s.jsx)(n.code,{children:"bundle.js"})," and store them in the ",(0,s.jsx)(n.code,{children:"dist"})," directory."]}),"\n",(0,s.jsxs)(n.p,{children:["Now that we have a very basic configuration file in place, we're almost ready to process and concatenate some JavaScript code. Next, we need to learn about ",(0,s.jsx)(n.code,{children:"import"})," and ",(0,s.jsx)(n.code,{children:"export"})," statements in order to connect our files together."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>r});var t=i(96540);const s={},o=t.createContext(s);function a(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);