"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[50668],{28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>s});var o=t(96540);const a={},i=o.createContext(a);function c(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),o.createElement(i.Provider,{value:n},e.children)}},96761:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>s,default:()=>h,frontMatter:()=>c,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"react/react-fundamentals/4-2-2-3-unidirectional-data-flow","title":"\ud83d\udcd3 4.2.2.3 Unidirectional Data Flow","description":"So far we have only been working with local state. However, when a user inputs data in our form, we somehow need to get that data from our NewTicketForm component to its parent TicketControl component.","source":"@site/versioned_docs/version-v1_3/4_react/2_react-fundamentals/4-2-2-03-unidirectional-data-flow.md","sourceDirName":"4_react/2_react-fundamentals","slug":"/react/react-fundamentals/4-2-2-3-unidirectional-data-flow","permalink":"/v1.3/react/react-fundamentals/4-2-2-3-unidirectional-data-flow","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 4.2.2.3 Unidirectional Data Flow","day":"tuesday","id":"4-2-2-3-unidirectional-data-flow","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 4.2.2.2 Adding a Form","permalink":"/v1.3/react/react-fundamentals/4-2-2-2-adding-a-form"},"next":{"title":"\ud83d\udcd3 4.2.2.4 Passing Data Via Callbacks","permalink":"/v1.3/react/react-fundamentals/4-2-2-4-passing-data-via-callbacks"}}');var a=t(74848),i=t(28453);const c={title:"\ud83d\udcd3 4.2.2.3 Unidirectional Data Flow",day:"tuesday",id:"4-2-2-3-unidirectional-data-flow",hide_table_of_contents:!0},s=void 0,r={},l=[];function d(e){const n={code:"code",em:"em",li:"li",ol:"ol",p:"p",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["So far we have only been working with local state. However, when a user inputs data in our form, we somehow need to get that data from our ",(0,a.jsx)(n.code,{children:"NewTicketForm"})," component to its parent ",(0,a.jsx)(n.code,{children:"TicketControl"})," component."]}),"\n",(0,a.jsxs)(n.p,{children:["Before we do that, we need to learn more about ",(0,a.jsx)(n.strong,{children:"unidirectional data flow"}),". Unidirectional data flow is a language-agnostic term for applications that have data flowing in only one direction."]}),"\n",(0,a.jsxs)(n.p,{children:["In the case of React applications, data can only flow from a parent component ",(0,a.jsx)(n.em,{children:"down"})," to a child component. That's why shared state should always be lifted to a common ancestor. Only child components will ever be able to access that state. Components that are higher up the component tree (above a component with state) have no way to know about that state because of unidirectional data flow. In fact, components in React are so modular that they don't even know their parents exist. It's the job of parent components to keep track of their children, not the other way around."]}),"\n",(0,a.jsxs)(n.p,{children:["The same is true with props. We can only pass props ",(0,a.jsx)(n.em,{children:"down"})," from a parent component to a child component. That's the whole point of unidirectional data flow. It may seem like a limiting concept, but it makes planning, building, and debugging an application much easier. If state and props could flow in every direction, our applications would quickly become a mess."]}),"\n",(0,a.jsxs)(n.p,{children:["So if data can only be passed ",(0,a.jsx)(n.em,{children:"down"}),", then how can we get information from a child component up to a parent component?"]}),"\n",(0,a.jsxs)(n.p,{children:["The answer: we need to use ",(0,a.jsx)(n.strong,{children:"callbacks"}),". Here's how it works:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"We define a function in a parent component that has state."}),"\n",(0,a.jsx)(n.li,{children:"The parent component passes this function into the child component as a prop. Functions can be props just like any other data type."}),"\n",(0,a.jsx)(n.li,{children:"We call this function in our child component, passing data as an argument."}),"\n",(0,a.jsx)(n.li,{children:"When the child calls this function, the function in the parent component is invoked. Because the function lives in the parent component, the parent can access any data that's passed into it."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This may feel like we're breaking the rules of unidirectional data flow because the parent component can access information from the function call in the child component."}),"\n",(0,a.jsxs)(n.p,{children:["However, that's not the case. The parent component passes props ",(0,a.jsx)(n.em,{children:"down"})," using unidirectional data flow. If a function is passed downward as a prop, the parent can still access it when it's called."]}),"\n",(0,a.jsx)(n.p,{children:"Understandably, this concept can be confusing at first. Let's make it more concrete by describing how we will do this in our Help Queue application. We'll do the following:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["First, we will create a function called ",(0,a.jsx)(n.code,{children:"handleAddingNewTicketToList"})," in the parent ",(0,a.jsx)(n.code,{children:"TicketControl"})," component."]}),"\n",(0,a.jsxs)(n.li,{children:["Next, we'll pass this function to its child ",(0,a.jsx)(n.code,{children:"NewTicketForm"})," component as a prop called ",(0,a.jsx)(n.code,{children:"onNewTicketCreation"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Our child ",(0,a.jsx)(n.code,{children:"NewTicketForm"})," component has a function called ",(0,a.jsx)(n.code,{children:"handleNewTicketFormSubmission"})," which correctly gathers user inputs from a form. We will call ",(0,a.jsx)(n.code,{children:"onNewTicketCreation"})," inside ",(0,a.jsx)(n.code,{children:"handleNewTicketFormSubmission"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Form data will be passed into ",(0,a.jsx)(n.code,{children:"onNewTicketCreation"})," as an argument."]}),"\n",(0,a.jsxs)(n.li,{children:["The parent ",(0,a.jsx)(n.code,{children:"TicketControl"})," component will receive that data and use it to add a new ticket to our ",(0,a.jsx)(n.code,{children:"mainTicketList"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Now that we've covered unidirectional data flow, we're ready to implement this new functionality. Don't worry if it still doesn't make sense. This is a new and complex concept for React beginners \u2014 the best way to learn and internalize how this works is to actually write the code \u2014 and then continue to practice working with unidirectional data flow until the underlying concepts begin to click."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);