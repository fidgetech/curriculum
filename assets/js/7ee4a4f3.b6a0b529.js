"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[67482],{25995:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/go_left_then_right-dcae11df90bb823b2654296ca9a32ee0.png"},28453:(e,t,n)=>{n.d(t,{R:()=>d,x:()=>i});var o=n(96540);const r={},s=o.createContext(r);function d(e){const t=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),o.createElement(s.Provider,{value:t},e.children)}},47353:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/go_left_twice-787695286a5203586784a37df0d2d1c1.png"},72622:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>i,default:()=>c,frontMatter:()=>d,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"capstone/capstone-week-1/binary-search-trees-part-1","title":"\ud83d\udcd3 Binary Search Trees Part 1","description":"In the last lesson, we learned about binary tree and binary search tree data structures. Over the next several lessons, we\'ll build an application that creates a binary search tree from scratch. We\'ll also learn how to search this BSTs in the process.","source":"@site/docs/capstone/1_capstone-week-1/binary-search-trees-part-1.md","sourceDirName":"capstone/1_capstone-week-1","slug":"/capstone/capstone-week-1/binary-search-trees-part-1","permalink":"/v1.2/capstone/capstone-week-1/binary-search-trees-part-1","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":13,"frontMatter":{"title":"\ud83d\udcd3 Binary Search Trees Part 1","id":"binary-search-trees-part-1","slug":"binary-search-trees-part-1","hide_table_of_contents":true,"sidebar_position":13,"day":"monday","type":"lesson","url":"https://github.com/epicodus-curriculum/capstone/blob/main/3_binary_search_trees_part_1.md"},"sidebar":"capstone","previous":{"title":"\ud83d\udcd3 Binary Search Trees Introduction","permalink":"/v1.2/capstone/capstone-week-1/binary-search-trees-introduction"},"next":{"title":"\ud83d\udcd3 Binary Search Trees Part 2","permalink":"/v1.2/capstone/capstone-week-1/binary-search-trees-part-2"}}');var r=n(74848),s=n(28453);const d={title:"\ud83d\udcd3 Binary Search Trees Part 1",id:"binary-search-trees-part-1",slug:"binary-search-trees-part-1",hide_table_of_contents:!0,sidebar_position:13,day:"monday",type:"lesson",url:"https://github.com/epicodus-curriculum/capstone/blob/main/3_binary_search_trees_part_1.md"},i=void 0,a={},l=[{value:"Creating a Node",id:"creating-a-node",level:2},{value:"Adding a Root Node to a Binary Search Tree",id:"adding-a-root-node-to-a-binary-search-tree",level:2},{value:"Inserting a Node",id:"inserting-a-node",level:3},{value:"Inserting a Node Less Than the Root",id:"inserting-a-node-less-than-the-root",level:3},{value:"Inserting a Node Greater Than the Root",id:"inserting-a-node-greater-than-the-root",level:3},{value:"Adding A Node to a Child Node (Left Side)",id:"adding-a-node-to-a-child-node-left-side",level:3},{value:"First Insertion: <code>bst.insertNode(rootNode);</code>",id:"first-insertion-bstinsertnoderootnode",level:4},{value:"Second Insertion: <code>bst.insertNode(node2);</code>",id:"second-insertion-bstinsertnodenode2",level:4},{value:"Third Insertion: <code>bst.insertNode(node3);</code>",id:"third-insertion-bstinsertnodenode3",level:4},{value:"Adding A Node to a Child Node (Right Side)",id:"adding-a-node-to-a-child-node-right-side",level:3},{value:"Verifying the Code Works for Both Sides",id:"verifying-the-code-works-for-both-sides",level:3},{value:"Handling Duplicate Values",id:"handling-duplicate-values",level:3}];function h(e){const t={a:"a",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"In the last lesson, we learned about binary tree and binary search tree data structures. Over the next several lessons, we'll build an application that creates a binary search tree from scratch. We'll also learn how to search this BSTs in the process."}),"\n",(0,r.jsxs)(t.p,{children:["To get started, use the basic testing structure described in the ",(0,r.jsx)(t.a,{href:"/capstone/capstone-week-1/computer-science-testing-environment-setup",children:"Computer Science Testing Environment"})," lesson."]}),"\n",(0,r.jsx)(t.h2,{id:"creating-a-node",children:"Creating a Node"}),"\n",(0,r.jsx)(t.p,{children:"We'll use a TDD approach, which means we'll start by writing a test for the smallest possible behavior. Just as a block tower is made of building blocks, our binary search tree is made of nodes. And just as we can't build a tower without blocks, we need to start with nodes before we can even think about building a binary search tree."}),"\n",(0,r.jsxs)(t.p,{children:["We'll start by writing a constructor for a node object. We'll call this object ",(0,r.jsx)(t.code,{children:"BSTNode"}),". We could call it something even simpler like ",(0,r.jsx)(t.code,{children:"Node"})," but we don't want to mix things up with Node.js."]}),"\n",(0,r.jsxs)(t.p,{children:["Before we write a test for the constructor, we need to think about what a node needs to know. First, it will have to have a key (which we'll call ",(0,r.jsx)(t.code,{children:"data"}),"). That key will be a numerical value. This key will be used to determine where a node should go in a binary search tree."]}),"\n",(0,r.jsxs)(t.p,{children:["Create a file in ",(0,r.jsx)(t.code,{children:"__tests__"})," called ",(0,r.jsx)(t.code,{children:"bst-node.test.js"}),". Here's our first test:"]}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"__tests__/bst-node.test.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"import BSTNode from '../src/bst-node.js';\n\ndescribe('bstNode', () => {\n\n  test('should correctly create a node', () => {\n    const node = new BSTNode(36);\n    expect(node.data).toEqual(36);\n  });\n});\n"})}),"\n",(0,r.jsx)(t.p,{children:"Next, let's get this test passing."}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"src/bst-node.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"export default class BSTNode {\n  constructor(data) {\n    this.data = data;\n  }\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"Once we add this code, our first test will be passing. However, we'll need to update our test and constructor in just a moment. As of now, there's something missing from a node. Can you guess what it is?"}),"\n",(0,r.jsxs)(t.p,{children:["Here's a hint. Remember that trees are a way to store ",(0,r.jsx)(t.em,{children:"relationships between different nodes"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Here's another hint. ",(0,r.jsx)(t.em,{children:"A parent node should know about its children. However, a child node doesn't need to know about its parent."})]}),"\n",(0,r.jsxs)(t.p,{children:["Since we know that every parent node can have at most two child nodes and that one is on the left side and the other is on the right, we can store this relationship by adding two more properties to a node: ",(0,r.jsx)(t.code,{children:"left"})," and ",(0,r.jsx)(t.code,{children:"right"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"Let's update our test:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"__tests__/bst-node.test.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"import BSTNode from '../src/bst-node.js';\n\ndescribe('bstNode', () => {\n\n  test('should correctly create a node', () => {\n    const node = new BSTNode(36);\n    expect(node.data).toEqual(36);\n    expect(node.left).toEqual(null);\n    expect(node.right).toEqual(null);\n  });\n});\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Note that these properties will both be ",(0,r.jsx)(t.code,{children:"null"})," to start. When a node has ",(0,r.jsx)(t.code,{children:"left"})," and ",(0,r.jsx)(t.code,{children:"right"})," properties that are ",(0,r.jsx)(t.code,{children:"null"}),", that means it has no children. Later, as our application adds child nodes, it will update the ",(0,r.jsx)(t.code,{children:"left"})," and ",(0,r.jsx)(t.code,{children:"right"})," properties of parent nodes as needed."]}),"\n",(0,r.jsx)(t.p,{children:"Let's update our source code to get our test passing:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"src/bst-node.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"export default class BSTNode {\n  constructor(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n  }\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"So now our application can create a basic node. The building blocks of a binary search tree are in place. We're ready to start building out our binary search tree creator."}),"\n",(0,r.jsx)(t.h2,{id:"adding-a-root-node-to-a-binary-search-tree",children:"Adding a Root Node to a Binary Search Tree"}),"\n",(0,r.jsxs)(t.p,{children:["Let's take a moment to think about the smallest behavior we can implement for a binary search tree creator. What does a binary search tree ",(0,r.jsx)(t.em,{children:"need"})," to have?"]}),"\n",(0,r.jsxs)(t.p,{children:["If you guessed a root node, you are correct. We are going to need to sort our binary search tree so that values that are ",(0,r.jsx)(t.em,{children:"less than"})," the root node go on the left-hand side while values that are ",(0,r.jsx)(t.em,{children:"greater than"})," the root node go on the right side. Without a starting root node, we have no way to sort our binary search tree."]}),"\n",(0,r.jsxs)(t.p,{children:["Our binary search tree won't automatically come with a root node, though \u2014 we have to add our own. So what should the initial state of our binary search tree be? An object with a ",(0,r.jsx)(t.code,{children:"root"})," of ",(0,r.jsx)(t.code,{children:"null"}),". In other words, an empty binary search tree."]}),"\n",(0,r.jsx)(t.p,{children:"Let's write a test:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"__tests__/bst.test.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"import BST from '../src/bst.js';\n\ndescribe('binarySearchTree', () => {\n\n  test('should initialize a binary search tree with a root of null', () => {\n    let bst = new BST();\n    expect(bst.root).toEqual(null);\n  });\n});\n"})}),"\n",(0,r.jsx)(t.p,{children:"Getting this test passing is very simple:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"src/bst.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"export default class BST {\n  constructor() {\n    this.root = null;\n  }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"inserting-a-node",children:"Inserting a Node"}),"\n",(0,r.jsx)(t.p,{children:"So now we have a way of creating a node and a way to create a binary search tree \u2014 but the binary search tree has no nodes. What's the next thing we need to do?"}),"\n",(0,r.jsxs)(t.p,{children:["Well, a tower made of building blocks starts with a single block. And likewise, we need to be able to add a node to a binary search tree. We don't need to think about everything this binary search tree needs to do just yet, though. All we have to do is write a method that inserts a single node. We'll call that method ",(0,r.jsx)(t.code,{children:"BST.prototype.insertNode()"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"It's time for another test:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"__tests__/bst.test.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"...\n// We need to import our BSTNode now.\nimport BSTNode from '../src/bst-node.js';\n\ndescribe('binarySearchTree', () => {\n\n  ...\n\n  test('it should create a new root node', () => {\n    let bst = new BST();\n    let node = new BSTNode(36);\n    bst.insertNode(node);\n    expect(bst.root).toEqual(node);\n  });\n});\n"})}),"\n",(0,r.jsxs)(t.p,{children:["In this test, we create instances of both a new ",(0,r.jsx)(t.code,{children:"BST"})," and a new ",(0,r.jsx)(t.code,{children:"BSTNode"}),". Note the new import statement at the beginning of our tests \u2014 we have to import the ",(0,r.jsx)(t.code,{children:"BSTNode"})," class now. Next, we call ",(0,r.jsx)(t.code,{children:"BST.prototype.insertNode()"})," to insert the instantiated node into the binary search tree. We'll expect the ",(0,r.jsx)(t.code,{children:"root"})," property of our binary search tree to equal the inserted node."]}),"\n",(0,r.jsx)(t.p,{children:"Here's the code to make it pass:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"src/bst.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"export default class BST {\n  constructor() {\n    this.root = null;\n  }\n\n  insertNode(node) {\n    this.root = node;\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["As we can see, we're following the principles of TDD and keeping our code as simple as possible. For now, all we need to do is set ",(0,r.jsx)(t.code,{children:"this.root"})," equal to the inserted node. Adding a root node will always be the first step after we instantiate an empty binary search tree."]}),"\n",(0,r.jsx)(t.h3,{id:"inserting-a-node-less-than-the-root",children:"Inserting a Node Less Than the Root"}),"\n",(0,r.jsxs)(t.p,{children:["Now that we have a root node, that means we have a point of comparison. Next, we need to be able to add a child node. We'll start with a child node that's ",(0,r.jsx)(t.em,{children:"less than"})," the root node."]}),"\n",(0,r.jsxs)(t.p,{children:["But how do we build that relationship? How will our binary search tree ",(0,r.jsx)(t.em,{children:"know"})," how to sort (and search for) other nodes?"]}),"\n",(0,r.jsxs)(t.p,{children:["Well, that's why we added ",(0,r.jsx)(t.code,{children:"left"})," and ",(0,r.jsx)(t.code,{children:"right"})," properties for nodes. If a number is less than the parent node, that means the parent node's ",(0,r.jsx)(t.code,{children:"left"})," property should be updated to be the child node. That sounds more complicated than it is. A test should make it clear."]}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"__tests__/bst.test.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"...\n\ndescribe('binarySearchTree', () => {\n\n  ...\n\n  test('it should add a child node to the right of the root node', () => {\n    let bst = new BST();\n    let rootNode = new BSTNode(36);\n    bst.insertNode(rootNode);\n    let newNode = new BSTNode(22);\n    bst.insertNode(newNode);\n    expect(rootNode.left.data).toEqual(22);\n  });\n});\n"})}),"\n",(0,r.jsxs)(t.p,{children:["These tests aren't very DRY \u2014 you can use a ",(0,r.jsx)(t.code,{children:"beforeEach()"})," block to refactor them. For now, we'll stay focused on building out our application."]}),"\n",(0,r.jsxs)(t.p,{children:["This time, we're inserting two nodes. After inserting the second node, we're expecting the ",(0,r.jsx)(t.code,{children:"data"})," property of ",(0,r.jsx)(t.code,{children:"rootNode.left"})," to be equal to ",(0,r.jsx)(t.code,{children:"22"}),". In other words, the child node will be placed on the left side of the root node because its value is smaller than the root node's value."]}),"\n",(0,r.jsxs)(t.p,{children:["Here's the updated ",(0,r.jsx)(t.code,{children:"BST.prototype.insertNode()"})," method to get this passing:"]}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"src/bst.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"insertNode(node) {\n  if (this.root === null) {\n    this.root = node;\n  } else {\n    this.root.left = node;\n  }  \n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"This is the bare minimum code needed to get this test passing. It will need to be refactored multiple times as we continue to test. The goal of using TDD here isn't just to reinforce good problem-solving habits but also to slowly work through the process of building a binary search tree, deepening our understanding of what is happening."}),"\n",(0,r.jsx)(t.h3,{id:"inserting-a-node-greater-than-the-root",children:"Inserting a Node Greater Than the Root"}),"\n",(0,r.jsx)(t.p,{children:"Next, we need to do the same for adding a child node on the right side of the root node. Here's a test:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"__tests__/bst.test.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"test('it should add a child node to the right of the root node', () => {\n  let bst = new BST();\n  let rootNode = new BSTNode(36);\n  bst.insertNode(rootNode);\n  let newNode = new BSTNode(48);\n  bst.insertNode(newNode);\n  expect(rootNode.right.data).toEqual(48);\n});\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Again, not a very DRY test considering our previous test \u2014 but it does make explicit exactly what we are trying to do. Here's the updated ",(0,r.jsx)(t.code,{children:"BST.prototype.insertNode()"})," method to get the test to pass:"]}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"src/bst.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"insertNode(node) {\n  if (this.root === null) {\n    this.root = node;\n  } else if (this.root.data > node.data) {\n    this.root.left = node;\n  } else if (this.root.data < node.data) {\n    this.root.right = node;\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["We've updated our method to have three conditionals. The second and third conditionals determine whether the node should go to the left or the right of the root node. If the value of the ",(0,r.jsx)(t.code,{children:"data"})," property is greater than the new node's ",(0,r.jsx)(t.code,{children:"data"})," property, the new child node goes on the left side. If the value of the new node's ",(0,r.jsx)(t.code,{children:"data"})," property is greater than the root node's ",(0,r.jsx)(t.code,{children:"data"})," property, it goes on the right side of the root node."]}),"\n",(0,r.jsx)(t.p,{children:"At this point, you should have a basic idea of what's happening in a binary search tree. We can use the general principle above either to add new nodes or to traverse a binary search tree. Whether we are building or traversing, we just need to look at the value of the current node and then determine whether we need to go left or right."}),"\n",(0,r.jsxs)(t.p,{children:["Well, that's the basic principle. If we look at the code we have so far, it's still incomplete. Our method can build a root node with two children and that's it. In order to continue to build our binary search tree, our application needs to traverse ",(0,r.jsx)(t.em,{children:"and"})," construct nodes. It needs to check a node, see whether it needs to go left or right, and then move to the correct node. Then it needs to repeat the process until it finds where the new node should go."]}),"\n",(0,r.jsx)(t.h3,{id:"adding-a-node-to-a-child-node-left-side",children:"Adding A Node to a Child Node (Left Side)"}),"\n",(0,r.jsx)(t.p,{children:"The fact that we need to repeat the process offers a strong clue for what needs to happen next: we need to add either a loop or recursion. Let's write a test first. This test will see if our method can correctly insert a node so that our binary search tree has a height of three. Here's an image of what this would look like if we were first going to insert a child node to the left and then add a node to that child's right:"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"Image of adding a child node to the root node and then adding a node to the child.",src:n(25995).A+"",width:"231",height:"411"})}),"\n",(0,r.jsxs)(t.p,{children:["To recreate the process of what's happening in the image above, we first need to insert a child node to the left of the root node. Then, to create the next node, our method needs to traverse to the child node we just created. Finally, the method needs to insert another child node (we can think of this one as being the \"grandchild\" of the root node) that's to the ",(0,r.jsx)(t.em,{children:"right"})," of its parent node."]}),"\n",(0,r.jsx)(t.p,{children:"This is our eventual goal, anyway. We'll break it down even more with TDD. Let's start by testing that our application can just traverse and go left. Then we'll write an additional test to ensure it can go right. Finally, we'll write a test that depicts what's happening in the image above. Once again, this is a good TDD approach and will also allow us to put our method together slowly so it's really clear what is happening."}),"\n",(0,r.jsx)(t.p,{children:"The image below shows what we'll test first:"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"In the image below, we go left twice.",src:n(47353).A+"",width:"391",height:"401"})}),"\n",(0,r.jsx)(t.p,{children:"As we can see in the image, we need to create a root node, then a child node to the left of the root node, and then a child node to the left of that child node. Here's the test:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"__tests__/bst.test.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"  test('it should add a child to the left of a child node', () => {\n    let bst = new BST();\n    let rootNode = new BSTNode(36);\n    bst.insertNode(rootNode);\n    let node2 = new BSTNode(22);\n    bst.insertNode(node2);\n    let node3 = new BSTNode(11);\n    bst.insertNode(node3);\n    expect(rootNode.left.left.data).toEqual(11);\n  });\n"})}),"\n",(0,r.jsxs)(t.p,{children:["You might wonder why we keep using ",(0,r.jsx)(t.code,{children:"let"}),", especially since we aren't changing any of these objects in the test above. Well, our method ",(0,r.jsx)(t.em,{children:"will"})," be changing a ",(0,r.jsx)(t.code,{children:"BSTNode"}),"'s properties on a regular basis, updating its ",(0,r.jsx)(t.code,{children:"left"})," and ",(0,r.jsx)(t.code,{children:"right"})," properties, so it makes sense that we use ",(0,r.jsx)(t.code,{children:"let"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"Next, here's the code. We have to make quite a few changes for this to work:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"src/bst.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"insertNode(insertedNode) {\n  if (this.root === null) {\n    this.root = insertedNode;\n  } else {\n    let currentNode = this.root;\n    while (true) {\n      if (currentNode.data > insertedNode.data) {\n        if (currentNode.left === null) {\n          currentNode.left = insertedNode;\n          return this;\n        } else {\n          currentNode = currentNode.left;\n        }\n      } else if (currentNode.data < insertedNode.data) {\n        currentNode.right = insertedNode;\n        return this;\n      }\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"Let's walk through the new code line by line."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Note that we've changed the parameter to ",(0,r.jsx)(t.code,{children:"insertedNode"}),". This is to differentiate the node being inserted from the ",(0,r.jsx)(t.code,{children:"currentNode"})," \u2014 the node being traversed. We'll talk about ",(0,r.jsx)(t.code,{children:"currentNode"})," more in a moment."]}),"\n",(0,r.jsxs)(t.li,{children:["We don't need to change our first conditional \u2014 if there's no root node, we just set the node to be equal to ",(0,r.jsx)(t.code,{children:"this.root"}),". So when we insert our first node, it will become ",(0,r.jsx)(t.code,{children:"this.root"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:["Otherwise, we need to either add a child node to the root or traverse further down the tree. We create a new variable called ",(0,r.jsx)(t.code,{children:"currentNode"})," which starts out equal to the value of the root node. If we need to traverse further down the tree, the value of ",(0,r.jsx)(t.code,{children:"currentNode"})," will be updated as needed. When we insert a second node, this will be a child of the root node. However, because no traversal is needed to add a child node to the root node, there's also no need to update ",(0,r.jsx)(t.code,{children:"currentNode"}),". We only need to start thinking about traversal once we are adding children to a root node's children. We'll cover this more in a moment."]}),"\n",(0,r.jsxs)(t.li,{children:["Next, we have a ",(0,r.jsx)(t.code,{children:"while (true)"})," loop. Since true is always true, this loop will run forever unless we use ",(0,r.jsx)(t.code,{children:"break"})," or ",(0,r.jsx)(t.code,{children:"return"})," statements. Obviously, we'll need to be careful to make sure that we don't create any situations where we don't eventually break out of the loop."]}),"\n",(0,r.jsxs)(t.li,{children:["Inside our loop, we have a conditional that will run if ",(0,r.jsx)(t.code,{children:"currentNode.data"})," is greater than ",(0,r.jsx)(t.code,{children:"insertedNode.data"}),". We're setting the stage here. If the node being traversed is greater than the newly inserted node, we're going to need to put the newly inserted node to the left of the traversed node."]}),"\n",(0,r.jsxs)(t.li,{children:["If ",(0,r.jsx)(t.code,{children:"(currentNode.left === null)"}),", we've reached the end of our journey. We can insert the node here. That means we can set ",(0,r.jsx)(t.code,{children:"currentNode.left = insertedNode;"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:["Finally, we'll return ",(0,r.jsx)(t.code,{children:"this"})," \u2014 the binary search tree. We could also just break out of the loop as well with a ",(0,r.jsx)(t.code,{children:"break"})," statement. However, it might be more useful for users if we return the updated tree. The important thing is that once we insert the node, we stop the loop \u2014 otherwise, it will run forever."]}),"\n",(0,r.jsxs)(t.li,{children:["However, if ",(0,r.jsx)(t.code,{children:"currentNode.left"})," isn't equal to ",(0,r.jsx)(t.code,{children:"null"}),", that means there's a node there and we need to traverse down another level. That means we need to update the ",(0,r.jsx)(t.code,{children:"currentNode"})," to node stored in the ",(0,r.jsx)(t.code,{children:"left"})," property of the node being traversed."]}),"\n",(0,r.jsx)(t.li,{children:"We haven't updated the code for the right side of the tree yet other than to update the variable names."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"If we run our tests, they will pass. Let's walk through what our method is doing for each insertion."}),"\n",(0,r.jsxs)(t.h4,{id:"first-insertion-bstinsertnoderootnode",children:["First Insertion: ",(0,r.jsx)(t.code,{children:"bst.insertNode(rootNode);"})]}),"\n",(0,r.jsxs)(t.p,{children:["There is no root node yet so ",(0,r.jsx)(t.code,{children:"this.root"})," is updated to be the root node as shown in the code below."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"if (this.root === null) {\n  this.root = insertedNode;\n}\n"})}),"\n",(0,r.jsxs)(t.h4,{id:"second-insertion-bstinsertnodenode2",children:["Second Insertion: ",(0,r.jsx)(t.code,{children:"bst.insertNode(node2);"})]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"node2"})," has a ",(0,r.jsx)(t.code,{children:"data"})," value of ",(0,r.jsx)(t.code,{children:"22"})," in our test. There is already a root node so we will move along to the code in the ",(0,r.jsx)(t.code,{children:"else"})," statement:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"let currentNode = this.root;\nwhile (true) {\n  if (currentNode.data > insertedNode.data) {\n    if (currentNode.left === null) {\n      currentNode.left = insertedNode;\n      return this;\n    }\n    ...\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"currentNode"})," is the root node which has a ",(0,r.jsx)(t.code,{children:"data"})," value of ",(0,r.jsx)(t.code,{children:"36"}),". We run our loop and hit the next conditional because ",(0,r.jsx)(t.code,{children:"currentNode.data"})," (36) is greater than ",(0,r.jsx)(t.code,{children:"insertedNode.data"})," (22)."]}),"\n",(0,r.jsxs)(t.li,{children:["The root node doesn't have any child nodes yet so ",(0,r.jsx)(t.code,{children:"currentNode.left"})," (the root node's left child property) is ",(0,r.jsx)(t.code,{children:"null"}),". That means we can set the value of the root node's left child property to the inserted node."]}),"\n",(0,r.jsx)(t.li,{children:"We are done. We need to return or break out of our statement so it doesn't run forever."}),"\n"]}),"\n",(0,r.jsxs)(t.h4,{id:"third-insertion-bstinsertnodenode3",children:["Third Insertion: ",(0,r.jsx)(t.code,{children:"bst.insertNode(node3);"})]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"node3"})," has a ",(0,r.jsx)(t.code,{children:"data"})," value of ",(0,r.jsx)(t.code,{children:"11"})," in our test."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"There's already a root node so we skip over that conditional."}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"currentNode"})," will be set to the root node (",(0,r.jsx)(t.code,{children:"let currentNode = this.root;"}),")."]}),"\n",(0,r.jsx)(t.li,{children:"Next, we hit our loop. The value of the root node is greater than the inserted node so that conditional is true."}),"\n",(0,r.jsxs)(t.li,{children:["However, the value of the root node's ",(0,r.jsx)(t.code,{children:"left"})," property isn't ",(0,r.jsx)(t.code,{children:"null"}),". That means we move to the ",(0,r.jsx)(t.code,{children:"else"})," statement:"]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"...\n} else {\n  currentNode = currentNode.left;\n}\n...\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Before the reassignment, ",(0,r.jsx)(t.code,{children:"currentNode"})," is the root node. After reassignment, ",(0,r.jsx)(t.code,{children:"currentNode"})," is set to the root node's left property. We have a new ",(0,r.jsx)(t.code,{children:"currentNode"})," and we've successfully traversed down a level in our tree!"]}),"\n",(0,r.jsxs)(t.li,{children:["We iterate through the while loop again. The value of the ",(0,r.jsx)(t.code,{children:"currentNode"}),"'s ",(0,r.jsx)(t.code,{children:"data"})," property (22) is still greater than the value of the ",(0,r.jsx)(t.code,{children:"insertedNode"}),"'s ",(0,r.jsx)(t.code,{children:"data"})," property (11)."]}),"\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"currentNode"})," (the root node's left child node) doesn't have any children yet so ",(0,r.jsx)(t.code,{children:"currentNode.left === null"}),". We can insert the new node and return from the function. We are done \u2014 and we've successfully traversed multiple levels of the tree to insert a node."]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"adding-a-node-to-a-child-node-right-side",children:"Adding A Node to a Child Node (Right Side)"}),"\n",(0,r.jsx)(t.p,{children:"Next, we need to add a test for adding child nodes on the right side. We've already laid all the groundwork for the left side so try writing a test (and the passing code) for the right side as well before looking at the code below."}),"\n",(0,r.jsx)(t.p,{children:"Here's the test:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"__tests__/bst.test.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"test('it should add a child to the right of a child node', () => {\n  let bst = new BST();\n  let rootNode = new BSTNode(36);\n  bst.insertNode(rootNode);\n  let node2 = new BSTNode(48);\n  bst.insertNode(node2);\n  let node3 = new BSTNode(73);\n  bst.insertNode(node3);\n  expect(rootNode.right.right.data).toEqual(73);\n});\n"})}),"\n",(0,r.jsxs)(t.p,{children:["We've just updated the test so that the values increase with each node instead of decrease \u2014 which means that nodes will always be added to the right side. Finally, we expect the ",(0,r.jsx)(t.code,{children:"rootNode.right.right.data"})," property to be equal to ",(0,r.jsx)(t.code,{children:"73"})," \u2014 the value of the highest ",(0,r.jsx)(t.code,{children:"data"})," property. Note that ",(0,r.jsx)(t.code,{children:"rootNode.right.right"})," is the right child of the right child of the root node \u2014 just in case those nested properties are confusing."]}),"\n",(0,r.jsx)(t.p,{children:"To make the code pass, we just need to add some code that looks very similar to the code we added for inserting nodes in the left side of our tree. Here's the complete method so far:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"src/bst.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"\ninsertNode(insertedNode) {\n  if (this.root === null) {\n    this.root = insertedNode;\n  } else {\n    let currentNode = this.root;    \n    while (true) {\n      if (currentNode.data > insertedNode.data) {\n        if (currentNode.left === null) {\n          currentNode.left = insertedNode;\n          return this;\n        } else {\n          currentNode = currentNode.left;\n        }\n      } else if (currentNode.data < insertedNode.data) {\n        if (currentNode.right === null) {\n          currentNode.right = insertedNode;\n          return this;\n        } else {\n          currentNode = currentNode.right\n        }\n      }\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"As you can see, the code for inserting nodes on the right side is almost exactly the same as the code we've already added for the left side so we won't explain it again."}),"\n",(0,r.jsx)(t.h3,{id:"verifying-the-code-works-for-both-sides",children:"Verifying the Code Works for Both Sides"}),"\n",(0,r.jsx)(t.p,{children:"At this point, our code should work regardless of whether our method has to traverse left, right, or both. However, it would be good to verify that it can traverse one direction and then the other. Remember the following image from earlier in the lesson?"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"Image of adding a child node to the root node and then adding a node to the child.",src:n(25995).A+"",width:"231",height:"411"})}),"\n",(0,r.jsx)(t.p,{children:"Let's add a test for that now:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"__tests__/bst.test.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"test('it should add a child to left or right of a node', () => {\n  let bst = new BST();\n  let rootNode = new BSTNode(36);\n  bst.insertNode(rootNode);\n  let node2 = new BSTNode(22);\n  bst.insertNode(node2);\n  let node3 = new BSTNode(33);\n  bst.insertNode(node3);\n  expect(rootNode.left.right.data).toEqual(33);\n});\n"})}),"\n",(0,r.jsx)(t.p,{children:"If we run our tests, we'll see it passes."}),"\n",(0,r.jsx)(t.p,{children:"So we're good to go. Right? Or is there something missing? Can you think of a condition we haven't handled in our method? If so, how should it be handled?"}),"\n",(0,r.jsx)(t.h3,{id:"handling-duplicate-values",children:"Handling Duplicate Values"}),"\n",(0,r.jsxs)(t.p,{children:["What happens if a node with a specified ",(0,r.jsx)(t.code,{children:"data"})," value already exists in our binary search tree? Well, binary search trees can't have duplicates so that's not allowed. And if we were to try to insert a node with a ",(0,r.jsx)(t.code,{children:"data"})," value that already exists in our tree, we'd hit an infinite loop because we're not dealing with that conditional."]}),"\n",(0,r.jsxs)(t.p,{children:["So let's write a test and keep it simple. If we try to insert a node that has the same ",(0,r.jsx)(t.code,{children:"data"})," property as another node in the tree, our method will just return the existing binary search tree."]}),"\n",(0,r.jsx)(t.p,{children:"Here's the test:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"__tests__/bst.test.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'test(\'it should not add duplicate nodes\', () => {\n    let bst = new BST();\n    let rootNode = new BSTNode(36);\n    bst.insertNode(rootNode);\n    let node2 = new BSTNode(36);\n    expect(bst.insertNode(node2)).toEqual({"root": {"data": 36, "left": null, "right": null}});\n  });\n'})}),"\n",(0,r.jsxs)(t.p,{children:["We insert a node and then try to insert a second node that has the same ",(0,r.jsx)(t.code,{children:"data"})," value. Because we are setting our method to return the full tree when we call ",(0,r.jsx)(t.code,{children:"bst.insertNode(node2)"}),", it will return a tree that only includes one node \u2014 not the duplicate."]}),"\n",(0,r.jsx)(t.p,{children:"Here's the full logic which will get all tests passing:"}),"\n",(0,r.jsx)(t.div,{className:"filename",children:"src/bst.js"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"export default class BST {\n  constructor() {\n    this.root = null;\n  }\n\n  insertNode(insertedNode) {\n    if (this.root === null) {\n      this.root = insertedNode;\n    } else {\n      let currentNode = this.root;\n      while (true) {\n        if (currentNode.data > insertedNode.data) {\n          if (currentNode.left === null) {\n            currentNode.left = insertedNode;\n            return this;\n          } else {\n            currentNode = currentNode.left;\n          }\n        } else if (currentNode.data < insertedNode.data) {\n          if (currentNode.right === null) {\n            currentNode.right = insertedNode;\n            return this;\n          } else {\n            currentNode = currentNode.right\n          }\n        } else {\n          return this;\n        }\n      }\n    }\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["We just needed to add an ",(0,r.jsx)(t.code,{children:"else"})," statement that returns the full tree \u2014 because if the ",(0,r.jsx)(t.code,{children:"data"})," property of the node we are trying to insert is neither less than nor equal to any existing node in the tree, it either must have an equal ",(0,r.jsx)(t.code,{children:"data"})," value or have some bogus ",(0,r.jsx)(t.code,{children:"data"})," value that can't be compared (for instance, ",(0,r.jsx)(t.code,{children:'"hello"'})," is neither less than nor equal to any number), which means we just return the tree instead of altering it."]}),"\n",(0,r.jsx)(t.p,{children:"We could clean up our code by adding more robust error handling and DRYing up our tests but that's not the point of our project. We've created a simple method that can build a basic binary search tree. In the next lesson, we'll use this application to actually build a binary search tree that we'll then be able to search. We'll also discover a big problem with our binary search tree method as well, though fixing it is beyond the scope of this curriculum."})]})}function c(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);