"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[34572],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(96540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}},29707:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"intermediate-javascript/asynchrony-and-apis/2-3-1-6-separating-promise-logic","title":"\ud83d\udcd3 2.3.1.6 Separating Promise Logic","description":"Now that we\'ve learned about static methods, let\'s refactor our weather API application to use one. In the process, we\'ll separate our API call business logic into a separate file.","source":"@site/versioned_docs/version-v1_3/2_intermediate-javascript/3_asynchrony-and-apis/2-3-1-06-separating-promise-logic.md","sourceDirName":"2_intermediate-javascript/3_asynchrony-and-apis","slug":"/intermediate-javascript/asynchrony-and-apis/2-3-1-6-separating-promise-logic","permalink":"/v1.3/intermediate-javascript/asynchrony-and-apis/2-3-1-6-separating-promise-logic","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 2.3.1.6 Separating Promise Logic","day":"monday","id":"2-3-1-6-separating-promise-logic","hide_table_of_contents":true},"sidebar":"intermediate-javascript","previous":{"title":"\ud83d\udcd3 2.3.1.5 Static Methods and Properties","permalink":"/v1.3/intermediate-javascript/asynchrony-and-apis/2-3-1-5-static-methods-and-properties"},"next":{"title":"\ud83d\udcd3 2.3.1.7 SOP and CORS","permalink":"/v1.3/intermediate-javascript/asynchrony-and-apis/2-3-1-7-sop-and-cors"}}');var s=t(74848),i=t(28453);const a={title:"\ud83d\udcd3 2.3.1.6 Separating Promise Logic",day:"monday",id:"2-3-1-6-separating-promise-logic",hide_table_of_contents:!0},o=void 0,c={},l=[{value:"An Alternate Organization of <code>index.js</code>",id:"an-alternate-organization-of-indexjs",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",code:"code",div:"div",em:"em",h2:"h2",hr:"hr",i:"i",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Now that we've learned about static methods, let's refactor our weather API application to use one. In the process, we'll separate our API call business logic into a separate file."}),"\n",(0,s.jsxs)(n.p,{children:["Here's the code so far on the branch called ",(0,s.jsx)(n.code,{children:"2_xhr_api_call_with_promises"}),":"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsxs)(n.a,{href:"https://github.com/epicodus-lessons/section-6-js-api-call-with-webpack/tree/2_xhr_api_call_with_promises",children:[(0,s.jsx)(n.i,{className:"glyphicon glyphicon-folder-open"}),"  Example GitHub Repo for API Project with Promises"]})})}),"\n",(0,s.jsxs)(n.p,{children:["We'll just add one additional file to hold our API logic. We'll call this file ",(0,s.jsx)(n.code,{children:"weather-service.js"})," and the file will hold a class called ",(0,s.jsx)(n.code,{children:"WeatherService"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Why are we using the term ",(0,s.jsx)(n.strong,{children:"service"})," here? A service is a piece of reusable code that can be shared across an application. In this case, we are separating out our API call so we can make this code available wherever it's needed. In a very large application, we might need to include our service in many different places. That isn't the case here, but using this design pattern will make our application more scalable."]}),"\n",(0,s.jsx)(n.p,{children:"Let's take a look at the code in this file:"}),"\n",(0,s.jsx)(n.div,{className:"filename",children:"src/weather-service.js"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'export default class WeatherService {  \n  static getWeather(city) {\n    return new Promise(function(resolve, reject) {\n      let request = new XMLHttpRequest();\n      const url = `http://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${process.env.API_KEY}`;\n      request.addEventListener("loadend", function() {\n        const response = JSON.parse(this.responseText);\n        if (this.status === 200) {\n          resolve([response, city]);\n        } else {\n          reject([this, response, city]);\n        }\n      });\n      request.open("GET", url, true);\n      request.send();\n    });\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We ",(0,s.jsx)(n.code,{children:"export"})," a ",(0,s.jsx)(n.code,{children:"default"})," class because we will only be exporting ",(0,s.jsx)(n.code,{children:"WeatherService"}),". We also don't include a constructor, however we can still instantiate a new WeatherService instance if we needed to:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const myWeatherService = new WeatherService();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Next, we use the ",(0,s.jsx)(n.code,{children:"static"})," keyword to define a static method called ",(0,s.jsx)(n.code,{children:"getWeather()"})," which takes a ",(0,s.jsx)(n.code,{children:"city"})," as a parameter."]}),"\n",(0,s.jsxs)(n.p,{children:["The code inside this static method is almost exactly the same as it was before. The only difference is that we need to ",(0,s.jsx)(n.em,{children:"return"})," our promise. There's no need to save the promise in a variable. So, ",(0,s.jsx)(n.code,{children:"getWeather"})," is just a method that returns a promise object."]}),"\n",(0,s.jsxs)(n.p,{children:["The big gotcha that we see for many students trying to separate out logic is that they forget the ",(0,s.jsx)(n.code,{children:"return"})," keyword. As we know, functions need to return something or they will be ",(0,s.jsx)(n.code,{children:"undefined"}),". We've seen many situations where students thought they were getting ",(0,s.jsx)(n.code,{children:"undefined"})," in their code because they weren't handling asynchrony properly \u2014 but the real reason was because a function didn't return anything!"]}),"\n",(0,s.jsxs)(n.p,{children:["Now let's take a look at the updated code for ",(0,s.jsx)(n.code,{children:"index.js"}),":"]}),"\n",(0,s.jsx)(n.div,{className:"filename",children:"src/index.js"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import 'bootstrap';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport './css/styles.css';\nimport WeatherService from './weather-service.js'\n\n// Business Logic\n\nfunction getWeather(city) {\n  let promise = WeatherService.getWeather(city);\n  promise.then(function(weatherDataArray) {\n    printElements(weatherDataArray);\n  }, function(errorArray) {\n    printError(errorArray);\n  });\n}\n\n// UI Logic\n\nfunction printElements(data) {\n  document.querySelector('#showResponse').innerText = `The humidity in ${data[1]} is ${data[0].main.humidity}%.\n  The temperature in Kelvins is ${data[0].main.temp} degrees.`;\n}\n\nfunction printError(error) {\n  document.querySelector('#showResponse').innerText = `There was an error accessing the weather data for ${error[2]}: ${error[0].status} ${error[0].statusText}: ${error[1].message}`;\n}\n\nfunction handleFormSubmission(event) {\n  event.preventDefault();\n  const city = document.querySelector('#location').value;\n  document.querySelector('#location').value = null;\n  getWeather(city);\n}\n\nwindow.addEventListener(\"load\", function() {\n  document.querySelector('form').addEventListener(\"submit\", handleFormSubmission);\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["First we need to make sure to import our ",(0,s.jsx)(n.code,{children:"WeatherService"}),". We make our API call by doing the following:"]}),"\n",(0,s.jsx)(n.div,{className:"filename",children:"src/index.js"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function getWeather(city) {\n  let promise = WeatherService.getWeather(city);\n  promise.then(function(weatherDataArray) {\n    printElements(weatherDataArray);\n  }, function(errorArray) {\n    printError(errorArray);\n  });\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It should be really clear why our static ",(0,s.jsx)(n.code,{children:"WeatherService.getWeather()"})," method needs to return a promise \u2014 otherwise, the ",(0,s.jsx)(n.code,{children:"promise"})," variable would be undefined when we use it."]}),"\n",(0,s.jsxs)(n.p,{children:["Because the variable holds a promise, we can call ",(0,s.jsx)(n.code,{children:"Promise.prototype.then()"})," on it."]}),"\n",(0,s.jsxs)(n.h2,{id:"an-alternate-organization-of-indexjs",children:["An Alternate Organization of ",(0,s.jsx)(n.code,{children:"index.js"})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["Consider the following alternate organization of our logic in ",(0,s.jsx)(n.code,{children:"index.js"}),". This is just as acceptable as the initial solution, and could be considered more favorable since there's fewer lines of code without sacrificing good separation of logic and readability."]}),"\n",(0,s.jsx)(n.p,{children:"How you decide to organize the code in your own applications will depend on the functionality: how you need to process the data involved and how many API calls you need to make. Regardless of how you choose to organize your code, your business logic and UI logic should remain clearly separated."}),"\n",(0,s.jsx)(n.div,{className:"filename",children:"src/index.js"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import 'bootstrap';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport './css/styles.css';\nimport WeatherService from './weather-service.js'\n\n// UI Logic\n\nfunction handleFormSubmission(event) {\n  event.preventDefault();\n  const city = document.querySelector('#location').value;\n  document.querySelector('#location').value = null;\n  let promise = WeatherService.getWeather(city);\n  promise.then(function(weatherDataArray) {\n    printElements(weatherDataArray);\n  }, function(errorArray) {\n    printError(errorArray);\n  });\n}\n\nfunction printElements(data) {\n  document.querySelector('#showResponse').innerText = `The humidity in ${data[1]} is ${data[0].main.humidity}%.\n  The temperature in Kelvins is ${data[0].main.temp} degrees.`;\n}\n\nfunction printError(error) {\n  document.querySelector('#showResponse').innerText = `There was an error accessing the weather data for ${error[2]}: ${error[0].status} ${error[0].statusText}: ${error[1].message}`;\n}\n\nwindow.addEventListener(\"load\", function() {\n  document.querySelector('form').addEventListener(\"submit\", handleFormSubmission);\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"In this lesson, we've made some minor changes to our code that make a big difference in terms of separating logic and keeping our code concise and clean. You'll be expected to separate code related to API calls into its own file for this section's independent project."}),"\n",(0,s.jsxs)(n.p,{children:["Here's the project with separated logic on the branch called ",(0,s.jsx)(n.code,{children:"3_separate_logic_with_xhr_and_promises"}),":"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsxs)(n.a,{href:"https://github.com/epicodus-lessons/section-6-js-api-call-with-webpack/tree/3_separate_logic_with_xhr_and_promises",children:[(0,s.jsx)(n.i,{className:"glyphicon glyphicon-folder-open"}),"  Example GitHub Repo for API Project with Promises"]})})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);