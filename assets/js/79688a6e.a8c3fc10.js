"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[28951],{28453:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>s});var o=n(96540);const a={},i=o.createContext(a);function c(e){const t=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),o.createElement(i.Provider,{value:t},e.children)}},54322:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>h,frontMatter:()=>c,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"react/react-fundamentals/4-2-2-3-unidirectional-data-flow","title":"\ud83d\udcd3 4.2.2.3 Unidirectional Data Flow","description":"So far we have only been working with local state. However, when a user inputs data in our form, we somehow need to get that data from our NewTicketForm component to its parent TicketControl component.","source":"@site/docs/4_react/2_react-fundamentals/4-2-2-03-unidirectional-data-flow.md","sourceDirName":"4_react/2_react-fundamentals","slug":"/react/react-fundamentals/4-2-2-3-unidirectional-data-flow","permalink":"/v1.2/react/react-fundamentals/4-2-2-3-unidirectional-data-flow","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 4.2.2.3 Unidirectional Data Flow","day":"tuesday","id":"4-2-2-3-unidirectional-data-flow","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 4.2.2.2 Adding a Form","permalink":"/v1.2/react/react-fundamentals/4-2-2-2-adding-a-form"},"next":{"title":"\ud83d\udcd3 4.2.2.4 Passing Data Via Callbacks","permalink":"/v1.2/react/react-fundamentals/4-2-2-4-passing-data-via-callbacks"}}');var a=n(74848),i=n(28453);const c={title:"\ud83d\udcd3 4.2.2.3 Unidirectional Data Flow",day:"tuesday",id:"4-2-2-3-unidirectional-data-flow",hide_table_of_contents:!0},s=void 0,r={},l=[];function d(e){const t={code:"code",em:"em",li:"li",ol:"ol",p:"p",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["So far we have only been working with local state. However, when a user inputs data in our form, we somehow need to get that data from our ",(0,a.jsx)(t.code,{children:"NewTicketForm"})," component to its parent ",(0,a.jsx)(t.code,{children:"TicketControl"})," component."]}),"\n",(0,a.jsxs)(t.p,{children:["Before we do that, we need to learn more about ",(0,a.jsx)(t.strong,{children:"unidirectional data flow"}),". Unidirectional data flow is a language-agnostic term for applications that have data flowing in only one direction."]}),"\n",(0,a.jsxs)(t.p,{children:["In the case of React applications, data can only flow from a parent component ",(0,a.jsx)(t.em,{children:"down"})," to a child component. That's why shared state should always be lifted to a common ancestor. Only child components will ever be able to access that state. Components that are higher up the component tree (above a component with state) have no way to know about that state because of unidirectional data flow. In fact, components in React are so modular that they don't even know their parents exist. It's the job of parent components to keep track of their children, not the other way around."]}),"\n",(0,a.jsxs)(t.p,{children:["The same is true with props. We can only pass props ",(0,a.jsx)(t.em,{children:"down"})," from a parent component to a child component. That's the whole point of unidirectional data flow. It may seem like a limiting concept, but it makes planning, building, and debugging an application much easier. If state and props could flow in every direction, our applications would quickly become a mess."]}),"\n",(0,a.jsxs)(t.p,{children:["So if data can only be passed ",(0,a.jsx)(t.em,{children:"down"}),", then how can we get information from a child component up to a parent component?"]}),"\n",(0,a.jsx)(t.p,{children:"The answer: we need to use callbacks. Here's how it works."}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"We define a method in a parent component that has state."}),"\n",(0,a.jsx)(t.li,{children:"The parent component passes this method into the child component as a prop. Functions can be props just like any other data type."}),"\n",(0,a.jsx)(t.li,{children:"We will add this method to a function in our child component in the form of a callback."}),"\n",(0,a.jsx)(t.li,{children:"When the child executes the function that contains the parent component's callback, the method in the parent component is invoked. Because the callback resides in the parent component, the parent component can access any data that's passed into it. This works similarly to a closure."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"This may feel like we're breaking the rules of unidirectional data flow because the parent component can access information from the callback executed in the child component."}),"\n",(0,a.jsxs)(t.p,{children:["However, that's not the case. The parent component passes props ",(0,a.jsx)(t.em,{children:"down"})," using unidirectional data flow. If a function is passed downward as a prop, the parent can still access it."]}),"\n",(0,a.jsx)(t.p,{children:"Understandably, this concept can be confusing at first. Let's make it more concrete by describing how we will do this in our Help Queue application. We'll do the following:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["First, we will create a method called ",(0,a.jsx)(t.code,{children:"onNewTicketCreation"})," in the parent ",(0,a.jsx)(t.code,{children:"TicketControl"})," component."]}),"\n",(0,a.jsxs)(t.li,{children:["Next, we'll pass the ",(0,a.jsx)(t.code,{children:"onNewTicketCreation"})," function to its child ",(0,a.jsx)(t.code,{children:"NewTicketForm"})," component as a prop."]}),"\n",(0,a.jsxs)(t.li,{children:["Our child ",(0,a.jsx)(t.code,{children:"NewTicketForm"})," component has a function called ",(0,a.jsx)(t.code,{children:"handleNewTicketFormSubmission"})," which correctly gathers user inputs from a form. We will add ",(0,a.jsx)(t.code,{children:"onNewTicketCreation"})," to the ",(0,a.jsx)(t.code,{children:"handleNewTicketFormSubmission"})," as a callback."]}),"\n",(0,a.jsxs)(t.li,{children:["Form data will be passed into the ",(0,a.jsx)(t.code,{children:"onNewTicketCreation"})," callback via its parameters."]}),"\n",(0,a.jsxs)(t.li,{children:["The parent ",(0,a.jsx)(t.code,{children:"TicketControl"})," component will have access to that data, which it can then use to add a new ticket to our ",(0,a.jsx)(t.code,{children:"mainTicketList"}),"."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Now that we've covered unidirectional data flow, we're ready to implement this new functionality. Don't worry if it still doesn't make sense. This is a new and complex concept for React beginners \u2014 the best way to learn and internalize how this works is to actually write the code \u2014 and then continue to practice working with unidirectional data flow until the underlying concepts begin to click."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);