"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[80886],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(96540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}},38563:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"react/functional-programming-with-javascript/4-1-0-7-pure-functions","title":"\ud83d\udcd3 4.1.0.7 Pure Functions","description":"When we program in a functional style, the functions we write must always be pure. Let\'s take a look at what makes a pure function.","source":"@site/docs/4_react/1_functional-programming-with-javascript/4-1-0-07-pure-functions.md","sourceDirName":"4_react/1_functional-programming-with-javascript","slug":"/react/functional-programming-with-javascript/4-1-0-7-pure-functions","permalink":"/v1.2/react/functional-programming-with-javascript/4-1-0-7-pure-functions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 4.1.0.7 Pure Functions","day":"weekend","id":"4-1-0-7-pure-functions","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 4.1.0.6 Imperative Versus Declarative Programming","permalink":"/v1.2/react/functional-programming-with-javascript/4-1-0-6-imperative-versus-declarative-programming"},"next":{"title":"\ud83d\udcd3 4.1.0.8 First Class Citizens","permalink":"/v1.2/react/functional-programming-with-javascript/4-1-0-8-first-class-citizens"}}');var r=t(74848),i=t(28453);const a={title:"\ud83d\udcd3 4.1.0.7 Pure Functions",day:"weekend",id:"4-1-0-7-pure-functions",hide_table_of_contents:!0},o=void 0,c={},l=[{value:"Benefits of Pure Functions",id:"benefits-of-pure-functions",level:3}];function u(e){const n={code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["When we program in a functional style, the functions we write must always be ",(0,r.jsx)(n.strong,{children:"pure"}),". Let's take a look at what makes a ",(0,r.jsx)(n.strong,{children:"pure function"}),"."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Given a specific input, a pure function always returns the same output."})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Here's a very basic example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function addOne(num) {\n  return num + 1;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the example above, no matter how many times we pass in the value ",(0,r.jsx)(n.code,{children:"7"})," as an argument, the function will always return ",(0,r.jsx)(n.code,{children:"8"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"In contrast, we can't have a function that returns a random value:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'function guessMyNumber(num) {\n  const myNumber = Math.floor(Math.random() * Math.floor(10) ) + 1;\n  if (num === myNumber) {\n    return "You guessed right!"\n  } else {\n    return "That wasn\'t it."\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The function above takes a number as an argument. We then use ",(0,r.jsx)(n.code,{children:"Math.random()"})," to generate a number between 1 and 10. If the random number matches the number passed in as an argument, the function returns ",(0,r.jsx)(n.code,{children:'"You guessed right!"'})," Otherwise, the function returns ",(0,r.jsx)(n.code,{children:'"That wasn\'t it."'})]}),"\n",(0,r.jsxs)(n.p,{children:["This function isn't pure because we can get different results with the same input. For example, if we input ",(0,r.jsx)(n.code,{children:"7"}),", sometimes we'll get one result and sometimes we'll get the other."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A pure function always returns an output."})," We've already implied this, but let's make it explicit here: a pure function has to return something. A pure function can't always return the same output for a given input if it doesn't return anything at all!"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"A pure function can not have side effects."})," A side effect is when a function changes something in the application outside of the function. Pure functions should only return a single thing. They should not alter anything else in the application."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"We wrote many functions in JavaScript that had side effects. For instance, UI functions that change something in the DOM have side effects:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'function addWord(word) {\n  document.getElementById("typing-box").append(word);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"The function above appends a word to the DOM, which means it's altering something outside of the function. In fact, the function above is entirely side effects \u2014 there is no return value. It's definitely not a pure function!"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pure functions cannot rely on external variables or state."})," If a pure function could rely on external variables or state, then this could affect the return value of the function. Let's use pig dice as an example. Let's assume we have the following function inside a ",(0,r.jsx)(n.code,{children:"Player"})," class:"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"class Player {\n\n  constructor() {\n    this.totalScore = 0;\n  }\n\n  tallyScore(roundScore) {\n    this.totalScore = this.totalScore + roundScore;\n    return this.totalScore;\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the example above, when a player object is instantiated, it begins with a ",(0,r.jsx)(n.code,{children:"totalScore"})," of ",(0,r.jsx)(n.code,{children:"0"}),". Then, when we call the ",(0,r.jsx)(n.code,{children:"tallyScore()"})," method on the player, the player's ",(0,r.jsx)(n.code,{children:"totalScore"})," will be incremented. Because the ",(0,r.jsx)(n.code,{children:"totalScore"})," changes throughout the game, this function can return different results with the same input. For instance, if we input ",(0,r.jsx)(n.code,{children:"7"}),", the function will return ",(0,r.jsx)(n.code,{children:"33"})," if the player's ",(0,r.jsx)(n.code,{children:"totalScore"})," was already ",(0,r.jsx)(n.code,{children:"26"}),", but it would return ",(0,r.jsx)(n.code,{children:"7"})," if the player didn't have any points yet."]}),"\n",(0,r.jsxs)(n.p,{children:["It should also be clear that the ",(0,r.jsx)(n.code,{children:"tallyScore()"})," function has side effects because it alters external state \u2014 yet another reason this function isn't pure."]}),"\n",(0,r.jsx)(n.p,{children:"The same problems occur with global variables. For example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"let score = 0;\n\nfunction incrementScore(points) {\n  score += points;\n  return score;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"We learned in Introduction to Programming that this kind of code can be problematic. In a large code base, it could be very difficult for developers to know which functions are changing those global variables and how those global variables in turn are affecting the rest of the application. The application would be hard to test and have a higher potential for bugs."}),"\n",(0,r.jsx)(n.p,{children:"The code snippet above breaks most rules for a pure function. It can return different values even if the input is the same, it relies on external application state, and it has side effects."}),"\n",(0,r.jsx)(n.h3,{id:"benefits-of-pure-functions",children:"Benefits of Pure Functions"}),"\n",(0,r.jsx)(n.p,{children:"Pure functions are one of the basic tenets of functional programming, but why are they beneficial? Why does it matter if a function returns a consistent value, doesn't have side effects and so on?"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pure functions are easier to test."})," One input always returns the same output. If our tests pass, we know our code is probably good to go. Our pure functions will not alter other parts of the codebase, which means we can keep our tests simple instead of needing to account for other factors such as changing state."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"What You See Is What You Get."})," When we look at a pure function, we know the function has no side effects and can't be altered by external state. For that reason, we can look at a pure function in isolation without needing to know about the rest of the application."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pure functions result in fewer bugs."})," If a pure function is easier to test, easier to reason about, and works independently of the rest of the code base, we can more easily isolate and prevent bugs. This is especially important in a larger codebase."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"We must always write pure functions when using functional programming. In fact, even when we take an object-oriented perspective, we can benefit from writing pure functions."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}}}]);