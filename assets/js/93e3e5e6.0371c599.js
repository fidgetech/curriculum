"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[47060],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>l});var i=n(96540);const o={},s=i.createContext(o);function a(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:t},e.children)}},97477:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/c-sharp-category-details-many-to-many-d7c0263b623845ac73bb1342b4bc5b38.png"},97537:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>r});const i=JSON.parse('{"id":"c-and-net/many-to-many-relationships/3-4-0-5-many-to-many-read-functionality","title":"\ud83d\udcd3 3.4.0.5 Many-to-Many Read Functionality","description":"In the last lesson, we set up a many-to-many structure in our classes, created a join class, and configured and migrated our code into our database. Now we\'re ready to create controllers that will handle our new application structure. In this lesson, we\'ll focus on adding read functionality to the ItemsController, including the following:","source":"@site/versioned_docs/version-v1_3/3_c-and-net/4_many-to-many-relationships/3-4-0-05-many-to-many-read-functionality.md","sourceDirName":"3_c-and-net/4_many-to-many-relationships","slug":"/c-and-net/many-to-many-relationships/3-4-0-5-many-to-many-read-functionality","permalink":"/v1.3/c-and-net/many-to-many-relationships/3-4-0-5-many-to-many-read-functionality","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 3.4.0.5 Many-to-Many Read Functionality","day":"weekend","id":"3-4-0-5-many-to-many-read-functionality","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.4.0.4 Many-to-Many Relationships: Join Entities","permalink":"/v1.3/c-and-net/many-to-many-relationships/3-4-0-4-many-to-many-relationships-join-entities"},"next":{"title":"\ud83d\udcd3 3.4.0.6 Many-to-Many Create Functionality","permalink":"/v1.3/c-and-net/many-to-many-relationships/3-4-0-6-many-to-many-create-functionality"}}');var o=n(74848),s=n(28453);const a={title:"\ud83d\udcd3 3.4.0.5 Many-to-Many Read Functionality",day:"weekend",id:"3-4-0-5-many-to-many-read-functionality",hide_table_of_contents:!0},l=void 0,d={},r=[{value:"READ: Creating the <code>TagsController</code> and <code>Index()</code> Action and View",id:"read-creating-the-tagscontroller-and-index-action-and-view",level:2},{value:"Adding Navigation for Tag Views from the Homepage",id:"adding-navigation-for-tag-views-from-the-homepage",level:3},{value:"READ: Creating the Tags <code>Details()</code> Action and View",id:"read-creating-the-tags-details-action-and-view",level:2},{value:"READ for Join Entities in the Item Details View",id:"read-for-join-entities-in-the-item-details-view",level:2},{value:"READ for Join Entities in the Category Details View",id:"read-for-join-entities-in-the-category-details-view",level:2}];function c(e){const t={a:"a",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["In the last lesson, we set up a many-to-many structure in our classes, created a join class, and configured and migrated our code into our database. Now we're ready to create controllers that will handle our new application structure. In this lesson, we'll focus on adding read functionality to the ",(0,o.jsx)(t.code,{children:"ItemsController"}),", including the following:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Creating the ",(0,o.jsx)(t.code,{children:"TagsController"})," with READ functionality for all tags (the ",(0,o.jsx)(t.code,{children:"Index()"})," action) and an individual tag (the ",(0,o.jsx)(t.code,{children:"Details()"})," action)."]}),"\n",(0,o.jsx)(t.li,{children:"Adding a new navigation link on the homepage to access tags."}),"\n",(0,o.jsx)(t.li,{children:"Creating the views for index and details."}),"\n",(0,o.jsxs)(t.li,{children:["Adding READ for join entities (viewing the tags that belong to each item and vice versa) in the following views:\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"A category's detail page."}),"\n",(0,o.jsx)(t.li,{children:"An item's detail page."}),"\n",(0,o.jsx)(t.li,{children:"A tag's detail page."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.h2,{id:"read-creating-the-tagscontroller-and-index-action-and-view",children:["READ: Creating the ",(0,o.jsx)(t.code,{children:"TagsController"})," and ",(0,o.jsx)(t.code,{children:"Index()"})," Action and View"]}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsxs)(t.p,{children:["Within the ",(0,o.jsx)(t.code,{children:"ToDoList"})," production directory, create a new file called ",(0,o.jsx)(t.code,{children:"TagsController.cs"})," within the ",(0,o.jsx)(t.code,{children:"Controllers"})," directory and add the following code:"]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"Controllers/TagsController.cs"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"using Microsoft.AspNetCore.Mvc;\nusing ToDoList.Models;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.AspNetCore.Mvc.Rendering;\n\nnamespace ToDoList.Controllers\n{\n  public class TagsController : Controller\n  {\n    private readonly ToDoListContext _db;\n\n    public TagsController(ToDoListContext db)\n    {\n      _db = db;\n    }\n\n    public ActionResult Index()\n    {\n      return View(_db.Tags.ToList());\n    }\n  }\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"Index()"})," route should look familiar to those we've created in the ",(0,o.jsx)(t.code,{children:"CategoriesController.cs"})," and ",(0,o.jsx)(t.code,{children:"ItemsController.cs"})," with one shortcut: instead of saving the list of tags to a variable and passing that into the ",(0,o.jsx)(t.code,{children:"View()"})," method, we pass in the method call ",(0,o.jsx)(t.code,{children:"_db.Tags.ToList()"})," directly as the argument to ",(0,o.jsx)(t.code,{children:"View()"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Next, let's create the corresponding ",(0,o.jsx)(t.code,{children:"Index.cshtml"}),". Within the ",(0,o.jsx)(t.code,{children:"Views"})," directory, create another subdirectory called ",(0,o.jsx)(t.code,{children:"Tags"})," and a file within called ",(0,o.jsx)(t.code,{children:"Index.cshtml"})," with the following code:"]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"Views/Tags/Index.cshtml"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-html",children:'@{\n  Layout = "_Layout";\n}\n\n@using ToDoList.Models;\n\n<h1>Tags</h1>\n\n@if (@Model.Count == 0)\n{\n  <h3>No tags have been added yet!</h3>\n} \n\n@foreach (Tag tag in Model)\n{\n  <li>@Html.ActionLink($"{tag.Title}", "Details", new { id = tag.TagId })</li>\n}\n\n<p>@Html.ActionLink("Add new tag", "Create")</p>\n\n<p>@Html.ActionLink("Home", "Index", "Home")</p>\n'})}),"\n",(0,o.jsx)(t.h3,{id:"adding-navigation-for-tag-views-from-the-homepage",children:"Adding Navigation for Tag Views from the Homepage"}),"\n",(0,o.jsxs)(t.p,{children:["Next, let's add a link to our tags from the homepage of our To Do List app. Open up ",(0,o.jsx)(t.code,{children:"ToDoList/Views/Home/Index.cshtml"})," and add the following action link:"]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"Views/Home/Index.cshtml"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-html",children:'...\n\n<p>@Html.ActionLink("See all tags", "Index", "Tags")</p>\n'})}),"\n",(0,o.jsxs)(t.h2,{id:"read-creating-the-tags-details-action-and-view",children:["READ: Creating the Tags ",(0,o.jsx)(t.code,{children:"Details()"})," Action and View"]}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsxs)(t.p,{children:["Next, let's add the ability to see the details of a single tag. In the view, we'll list the title of the tag as well as every item that is currently associated with that tag. That means we're going to have to deliver the tag object to the ",(0,o.jsx)(t.code,{children:"Details.cshtml"})," view, as well as the join entities the tag is associated with."]}),"\n",(0,o.jsxs)(t.p,{children:["First, let's add the ",(0,o.jsx)(t.code,{children:"Details()"})," action to the ",(0,o.jsx)(t.code,{children:"TagsController.cs"}),":"]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"Controllers/TagsController.cs"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"... \n\n    public ActionResult Details(int id)\n    {\n      Tag thisTag = _db.Tags\n          .Include(tag => tag.JoinEntities)\n          .ThenInclude(join => join.Item)\n          .FirstOrDefault(tag => tag.TagId == id);\n      return View(thisTag);\n    }\n\n...\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Notice the new method we are using: ",(0,o.jsx)(t.code,{children:"ThenInclude()"}),". Let's go over what's happening here."]}),"\n",(0,o.jsxs)(t.p,{children:["Our ",(0,o.jsx)(t.code,{children:"_db.Tags"})," expression gives us a list of ",(0,o.jsx)(t.code,{children:"Tag"})," objects from the database. However, if we completed the query now (using the ",(0,o.jsx)(t.code,{children:"FirstOrDefault()"})," method), we'd simply have an ",(0,o.jsx)(t.code,{children:"Tag"})," without its related ",(0,o.jsx)(t.code,{children:"Category"}),"s."]}),"\n",(0,o.jsxs)(t.p,{children:["We need to ",(0,o.jsx)(t.code,{children:".Include(tag => tag.JoinEntities)"})," to load the ",(0,o.jsx)(t.code,{children:"JoinEntities"})," property of each ",(0,o.jsx)(t.code,{children:"Tag"}),". However, the ",(0,o.jsx)(t.code,{children:"JoinEntities"})," property on an ",(0,o.jsx)(t.code,{children:"Tag"})," is just a collection of join entities (",(0,o.jsx)(t.code,{children:"List<ItemTag>"}),"), which are tracked by ids: ",(0,o.jsx)(t.code,{children:"ItemTagId"}),", ",(0,o.jsx)(t.code,{children:"TagId"}),", and ",(0,o.jsx)(t.code,{children:"ItemId"}),". These are ",(0,o.jsx)(t.strong,{children:"not"})," the actual item objects related to a ",(0,o.jsx)(t.code,{children:"Tag"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["We need the actual ",(0,o.jsx)(t.code,{children:"Item"})," objects themselves, so we use ",(0,o.jsx)(t.code,{children:"ThenInclude()"})," method to load the ",(0,o.jsx)(t.code,{children:"Item"})," object associated with each ",(0,o.jsx)(t.code,{children:"ItemTag"}),". Remember that an ",(0,o.jsx)(t.code,{children:"ItemTag"})," is simply a reference to a relationship. Each ",(0,o.jsx)(t.code,{children:"ItemTag"})," includes the id of a ",(0,o.jsx)(t.code,{children:"Tag"})," as well as the id of an ",(0,o.jsx)(t.code,{children:"Item"}),". With ",(0,o.jsx)(t.code,{children:".ThenInclude(join => join.Item)"}),", we actually fetch the associated ",(0,o.jsx)(t.code,{children:"Item"})," object for each ",(0,o.jsx)(t.code,{children:"ItemTag"})," join entity."]}),"\n",(0,o.jsxs)(t.p,{children:["Next, let's create the ",(0,o.jsx)(t.code,{children:"Tags/Details.cshtml"})," view. Again, we'll make sure to display the ",(0,o.jsx)(t.code,{children:"Tag"})," details as well as all of the ",(0,o.jsx)(t.code,{children:"Item"})," objects associated with each Tag."]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"Views/Tags/Details.cshtml"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-html",children:'@{\n  Layout = "_Layout";\n}\n\n@using ToDoList.Models\n@model ToDoList.Models.Tag\n\n<h2>Tag Details</h2>\n<hr />\n<h3>@Html.DisplayNameFor(model => model.Title): @Html.DisplayFor(model => model.Title)</h3>\n\n@if(@Model.JoinEntities.Count == 0)\n{\n  <p>This tag does not belong to any items.</p>\n}\nelse\n{\n  <h4>Items the tag belongs to:</h4>\n  <ul>\n  @foreach(ItemTag join in Model.JoinEntities)\n  {\n    <li>@join.Item.Description</li>\n  }\n  </ul>\n}\n\n<p>@Html.ActionLink("Back to list", "Index")</p>\n'})}),"\n",(0,o.jsx)(t.p,{children:"Most of this code should look familiar, so we'll point out a few important pieces:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["We have an ",(0,o.jsx)(t.code,{children:"@using"})," directive for ",(0,o.jsx)(t.code,{children:"ToDoList.Models"})," so that we can reference the ",(0,o.jsx)(t.code,{children:"ItemTag"})," class in our ",(0,o.jsx)(t.code,{children:"foreach"})," loop."]}),"\n",(0,o.jsxs)(t.li,{children:["We also have an ",(0,o.jsx)(t.code,{children:"@model"})," directive for ",(0,o.jsx)(t.code,{children:"ToDoList.Models.Tag"})," so that we can use the strongly typed HTML helper methods ",(0,o.jsx)(t.code,{children:"Html.DisplayNameFor()"})," and ",(0,o.jsx)(t.code,{children:"@Html.DisplayFor"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["Notice that we access ",(0,o.jsx)(t.code,{children:"@Model.JoinEntities.Count"})," in our conditional: with this line of code, we are checking if the ",(0,o.jsx)(t.code,{children:"List<ItemTag>"})," that we save to the ",(0,o.jsx)(t.code,{children:"Tag.JoinEntities"})," property is empty, and if so, we deliver a message to the user stating that there are no items associated with the tag we're looking at."]}),"\n",(0,o.jsxs)(t.li,{children:["If the ",(0,o.jsx)(t.code,{children:"List<ItemTag>"})," is not empty, then we loop through the ",(0,o.jsx)(t.code,{children:"Tag.JoinEntities"})," property and display each item's description: ",(0,o.jsx)(t.code,{children:"<li>@join.Item.Description</li>"}),". A few notes:\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["The variable ",(0,o.jsx)(t.code,{children:"join"})," represents a single ",(0,o.jsx)(t.code,{children:"ItemTag"})," join entity."]}),"\n",(0,o.jsxs)(t.li,{children:["To get the Item's description, we need to go through the ",(0,o.jsx)(t.code,{children:"ItemTag.Item"})," property, which contains all of the ",(0,o.jsx)(t.code,{children:"Item"})," object's data."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"read-for-join-entities-in-the-item-details-view",children:"READ for Join Entities in the Item Details View"}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsxs)(t.p,{children:["Next, we'll update the ",(0,o.jsx)(t.code,{children:"Details.cshtml"})," views for both ",(0,o.jsx)(t.code,{children:"Categories"})," and ",(0,o.jsx)(t.code,{children:"Items"})," to display tags."]}),"\n",(0,o.jsxs)(t.p,{children:["We'll start with updating ",(0,o.jsx)(t.code,{children:"Views/Items/Details.cshtml"}),". Right now this view shows the description of the item along with the category it belongs to. After the update we make, the view will also include a list of tags that are associated with the item."]}),"\n",(0,o.jsx)(t.p,{children:"Here's the updated code:"}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"Views/Items/Details.cshtml"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-html",children:'@{\n  Layout = "_Layout";\n}\n\n@using ToDoList.Models\n@model ToDoList.Models.Item\n\n<h2>Item Details</h2>\n<hr />\n<h3>@Html.DisplayNameFor(model => model.Description): @Html.DisplayFor(model => model.Description)</h3>  \n<h3>@Html.DisplayNameFor(model => model.Category): @Html.DisplayFor(model => model.Category.Name)</h3>\n\n@if(@Model.JoinEntities.Count == 0)\n{\n  <p>This item does not have any tags yet!</p>\n}\nelse\n{\n  <h4>This item has the following tags:</h4>\n  <ul>\n    @foreach(ItemTag join in Model.JoinEntities)\n    {\n      <li>Tag: @join.Tag.Title</li>\n    }\n  </ul>\n}\n\n<p>@Html.ActionLink("Back to list", "Index")</p>\n<p>@Html.ActionLink("Edit Item or Category", "Edit", new { id = Model.ItemId })</p>\n<p>@Html.ActionLink("Delete Item", "Delete", new { id = Model.ItemId })</p>\n'})}),"\n",(0,o.jsxs)(t.p,{children:["The above addition looks very similar to how we display a list of items that belong to a tag. The main difference is in the naming. In summary, if the ",(0,o.jsx)(t.code,{children:"Item.JoinEntities.Count"})," is equal to zero, then there are no tags that are associated with the item, so we deliver a message to the user about this. Otherwise, we loop through the ",(0,o.jsx)(t.code,{children:"Item.JoinEntities"})," property, and for each join entity we access the ",(0,o.jsx)(t.code,{children:"Tag"})," property to display the tag's title."]}),"\n",(0,o.jsxs)(t.p,{children:["With our view ready to display join entities, we now need to update the ",(0,o.jsx)(t.code,{children:"Details()"})," action in the ",(0,o.jsx)(t.code,{children:"ItemsController.cs"})," to fetch the join entities and tags from the database when we get the data for the item. Here's the update we'll make:"]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"Controllers/ItemsController.cs"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"... \n\n    public ActionResult Details(int id)\n    {\n      Item thisItem = _db.Items\n          .Include(item => item.Category)\n          .Include(item => item.JoinEntities)\n          .ThenInclude(join => join.Tag)\n          .FirstOrDefault(item => item.ItemId == id);\n      return View(thisItem);\n    }\n\n...\n"})}),"\n",(0,o.jsxs)(t.p,{children:["What we've done is add a new ",(0,o.jsx)(t.code,{children:"Include()"})," method to fetch the join entities, and a ",(0,o.jsx)(t.code,{children:"ThenInclude()"})," method to fetch the actual tag object for each join entity."]}),"\n",(0,o.jsxs)(t.p,{children:["Notice how we list an ",(0,o.jsx)(t.code,{children:"Include()"})," method for each navigation property in the ",(0,o.jsx)(t.code,{children:"Item"})," class: ",(0,o.jsx)(t.code,{children:"Item.Category"})," and ",(0,o.jsx)(t.code,{children:"Item.JoinEntities"}),". We can do this for as many navigation properties as we have and need to fetch."]}),"\n",(0,o.jsxs)(t.p,{children:["As always, we end our database query with ",(0,o.jsx)(t.code,{children:"FirstOrDefault()"})," if we want to fetch one object, or ",(0,o.jsx)(t.code,{children:"ToList()"})," if we want to fetch a list of objects. There are many other methods we can use like ",(0,o.jsx)(t.code,{children:"OrderBy()"})," or ",(0,o.jsx)(t.code,{children:"ToDictionary()"}),". If you have not already done so, check out the ",(0,o.jsxs)(t.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable?view=net-6.0#methods",children:["MS Docs on the ",(0,o.jsx)(t.code,{children:"System.Linq.Enumerable"})," class methods"]})," to learn about other methods we can use to query our database."]}),"\n",(0,o.jsx)(t.h2,{id:"read-for-join-entities-in-the-category-details-view",children:"READ for Join Entities in the Category Details View"}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsx)(t.p,{children:"Next, we'll update our category details view to display not just the items that belong to each category, but also the tags that belong to each item. This is what the finished product will look like:"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"To Do List app&#39;s category details page that lists items and tags that belong to each item.",src:n(97477).A+"",width:"505",height:"365"})}),"\n",(0,o.jsx)(t.p,{children:"To make the above possible, we'll need a loop within a loop and some additional code to format our tags to display inline. Here's the updated code:"}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"Views/Category/Details.cshtml"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-html",children:'@{\n  Layout = "_Layout";\n}\n\n@model ToDoList.Models.Category;\n@using ToDoList.Models;\n@using System.Collections.Generic;\n\n<h2>Category Details</h2>\n<hr />\n<h3>@Html.DisplayNameFor(model => model.Name): @Html.DisplayFor(model => model.Name)</h3>\n\n@if(@Model.Items.Count == 0)\n{\n  <p>This category does not contain any items</p>\n}\nelse\n{\n  <h4>Items the category contains:</h4>\n  <ul>\n  @foreach(Item item in Model.Items)\n  {\n    string tags = "";\n    @if(item.JoinEntities.Count == 0)\n    {\n      tags = "This item does not have any tags.";\n    }\n    else\n    {\n      List<string> tagList = new List<string>();\n      @foreach(ItemTag join in item.JoinEntities)\n      {\n        tagList.Add(join.Tag.Title);\n      }\n      tags = String.Join(", ", tagList);\n    }\n    <li>@item.Description | Tags: @tags</li>\n  }\n  </ul>\n}\n\n<p>@Html.ActionLink("Back to categories", "Index")</p>\n<p>@Html.ActionLink("Edit Category", "Edit", new { id = Model.CategoryId })</p>\n<p>@Html.ActionLink("Delete Category", "Delete", new { id = Model.CategoryId })</p>\n<p>@Html.ActionLink("Add new item", "Create", "Items")</p>\n'})}),"\n",(0,o.jsx)(t.p,{children:"We'll focus on understanding the new code:"}),"\n",(0,o.jsxs)(t.p,{children:["First notice that we've added a new ",(0,o.jsx)(t.code,{children:"@using"})," directive for the ",(0,o.jsx)(t.code,{children:"System.Collections.Generic;"})," namespace that allows use to use the ",(0,o.jsx)(t.code,{children:"List<T>"})," type."]}),"\n",(0,o.jsxs)(t.p,{children:["Next, notice how we've refactored the first (outer) ",(0,o.jsx)(t.code,{children:"foreach"})," loop:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["We've added branching logic to check whether there are any tags (join entities) associated with the item. If so, then we loop through the ",(0,o.jsx)(t.code,{children:"Item.JoinEntities"})," property, and if not, then we display a message ",(0,o.jsx)(t.code,{children:'"This item does not have any tags."'}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["In order to display the list of tags inline next to an item, we make use of a variable called ",(0,o.jsx)(t.code,{children:"tags"}),", and the ",(0,o.jsx)(t.code,{children:"String.Join()"})," method:\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["We use the variable ",(0,o.jsx)(t.code,{children:"tags"})," to hold the display value for tags. It will be either a message saying there are no tags, or all of the tags associated with the item, separated by a comma."]}),"\n",(0,o.jsxs)(t.li,{children:["When the ",(0,o.jsx)(t.code,{children:"tags"})," variable is set to the item's tags separated by a comma, we create this string by doing the following:\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Creating an empty ",(0,o.jsx)(t.code,{children:"List<string>"})," called ",(0,o.jsx)(t.code,{children:"tagList"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["Looping through the join entities and adding each join entity's tag's title to the ",(0,o.jsx)(t.code,{children:"tagList"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["Using ",(0,o.jsx)(t.code,{children:"String.Join()"})," to join each list item in ",(0,o.jsx)(t.code,{children:"tagList"})," into a string, separating each item with a comma and space."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Phew! That is a lot of new logic. Note that you can format your code however you like and you don't need to create complicated formatting in your own projects. You also don't ",(0,o.jsx)(t.em,{children:"need"})," to display each item's tags on a category's detail page. However, you should consider what is best for a user's experience as far as navigating a site and accessing information. As always, have fun and try exploring something new."]}),"\n",(0,o.jsxs)(t.p,{children:["With our category ",(0,o.jsx)(t.code,{children:"Details"})," view ready to display each item's join entities, we now need to revisit our ",(0,o.jsx)(t.code,{children:"Details()"})," action in the ",(0,o.jsx)(t.code,{children:"CategoriesController.cs"})," to fetch not only a list of items, but each's item's tags."]}),"\n",(0,o.jsx)(t.p,{children:"Here's the update we'll make:"}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"Controllers/CategoriesController.cs"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"... \n\n    public ActionResult Details(int id)\n    {\n      Category thisCategory = _db.Categories\n                                .Include(cat => cat.Items)\n                                .ThenInclude(item => item.JoinEntities)\n                                .ThenInclude(join => join.Tag)\n                                .FirstOrDefault(category => category.CategoryId == id);\n      return View(thisCategory);\n    }\n\n...\n"})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"Category"})," has only one navigation property, ",(0,o.jsx)(t.code,{children:"Category.Items"}),"; this is why there is only one ",(0,o.jsx)(t.code,{children:"Include()"})," method call. If we want to access each item's tag(s), we need to use a series of ",(0,o.jsx)(t.code,{children:"ThenInclude()"})," method calls to get the ",(0,o.jsx)(t.code,{children:"Item.JoinEntities"})," data for each item, and then the ",(0,o.jsx)(t.code,{children:"JoinEntity.Tag"})," tag data for each join entity."]}),"\n",(0,o.jsx)(t.p,{children:"We should now be able to run our application and navigate from the homepage to the tags index view. However, in order to view our new tag's details page (and the updates to our category and item details page), we'll have to first add some tags. Let's do that next."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);