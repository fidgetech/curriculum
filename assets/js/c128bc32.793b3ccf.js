"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[93867],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>l});var i=n(96540);const o={},a=i.createContext(o);function s(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:t},e.children)}},42495:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"c-and-net/many-to-many-relationships/5-4-0-8-many-to-many-delete-functionality","title":"\ud83d\udcd3 5.4.0.8 Many-to-Many Delete Functionality","description":"In this lesson we\'ll complete our refactor to include a many-to-many functionality between tags and items by adding delete functionality. We\'ll add delete functionality for Tags and delete functionality for ItemTags.","source":"@site/versioned_docs/version-WIP/c-and-net/4_many-to-many-relationships/3-4-0-08-many-to-many-delete-functionality.md","sourceDirName":"c-and-net/4_many-to-many-relationships","slug":"/c-and-net/many-to-many-relationships/5-4-0-8-many-to-many-delete-functionality","permalink":"/WIP/c-and-net/many-to-many-relationships/5-4-0-8-many-to-many-delete-functionality","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 5.4.0.8 Many-to-Many Delete Functionality","day":"weekend","id":"5-4-0-8-many-to-many-delete-functionality","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 5.4.0.7 Many-to-Many Update Functionality","permalink":"/WIP/c-and-net/many-to-many-relationships/5-4-0-7-many-to-many-update-functionality"},"next":{"title":"\u270f\ufe0f 5.4.1.1 University Registrar, Doctor\'s Office","permalink":"/WIP/c-and-net/many-to-many-relationships/5-4-1-1-university-registrar-doctors-office"}}');var o=n(74848),a=n(28453);const s={title:"\ud83d\udcd3 5.4.0.8 Many-to-Many Delete Functionality",day:"weekend",id:"5-4-0-8-many-to-many-delete-functionality",hide_table_of_contents:!0},l=void 0,d={},c=[{value:"DELETE: Adding Delete Functionality to <code>Tag</code>s",id:"delete-adding-delete-functionality-to-tags",level:2},{value:"DELETE: Adding Delete Functionality to <code>ItemTag</code>s",id:"delete-adding-delete-functionality-to-itemtags",level:2},{value:"<code>joinId</code> and Route Configuration in <code>Program.cs</code>",id:"joinid-and-route-configuration-in-programcs",level:3},{value:"Updating the <code>ItemsController</code> and <code>Details.cshtml</code> View to Delete Join Entities",id:"updating-the-itemscontroller-and-detailscshtml-view-to-delete-join-entities",level:3},{value:"Repository Reference",id:"repository-reference",level:3}];function r(e){const t={a:"a",code:"code",div:"div",h2:"h2",h3:"h3",hr:"hr",i:"i",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["In this lesson we'll complete our refactor to include a many-to-many functionality between tags and items by adding delete functionality. We'll add delete functionality for ",(0,o.jsx)(t.code,{children:"Tag"}),"s and delete functionality for ",(0,o.jsx)(t.code,{children:"ItemTag"}),"s."]}),"\n",(0,o.jsxs)(t.h2,{id:"delete-adding-delete-functionality-to-tags",children:["DELETE: Adding Delete Functionality to ",(0,o.jsx)(t.code,{children:"Tag"}),"s"]}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsxs)(t.p,{children:["We'll start by creating ",(0,o.jsx)(t.code,{children:"Delete()"})," GET and POST actions in our ",(0,o.jsx)(t.code,{children:"TagsController"}),". Here's the new code that we'll add:"]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"Controllers/TagsController.cs"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:'...\n    public ActionResult Delete(int id)\n    {\n      Tag thisTag = _db.Tags.FirstOrDefault(tags => tags.TagId == id);\n      return View(thisTag);\n    }\n\n    [HttpPost, ActionName("Delete")]\n    public ActionResult DeleteConfirmed(int id)\n    {\n      Tag thisTag = _db.Tags.FirstOrDefault(tags => tags.TagId == id);\n      _db.Tags.Remove(thisTag);\n      _db.SaveChanges();\n      return RedirectToAction("Index");\n    }\n...\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Note that when we delete a ",(0,o.jsx)(t.code,{children:"Tag"}),", all join entities that reference that tag's ",(0,o.jsx)(t.code,{children:"TagId"})," will also automatically be deleted. This is configured through ",(0,o.jsx)(t.strong,{children:"foreign key constraints"}),", which configures how objects in relationships should be deleted or updated when one object in the relationship is deleted or updated. For example, in our one-to-many relationship between categories and items, an item always belongs to a single category, and a category can have many items. If a user deletes a category that has five items in it, we can configure through foreign key constraints how those five items should be treated: should they remain in the database? Should they all be deleted?"]}),"\n",(0,o.jsx)(t.p,{children:"The default behavior in our application for one-to-many and many-to-many relationships is that when one object is deleted, related objects should also be deleted:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["In the one-to-many relationship between categories and items, when a category is deleted all associated items will also be deleted. That's because each ",(0,o.jsx)(t.code,{children:"Item"})," object has a ",(0,o.jsx)(t.code,{children:"CategoryId"})," property that becomes a foreign key in our database tables and links each ",(0,o.jsx)(t.code,{children:"Item"})," to a specific ",(0,o.jsx)(t.code,{children:"Category"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["In the many-to-many relationship between items and tags, when an item is deleted all join entities in the ",(0,o.jsx)(t.code,{children:"itemtags"})," table that reference that item will also be deleted. That's because ",(0,o.jsx)(t.code,{children:"ItemId"})," is a foreign key in the ",(0,o.jsx)(t.code,{children:"itemtags"})," table, connecting each ",(0,o.jsx)(t.code,{children:"ItemTag"})," object to a specific ",(0,o.jsx)(t.code,{children:"Item"})," object. Similarly, when a tag is deleted all join entities in the ",(0,o.jsx)(t.code,{children:"itemtags"})," table that reference that tag will also be deleted. That's because ",(0,o.jsx)(t.code,{children:"TagId"})," is a foreign key in the ",(0,o.jsx)(t.code,{children:"itemtags"})," table, connecting each ",(0,o.jsx)(t.code,{children:"ItemTag"})," object to a specific ",(0,o.jsx)(t.code,{children:"Tag"})," object."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["The automatic deletion of associated objects through foreign keys has a specific name: ",(0,o.jsx)(t.strong,{children:"cascade delete"}),". This is the default behavior for the foreign keys we create because they are all non-nullable, which means they can't have a ",(0,o.jsx)(t.code,{children:"null"})," value. This means that when a ",(0,o.jsx)(t.code,{children:"Tag"})," entry in the ",(0,o.jsx)(t.code,{children:"tags"})," database table is removed, then all of the entries in all other tables (right now just the ",(0,o.jsx)(t.code,{children:"itemtags"})," table) that use that ",(0,o.jsx)(t.code,{children:"Tag"})," as a foreign key (via ",(0,o.jsx)(t.code,{children:"TagId"}),") will also be removed, because the foreign key cannot be ",(0,o.jsx)(t.code,{children:"null"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["We could configure our foreign keys constraints to not delete associated objects, but we don't have a reason to change this behavior right now. Also, the specifics of how to do that is out of the scope of this lesson. To learn more about configuring cascade delete with EF Core, start by reading ",(0,o.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/ef/core/modeling/relationships?tabs=fluent-api%2Cfluent-api-simple-key%2Csimple-key",children:"the article on creating and configuring relationships with EF Core"}),". Some of the article's content will be a review, but other content will be new. Then, read about ",(0,o.jsx)(t.a,{href:"https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html",children:"foreign key constraints on the MySQL documentation"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Next, let's create our view that confirms that we are sure that we want to delete the tag. Within the ",(0,o.jsx)(t.code,{children:"Views/Tags/"})," subdirectory, create a new file called ",(0,o.jsx)(t.code,{children:"Delete.cshtml"}),", and add the following contents:"]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"Views/Tags/Delete.cshtml"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-html",children:'@{\n  Layout = "_Layout";\n}\n\n@model ToDoList.Models.Tag\n\n<h2>Are you sure you want to delete this?</h2>\n\n@Html.DisplayNameFor(model => model.Title): @Html.DisplayFor(model => model.Title)\n@using (Html.BeginForm())\n{\n    <input type="submit" value="Delete" />\n}\n@Html.ActionLink("Back to List", "Index")\n'})}),"\n",(0,o.jsxs)(t.p,{children:["As always, let's finish up by adding a link to our new ",(0,o.jsx)(t.code,{children:"Delete"})," route to our tag's ",(0,o.jsx)(t.code,{children:"Details.cshtml"}),":"]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"Views/Tags/Details.cshtml"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-html",children:'...\n<p>@Html.ActionLink("Delete Tag", "Delete", new { id = Model.TagId })</p>\n'})}),"\n",(0,o.jsxs)(t.h2,{id:"delete-adding-delete-functionality-to-itemtags",children:["DELETE: Adding Delete Functionality to ",(0,o.jsx)(t.code,{children:"ItemTag"}),"s"]}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsxs)(t.p,{children:["Next, we'll add the ability to delete join relationships. This time we won't create a new view for this, but instead add a delete button directly below each join entity in the details view in both ",(0,o.jsx)(t.code,{children:"Views/Items/Details.cshtml"})," and ",(0,o.jsx)(t.code,{children:"Views/Tags/Details.cshtml"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["First, let's check out the new button we'll be adding to the ",(0,o.jsx)(t.code,{children:"Views/Tags/Details.cshtml"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:'@using (Html.BeginForm("DeleteJoin", "Tags"))\n{\n  @Html.Hidden("joinId", @join.ItemTagId)\n  <input type="submit" value="Delete"/>\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Notably, the button is wrapped in a form that contains a hidden ",(0,o.jsx)(t.code,{children:"joinId"})," value for the join entity. That's because in order to change something in our database, we need to make a request via a form. When the user submits this form, it will go to a ",(0,o.jsx)(t.code,{children:"DeleteJoin"})," action in the ",(0,o.jsx)(t.code,{children:"TagsController.cs"})," which will handle deleting the join entity in our ",(0,o.jsx)(t.code,{children:"itemtags"})," database table using the ",(0,o.jsx)(t.code,{children:"joinId"})," variable."]}),"\n",(0,o.jsxs)(t.p,{children:["Also notice that we pass in two arguments to our ",(0,o.jsx)(t.code,{children:"BeginForm()"}),' method. The first argument is the route method that we\'d like to invoke and the second argument is the controller (note that .NET appends "Controller" to whatever string you pass in). Previously we did not include these arguments to ',(0,o.jsx)(t.code,{children:"BeginForm()"}),". That's because we relied on the default routing that the ",(0,o.jsx)(t.code,{children:"BeginForm()"})," HTML helper provides, which is to route to the controller action that matches the current URL. In the case of ",(0,o.jsx)(t.code,{children:"Tags/Details"}),", that would be the ",(0,o.jsx)(t.code,{children:"Details()"})," action in the ",(0,o.jsx)(t.code,{children:"TagsController"}),". However, we want to route to the ",(0,o.jsx)(t.code,{children:"DeleteJoin()"})," action, which is why we specify this explicitly in ",(0,o.jsx)(t.code,{children:'@using (Html.BeginForm("DeleteJoin", "Tags"))'}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Next, let's see how we'll place this form within ",(0,o.jsx)(t.code,{children:"View/Tags/Details.cshtml"}),". Here's what our code should look like now:"]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"Views/Tags/Details.cshtml"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-html",children:'@{\n  Layout = "_Layout";\n}\n\n@using ToDoList.Models\n@model ToDoList.Models.Tag\n\n<h2>Tag Details</h2>\n<hr />\n<h3>@Html.DisplayNameFor(model => model.Title): @Html.DisplayFor(model => model.Title)</h3>\n\n@if(@Model.JoinEntities.Count == 0)\n{\n  <p>This tag does not belong to any items</p>\n}\nelse\n{\n  <h4>Items the tag belongs to:</h4>\n  <ul>\n  @foreach(ItemTag join in Model.JoinEntities)\n  {\n    <li>@join.Item.Description</li>\n    @using (Html.BeginForm("DeleteJoin", "Tags"))\n    {\n      @Html.Hidden("joinId", @join.ItemTagId)\n      <input type="submit" value="Delete"/>\n    }\n  }\n  </ul>\n}\n\n<p>@Html.ActionLink("Back to list", "Index")</p>\n<p>@Html.ActionLink("Add an Item", "AddItem", new { id = Model.TagId })</p>\n<p>@Html.ActionLink("Edit Tag", "Edit", new { id = Model.TagId })</p>\n<p>@Html.ActionLink("Delete Tag", "Delete", new { id = Model.TagId })</p>\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Notice that we've added the new form/button below each join entity. That means there will be a separate button created for each join entity listed on the tag's details page, each with a unique ",(0,o.jsx)(t.code,{children:"joinId"})," value."]}),"\n",(0,o.jsxs)(t.p,{children:["Next, let's create the ",(0,o.jsx)(t.code,{children:"DeleteJoin()"})," action in the ",(0,o.jsx)(t.code,{children:"TagsController.cs"}),". Here's the new code we'll add:"]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"Controllers/TagsController.cs"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:'...\n\n    [HttpPost]\n    public ActionResult DeleteJoin(int joinId)\n    {\n      ItemTag joinEntry = _db.ItemTags.FirstOrDefault(entry => entry.ItemTagId == joinId);\n      _db.ItemTags.Remove(joinEntry);\n      _db.SaveChanges();\n      return RedirectToAction("Index");\n    }\n\n...\n'})}),"\n",(0,o.jsxs)(t.p,{children:["The code to remove a database entry should look familiar, with the only difference being that we're going into the ",(0,o.jsx)(t.code,{children:"ItemTags"})," database table. Note that the ",(0,o.jsx)(t.code,{children:"DeleteJoin()"})," action will find the entry in the join table by using the join entry's ",(0,o.jsx)(t.code,{children:"ItemTagId"}),". The ",(0,o.jsx)(t.code,{children:"ItemTagId"})," is being passed in through the variable ",(0,o.jsx)(t.code,{children:"joinId"})," in our action's parameter and came from the ",(0,o.jsx)(t.code,{children:"BeginForm()"})," HTML helper method in our details view."]}),"\n",(0,o.jsxs)(t.p,{children:["Note that we've called our action ",(0,o.jsx)(t.code,{children:"DeleteJoin()"})," because it handles deleting an ",(0,o.jsx)(t.code,{children:"ItemTag"})," join relationship. However we could name this route something more specific if we prefer, like ",(0,o.jsx)(t.code,{children:"DeleteItemTagJoin"}),", or if we happen to have multiple many-to-many relationships."]}),"\n",(0,o.jsxs)(t.h3,{id:"joinid-and-route-configuration-in-programcs",children:[(0,o.jsx)(t.code,{children:"joinId"})," and Route Configuration in ",(0,o.jsx)(t.code,{children:"Program.cs"})]}),"\n",(0,o.jsxs)(t.p,{children:["We use the name ",(0,o.jsx)(t.code,{children:"joinId"})," in the ",(0,o.jsx)(t.code,{children:"DeleteJoin()"})," route instead of ",(0,o.jsx)(t.code,{children:"id"})," because .NET automatically utilizes the value in the URL query if we name the variable ",(0,o.jsx)(t.code,{children:"id"}),". For example, if we named the parameter ",(0,o.jsx)(t.code,{children:"id"})," instead of ",(0,o.jsx)(t.code,{children:"joinId"})," and the details URL was something like ",(0,o.jsx)(t.code,{children:"/Items/Details/6"}),", then the value of ",(0,o.jsx)(t.code,{children:"id"})," would be 6, which is the ",(0,o.jsx)(t.code,{children:"ItemId"})," and not the ",(0,o.jsx)(t.code,{children:"ItemTagId"})," that we wanted from our ",(0,o.jsx)(t.code,{children:"Hidden()"})," method."]}),"\n",(0,o.jsxs)(t.p,{children:["The reason .NET uses this convention is due to our configuration in the ",(0,o.jsx)(t.code,{children:"Program.cs"})," file. Take a look at the following code in the ",(0,o.jsx)(t.code,{children:"Program.cs"})," file:"]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"ToDoList/Program.cs"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:'...\n      app.MapControllerRoute(\n          name: "default",\n          pattern: "{controller=Home}/{action=Index}/{id?}"\n        );\n...\n'})}),"\n",(0,o.jsxs)(t.p,{children:["The template option tells .NET how to treat routes. This configuration, known as ",(0,o.jsx)(t.strong,{children:"conventional routing"}),", matches a path like ",(0,o.jsx)(t.code,{children:"/Items/Details/6"})," to its specific controller action by looking for the ",(0,o.jsx)(t.code,{children:"Details"})," action route in the ",(0,o.jsx)(t.code,{children:"Items"})," controller. Then it binds the value of 6 to the ",(0,o.jsx)(t.code,{children:"id"})," variable. We won't change routes in this class, but be aware that .NET routing conventions can be configured. If you're interested in learning more, check out the ",(0,o.jsx)(t.a,{href:"https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-6.0",children:"documentation on the subject."})]}),"\n",(0,o.jsxs)(t.h3,{id:"updating-the-itemscontroller-and-detailscshtml-view-to-delete-join-entities",children:["Updating the ",(0,o.jsx)(t.code,{children:"ItemsController"})," and ",(0,o.jsx)(t.code,{children:"Details.cshtml"})," View to Delete Join Entities"]}),"\n",(0,o.jsx)(t.p,{children:"Next, we'll add the same delete button and controller action to our items. The process will be the exact same as with tags, except different naming to reflect that we're in the items controller and views."}),"\n",(0,o.jsxs)(t.p,{children:["Let's start with the controller action this time. Within ",(0,o.jsx)(t.code,{children:"ItemsController.cs"}),", add the following new route:"]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"Controllers/ItemsController.cs"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:'...\n\n    [HttpPost]\n    public ActionResult DeleteJoin(int joinId)\n    {\n      ItemTag joinEntry = _db.ItemTags.FirstOrDefault(entry => entry.ItemTagId == joinId);\n      _db.ItemTags.Remove(joinEntry);\n      _db.SaveChanges();\n      return RedirectToAction("Index");\n    }\n\n...\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Next, let's update the ",(0,o.jsx)(t.code,{children:"Views/Items/Details.cshtml"})," to include a new form and button for each join entity listed for the item:"]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"Views/Items/Details.cshtml"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-html",children:'@{\n  Layout = "_Layout";\n}\n\n@using ToDoList.Models\n@model ToDoList.Models.Item\n\n<h2>Item Details</h2>\n<hr />\n<h3>@Html.DisplayNameFor(model => model.Description): @Html.DisplayFor(model => model.Description)</h3>  \n<h3>@Html.DisplayNameFor(model => model.Category): @Html.DisplayFor(model => model.Category.Name)</h3>\n\n@if(@Model.JoinEntities.Count == 0)\n{\n  <p>This item does not have any tags yet!</p>\n}\nelse\n{\n  <h4>This item has the following tags:</h4>\n  <ul>\n    @foreach(ItemTag join in Model.JoinEntities)\n    {\n      <li>Tag: @join.Tag.Title</li>\n      @using (Html.BeginForm("DeleteJoin", "Items"))\n      {\n        @Html.Hidden("joinId", @join.ItemTagId)\n        <input type="submit" value="Delete"/>\n      }\n    }\n  </ul>\n}\n\n<p>@Html.ActionLink("Back to list", "Index")</p>\n<p>@Html.ActionLink("Edit Item or Category", "Edit", new { id = Model.ItemId })</p>\n<p>@Html.ActionLink("Add a Tag", "AddTag", new { id = Model.ItemId })</p>\n<p>@Html.ActionLink("Delete Item", "Delete", new { id = Model.ItemId })</p>\n'})}),"\n",(0,o.jsxs)(t.p,{children:["And with that, we've completed CRUD for tags and CRD for our ",(0,o.jsx)(t.code,{children:"ItemTag"})," many-to-many join entity. Start your To Do List's server and check out the completed functionality in the browser!"]}),"\n",(0,o.jsx)(t.h3,{id:"repository-reference",children:"Repository Reference"}),"\n",(0,o.jsx)(t.p,{children:"Follow the link below to view how a sample version of the project should look at this point. Note that this is a link to a specific branch in the repository."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:(0,o.jsxs)(t.a,{href:"https://github.com/epicodus-lessons/section-4-to-do-list-with-many-to-many-csharp-net6/tree/4_m2m_update_and_delete",children:[(0,o.jsx)(t.i,{className:"glyphicon glyphicon-folder-open"}),"  GitHub Repo for To Do List with EF Core Migrations and a Many-to-Many Relationship: 4_m2m_update_and_delete"]})})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(r,{...e})}):r(e)}}}]);