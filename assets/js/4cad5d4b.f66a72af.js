"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[94794],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var a=n(96540);const i={},o=a.createContext(i);function s(e){const t=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(o.Provider,{value:t},e.children)}},80782:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"react/functional-programming-with-javascript/4-1-1-10-building-a-functional-application-part-2","title":"\ud83d\udcd3 4.1.1.10 Building a Functional Application (Part 2)","description":"In the last lesson, we built a function factory for incrementing a plant\'s attributes. However, we still have no place to save that information. If we wanted this application to be truly functional, we could retrieve the state from the DOM when we need to update it. Feel free to try this approach in class \u2014 but don\'t forget that it\'s not very efficient to query the DOM!","source":"@site/docs/4_react/1_functional-programming-with-javascript/4-1-1-10-building-a-functional-application-part-2.md","sourceDirName":"4_react/1_functional-programming-with-javascript","slug":"/react/functional-programming-with-javascript/4-1-1-10-building-a-functional-application-part-2","permalink":"/v1.2/react/functional-programming-with-javascript/4-1-1-10-building-a-functional-application-part-2","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 4.1.1.10 Building a Functional Application (Part 2)","day":"monday","id":"4-1-1-10-building-a-functional-application-part-2","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 4.1.1.9 Building a Functional Application (Part 1)","permalink":"/v1.2/react/functional-programming-with-javascript/4-1-1-9-building-a-functional-application-part-1"},"next":{"title":"\ud83d\udcd3 4.1.1.11 Addressing Implicit Bias","permalink":"/v1.2/react/functional-programming-with-javascript/4-1-1-11-addressing-implicit-bias"}}');var i=n(74848),o=n(28453);const s={title:"\ud83d\udcd3 4.1.1.10 Building a Functional Application (Part 2)",day:"monday",id:"4-1-1-10-building-a-functional-application-part-2",hide_table_of_contents:!0},r=void 0,c={},l=[{value:"Bringing It All Together",id:"bringing-it-all-together",level:2}];function d(e){const t={code:"code",div:"div",em:"em",h2:"h2",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"In the last lesson, we built a function factory for incrementing a plant's attributes. However, we still have no place to save that information. If we wanted this application to be truly functional, we could retrieve the state from the DOM when we need to update it. Feel free to try this approach in class \u2014 but don't forget that it's not very efficient to query the DOM!"}),"\n",(0,i.jsx)(t.p,{children:"We are going to store our state inside a function. This approach will give us more practice with closures, one of the most important concepts we can understand in terms of taking our skills to the next level. Note that this lesson contains more challenging content. We recommend reading it several times, carefully recreating the code in class, and being patient with yourself."}),"\n",(0,i.jsx)(t.p,{children:"Here's our function for storing state. Note that all the function names are abstracted. We could potentially reuse this function elsewhere as needed, too."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const storeState = () => {\n  let currentState = {};\n  return (stateChangeFunction) => {\n    const newState = stateChangeFunction(currentState);\n    currentState = {...newState};\n    return newState;\n  }\n}\n"})}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["First, our outer function is stored in the constant ",(0,i.jsx)(t.code,{children:"storeState"}),". It does not take an argument. The only job of the outer function is to store the ",(0,i.jsx)(t.code,{children:"currentState"})," of an object."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"currentState"})," of an object will be initialized as a ",(0,i.jsx)(t.code,{children:"{}"}),". Note that we use ",(0,i.jsx)(t.code,{children:"let"})," because the ",(0,i.jsx)(t.code,{children:"currentState"})," will be mutated each time the inner function is called."]}),"\n",(0,i.jsxs)(t.li,{children:["Our outer function returns an anonymous inner function that takes one parameter called ",(0,i.jsx)(t.code,{children:"stateChangeFunction"}),". This inner function will take a function as an argument. We can do this because functions are first-class citizens in JavaScript. The function that we pass in will specify the exact change that should be made to ",(0,i.jsx)(t.code,{children:"currentState"}),". Note that we've already written the function that will be passed in as an argument \u2014 we will demonstrate how it works soon."]}),"\n",(0,i.jsxs)(t.li,{children:["The line ",(0,i.jsx)(t.code,{children:"const newState = stateChangeFunction(currentState);"})," will take the function we pass in as an argument and then call it on ",(0,i.jsx)(t.code,{children:"currentState"}),". Instead of mutating ",(0,i.jsx)(t.code,{children:"currentState"}),", we will save the new state in a constant called ",(0,i.jsx)(t.code,{children:"newState"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["Now it's time to break the rules. We are going to need to update the ",(0,i.jsx)(t.code,{children:"currentState"}),". We will make a copy of ",(0,i.jsx)(t.code,{children:"newState"})," and assign it to ",(0,i.jsx)(t.code,{children:"currentState"}),". (This is similar to what React does with its ",(0,i.jsx)(t.code,{children:"setState()"})," method. We'll learn about ",(0,i.jsx)(t.code,{children:"setState()"})," in the next course section.)"]}),"\n",(0,i.jsxs)(t.li,{children:["Finally, our inner function will return the ",(0,i.jsx)(t.code,{children:"newState"}),". Why are we returning ",(0,i.jsx)(t.code,{children:"newState"})," instead of ",(0,i.jsx)(t.code,{children:"currentState"}),"? Well, in this particular use case, it doesn't matter which we do because both ",(0,i.jsx)(t.code,{children:"newState"})," and ",(0,i.jsx)(t.code,{children:"currentState"})," are equal. In a basic React application, we'd update the state and then return that state. In that case, it makes more sense to return ",(0,i.jsx)(t.code,{children:"currentState"}),". But here's another interesting use case which we'll learn about in a few weeks when we use Firestore, a cloud database solution. With Firestore, we might think of ",(0,i.jsx)(t.code,{children:"currentState"})," as being the state of our database. However, because it takes time to update and return ",(0,i.jsx)(t.code,{children:"currentState"})," (an async operation), we can provide a quick snapshot of state to users by just returning the equivalent of ",(0,i.jsx)(t.code,{children:"newState"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Next, we will need to store our function in another constant like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const stateControl = storeState();\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Here, we are actually invoking the ",(0,i.jsx)(t.code,{children:"storeState()"})," function and creating a closure over the ",(0,i.jsx)(t.code,{children:"currentState"})," variable in the outer function."]}),"\n",(0,i.jsxs)(t.p,{children:["Why are we calling it ",(0,i.jsx)(t.code,{children:"stateControl"})," instead of something like ",(0,i.jsx)(t.code,{children:"stateChanger"}),"? Well, we might also just want to ",(0,i.jsx)(t.em,{children:"look"})," at the current state \u2014 not change it \u2014 so ",(0,i.jsx)(t.code,{children:"stateChanger"})," wouldn't be the best name in that situation."]}),"\n",(0,i.jsxs)(t.p,{children:["Let's take a look at the value of ",(0,i.jsx)(t.code,{children:"stateControl"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"(stateChangeFunction) => {\n  const newState = stateChangeFunction(currentState);\n  currentState = {...newState};\n  return newState;\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["As we can see, ",(0,i.jsx)(t.code,{children:"stateControl"})," holds the inner function. It also retains the ",(0,i.jsx)(t.code,{children:"currentState"})," variable from the outer function. When ",(0,i.jsx)(t.code,{children:"storeState()"})," is called and stored in the ",(0,i.jsx)(t.code,{children:"stateControl"})," variable, ",(0,i.jsx)(t.code,{children:"currentState"})," is set to ",(0,i.jsx)(t.code,{children:"{}"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Now let's try passing one of our feeding functions into ",(0,i.jsx)(t.code,{children:"stateControl"}),". Specifically, we'll pass in the feeding function ",(0,i.jsx)(t.code,{children:"blueFood()"})," which we created in the last lesson. This function increments the food level of a plant by 5."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const fedPlant = stateControl(blueFood);\n> { soil: 5 }\n"})}),"\n",(0,i.jsx)(t.p,{children:"Here's what just happened:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["We passed in the variable ",(0,i.jsx)(t.code,{children:"blueFood"})," into ",(0,i.jsx)(t.code,{children:"stateControl"}),". This invokes the inner function inside ",(0,i.jsx)(t.code,{children:"storeState()"}),". (Be careful here \u2014 we don't want to pass in ",(0,i.jsx)(t.code,{children:"blueFood()"})," because we don't want the function to be invoked yet!)"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"blueFood"})," is passed in as an argument for the ",(0,i.jsx)(t.code,{children:"stateChangeFunction"})," parameter. Now ",(0,i.jsx)(t.code,{children:"const newState = blueFood(currentState);"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["When ",(0,i.jsx)(t.code,{children:"blueFood(currentState)"})," is called, it invokes the following function:"]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:'(state) => ({\n  ...state,\n  ["soil"] : (state["soil"] || 0) + 5\n})\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Remember that ",(0,i.jsx)(t.code,{children:"5"})," replaces the ",(0,i.jsx)(t.code,{children:"value"})," variable and ",(0,i.jsx)(t.code,{children:'"soil"'})," replaces the ",(0,i.jsx)(t.code,{children:"prop"})," variable because ",(0,i.jsx)(t.code,{children:"blueFood"})," increments ",(0,i.jsx)(t.code,{children:"soil"})," by 5. If this isn't clear, you may want to review how we used a curried function in the last lesson to create ",(0,i.jsx)(t.code,{children:"blueFood"})," in the first place."]}),"\n",(0,i.jsxs)(t.ol,{start:"4",children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"currentState"})," is passed into the ",(0,i.jsx)(t.code,{children:"state"})," parameter. Because ",(0,i.jsx)(t.code,{children:"currentState"})," doesn't have a ",(0,i.jsx)(t.code,{children:"soil"})," property yet, it defaults to ",(0,i.jsx)(t.code,{children:"0"})," before ",(0,i.jsx)(t.code,{children:"5"})," is added. This is because we are using the ",(0,i.jsx)(t.code,{children:"||"})," operator to ensure the default value of the ",(0,i.jsx)(t.code,{children:"soil"})," property is 0 if it hasn't been defined."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Now, if we pass in ",(0,i.jsx)(t.code,{children:"greenFood"}),", we'll get the following:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const plantFedAgain = stateControl(greenFood);\n> { soil: 15 }\n"})}),"\n",(0,i.jsx)(t.p,{children:"Our function is successfully storing the plant's state!"}),"\n",(0,i.jsxs)(t.p,{children:["As you can see in the example above, ",(0,i.jsx)(t.code,{children:"plantFedAgain"})," only has a ",(0,i.jsx)(t.code,{children:"soil"})," property. That's because our ",(0,i.jsx)(t.code,{children:"currentState"})," variable begins as an empty object. We could do the following to initialize the plant with all three properties:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const storeState = () => {\n  let currentState = { soil: 0, light: 0, water: 0 }; //Small change made to function here.\n  return (stateChangeFunction) => {\n    const newState = stateChangeFunction(currentState);\n    currentState = {...newState};\n    return newState;\n  }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"While the version above will work for our small application, it's not very reusable. What if we eventually want to add other attributes or use it for other kinds of objects entirely?"}),"\n",(0,i.jsxs)(t.p,{children:["We could also give the outer function a parameter like ",(0,i.jsx)(t.code,{children:"initialState"})," and do the following:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const storeState = (initialState) => {\n  let currentState = initialState; // We could pass in an initial state to the object instead of starting with an empty object as well.\n  return (stateChangeFunction) => {\n    const newState = stateChangeFunction(currentState);\n    currentState = {...newState};\n    return newState;\n  }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This would work correctly. However, for our use case, it won't be necessary for our plant to start with any properties. You may find that you need to set an initial value when you practice building out applications using closures in class. For instance, let's say your application has multiple different plants, each with different starting attributes. You'd need to pass in the ",(0,i.jsx)(t.code,{children:"initialState"})," of the object to set its properties as we do in the example above."]}),"\n",(0,i.jsxs)(t.p,{children:["A note worth mentioning again: it is very important that we pass in a variable holding a function into ",(0,i.jsx)(t.code,{children:"stateControl"})," and ",(0,i.jsx)(t.strong,{children:"not"})," the invoked function. This would not work:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:'const blueFood = changeState("soil")(5);\n\nconst fedPlant = stateControl(blueFood());\n\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Specifically, passing in ",(0,i.jsx)(t.code,{children:"blueFood()"})," as an argument to ",(0,i.jsx)(t.code,{children:"stateControl()"})," won't work: ",(0,i.jsx)(t.code,{children:"stateControl(blueFood());"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Why? ",(0,i.jsx)(t.code,{children:"blueFood"})," needs to take the ",(0,i.jsx)(t.code,{children:"currentState"})," as an argument, and can only do so inside the body of the ",(0,i.jsx)(t.code,{children:"storeState"})," function itself. If we invoke the ",(0,i.jsx)(t.code,{children:"blueFood"})," function too early without an argument like we did above, we'll get an error:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"Uncaught TypeError: Cannot read property 'soil' of undefined\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This is because the ",(0,i.jsx)(t.code,{children:"blueFood"})," function expects to be given an object as an agrument. This would be a good reason to add some error handling to the function to deal with this use case. Try doing so in your own applications!"]}),"\n",(0,i.jsx)(t.p,{children:"Before we move on, there is one other important issue we might want to cover \u2014 it's not necessarily as relevant in this little plant application but it will likely be something you'll want to access in projects during this section."}),"\n",(0,i.jsx)(t.p,{children:"We've covered how to change state \u2014 but what if we just want to access it but not change it?"}),"\n",(0,i.jsxs)(t.p,{children:["Well, let's look at our ",(0,i.jsx)(t.code,{children:"storeState"})," function literal again:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const storeState = () => {\n  let currentState = {};\n  return (stateChangeFunction) => {\n    const newState = stateChangeFunction(currentState);\n    currentState = {...newState};\n    return newState;\n  }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We know that we need to do something with this particular function in order to see the state because this is where our ",(0,i.jsx)(t.code,{children:"currentState"})," is enclosed \u2014 there's no way to access it other than this function!"]}),"\n",(0,i.jsxs)(t.p,{children:["Well, in this case, we just need the ",(0,i.jsx)(t.code,{children:"stateChangeFunction"})," be a function that takes the original state and then returns it. In other words, the ",(0,i.jsx)(t.code,{children:"stateChangeFunction"})," needs to be the following:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"state => state\n"})}),"\n",(0,i.jsx)(t.p,{children:"Well, it would be a bit annoying to have to pass that in wherever we want to see the current state. However, we can do something else \u2014 since functions are first class citizens, we can pass this in as a default parameter like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const storeState = () => {\n  let currentState = {};\n  return (stateChangeFunction = state => state) => {\n    const newState = stateChangeFunction(currentState);\n    currentState = {...newState};\n    return newState;\n  }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"Here's the change:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"return (stateChangeFunction = state => state)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["It may look strange, but what we are saying here is that if ",(0,i.jsx)(t.code,{children:"stateChangeFunction"})," is ",(0,i.jsx)(t.code,{children:"undefined"})," (no argument is passed in), the ",(0,i.jsx)(t.code,{children:"stateChangeFunction"})," should be ",(0,i.jsx)(t.code,{children:"state => state"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["That means all we need to do is call ",(0,i.jsx)(t.code,{children:"stateControl()"})," (without arguments) in order to just return the current state!"]}),"\n",(0,i.jsx)(t.h2,{id:"bringing-it-all-together",children:"Bringing It All Together"}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.p,{children:"Finally, here's how we could implement this in the browser. This example has been kept very simple and can only increment soil. This example does not include webpack, testing, or separation of logic. Try adding this functionality on your own. Note also that manipulating the DOM will always lead to functions that produce side effects. There's no way around it!"}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"plant.js"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"// This function stores our state.\nconst storeState = () => {\n    let currentState = {};\n    return (stateChangeFunction = state => state) => {\n      const newState = stateChangeFunction(currentState);\n      currentState = {...newState};\n      return newState;\n    }\n  }\n  \nconst stateControl = storeState();\n\n// This is a function factory. \n// We can easily create more specific functions that \n// alter a plant's soil, water, and light to varying degrees.\nconst changeState = (prop) => {\n  return (value) => {\n    return (state) => ({\n      ...state,\n      [prop] : (state[prop] || 0) + value\n    })\n  }\n}\n\n// We create four functions using our function factory. \n// We could easily create many more.\nconst feed = changeState(\"soil\")(1);\nconst blueFood = changeState(\"soil\")(5);\n\nconst hydrate = changeState(\"water\")(1);\nconst superWater = changeState(\"water\")(5);\n\nwindow.onload = function() {\n\n  // This function has side effects because we are manipulating the DOM.\n  // Manipulating the DOM will always be a side effect. \n  // Note that we only use one of our functions to alter soil. \n  // You can easily add more.\n  document.getElementById('feed').onclick = function() {\n    const newState = stateControl(blueFood);\n    document.getElementById('soil-value').innerText = `Soil: ${newState.soil}`;\n  };\n\n  // This function doesn't actually do anything useful in this application \n  // \u2014 it just demonstrates how we can \"look\" at the current state \n  // (which the DOM is holding anyway). \n  // However, students often do need the ability to see the current state \n  // without changing it so it's included here for reference.\n  document.getElementById('show-state').onclick = function() {\n    // We just need to call stateControl() without arguments \n    // to see our current state.\n    const currentState = stateControl();\n    document.getElementById('soil-value').innerText = `Soil: ${currentState.soil}`;\n  };\n};\n"})}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"index.html"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-html",children:'<html>\n  <head>\n    <script type="text/javascript" src="plant.js"><\/script>\n    <title>Grow Your Plant</title>\n  </head>\n  <body>\n    <button id="feed">Add soil</button>\n    <button id="show-state">Current Stats</button>\n    <h1>Your Plant\'s Values</h1>\n    <h3><div id="soil-value">0</div></h3>\n  </body>\n</html>\n'})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);