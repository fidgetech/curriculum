"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[36944],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(96540);const s={},l=i.createContext(s);function a(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(l.Provider,{value:n},e.children)}},71577:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"c-and-net/lessons-19-31-basic-console-apps/3-0-0-27-static-class-members","title":"\ud83d\udcd3 3.0.0.27 Static Class Members","description":"We\'ve learned how to create and call instance class members, which are called on an object of a specific type. We also learned how to call built-in static methods, which are called on the class, like Console.WriteLine(). In this lesson, we\'ll complete our practice with static and instance class members by adding a static field and method to our Triangle class. Since we\'ll continue to make our fields private and expose public methods to access the fields, this will be another example of encapsulation.","source":"@site/versioned_docs/version-v1_3/3_c-and-net/0_lessons-19-31-basic-console-apps/3-0-0-27-static-class-members.md","sourceDirName":"3_c-and-net/0_lessons-19-31-basic-console-apps","slug":"/c-and-net/lessons-19-31-basic-console-apps/3-0-0-27-static-class-members","permalink":"/v1.3/c-and-net/lessons-19-31-basic-console-apps/3-0-0-27-static-class-members","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 3.0.0.27 Static Class Members","day":"weekend","id":"3-0-0-27-static-class-members","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.0.0.26 APIE: Encapsulation","permalink":"/v1.3/c-and-net/lessons-19-31-basic-console-apps/3-0-0-26-apie-encapsulation"},"next":{"title":"\ud83d\udcd3 3.0.0.28 Creating a User Interface for a Console App","permalink":"/v1.3/c-and-net/lessons-19-31-basic-console-apps/3-0-0-28-creating-a-user-interface-for-a-console-app"}}');var s=t(74848),l=t(28453);const a={title:"\ud83d\udcd3 3.0.0.27 Static Class Members",day:"weekend",id:"3-0-0-27-static-class-members",hide_table_of_contents:!0},r=void 0,c={},o=[{value:"Static Field",id:"static-field",level:2},{value:"Updating the Constructor",id:"updating-the-constructor",level:2},{value:"Static Method",id:"static-method",level:2},{value:"<code>Triangle.GetAll()</code>",id:"trianglegetall",level:3},{value:"<code>Triangle.ClearAll()</code>",id:"triangleclearall",level:3},{value:"Using Static Methods",id:"using-static-methods",level:2},{value:"Repository Reference",id:"repository-reference",level:3}];function d(e){const n={a:"a",code:"code",div:"div",h2:"h2",h3:"h3",hr:"hr",i:"i",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["We've learned how to create and call ",(0,s.jsx)(n.strong,{children:"instance"})," class members, which are called on an object of a specific type. We also learned how to call built-in ",(0,s.jsx)(n.strong,{children:"static"})," methods, which are called on the class, like ",(0,s.jsx)(n.code,{children:"Console.WriteLine()"}),". In this lesson, we'll complete our practice with static and instance class members by adding a static field and method to our ",(0,s.jsx)(n.code,{children:"Triangle"})," class. Since we'll continue to make our fields private and expose public methods to access the fields, this will be another example of encapsulation."]}),"\n",(0,s.jsxs)(n.p,{children:["When we create a static field or method, it should contain data or perform functionality that's relevant to the entire class. Alternatively we might design a class that only has static members, because there's no need to ever create an instance of the class; a good example of this is ",(0,s.jsxs)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.math?view=net-6.0",children:["the ",(0,s.jsx)(n.code,{children:"Math"})," class"]}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["We do want to create instances of the ",(0,s.jsx)(n.code,{children:"Triangle"})," class, so we'll want to create a field or method that's relevant to the entire class. Given these goals, let's create a new field called ",(0,s.jsx)(n.code,{children:"_instances"})," that will hold a list of all ",(0,s.jsx)(n.code,{children:"Triangle"})," objects ever created, and two methods that will allow us to access and clear the list."]}),"\n",(0,s.jsx)(n.p,{children:"Let's get into it!"}),"\n",(0,s.jsx)(n.h2,{id:"static-field",children:"Static Field"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["To create a static field, we simply need to use the ",(0,s.jsx)(n.code,{children:"static"})," keyword. Here's how we'll create our new ",(0,s.jsx)(n.code,{children:"_instances"})," field:"]}),"\n",(0,s.jsx)(n.div,{className:"filename",children:"Models/Triangle.cs"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"using System.Collections.Generic; // new using directive\n\nnamespace ShapeTracker.Models \n{\n  public class Triangle \n  {\n    private int _side1;\n    private int _side2;\n    private int _side3;\n    private static List<Triangle> _instances = new List<Triangle> {};\n\n    ... // other code omitted for brevity\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["First notice that we've added a new using directive for the namespace ",(0,s.jsx)(n.code,{children:"System.Collections.Generic"}),". The class ",(0,s.jsx)(n.code,{children:"List<T>"})," lives inside the ",(0,s.jsx)(n.code,{children:"System.Collections.Generic"})," namespace, so we need to make sure to import the namespace into our file before we can use ",(0,s.jsx)(n.code,{children:"List<T>"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Next, notice our new field ",(0,s.jsx)(n.code,{children:"_instances"}),". We declare ",(0,s.jsx)(n.code,{children:"_instances"})," as ",(0,s.jsx)(n.code,{children:"private"})," and ",(0,s.jsx)(n.code,{children:"static"})," and we give it a type of ",(0,s.jsx)(n.code,{children:"List<Triangle>"})," (a list of triangle objects)."]}),"\n",(0,s.jsxs)(n.p,{children:["We then use the assignment operator ",(0,s.jsx)(n.code,{children:"="})," to give ",(0,s.jsx)(n.code,{children:"_instances"})," an initial value of an empty list of triangle objects."]}),"\n",(0,s.jsx)(n.p,{children:"Next, let's update our constructor to add new triangle objects directly to our static list."}),"\n",(0,s.jsx)(n.h2,{id:"updating-the-constructor",children:"Updating the Constructor"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["We can use the keyword ",(0,s.jsx)(n.code,{children:"this"})," within our constructor to reference the object instance that's being created. Let's see how this works:"]}),"\n",(0,s.jsx)(n.div,{className:"filename",children:"Models/Triangle.cs"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"namespace ShapeTracker.Models \n{\n  public class Triangle \n  {\n    private int _side1;\n    private int _side2;\n    private int _side3;\n    private static List<Triangle> _instances = new List<Triangle> {};\n\n    public Triangle(int length1, int length2, int length3) \n    {\n      _side1 = length1;\n      _side2 = length2;\n      _side3 = length3;\n      _instance.Add(this);  // new code\n    }\n\n    ... // other code omitted for brevity\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["First of all, we call ",(0,s.jsxs)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1.add?view=net-6.0",children:["the built in ",(0,s.jsx)(n.code,{children:"List<T>.Add()"})," method"]})," to add a new element to our list. The argument we pass into the ",(0,s.jsx)(n.code,{children:"Add()"})," method is ",(0,s.jsx)(n.code,{children:"this"}),", the special keyword that represents the object instance that's being created. To learn more about ",(0,s.jsx)(n.code,{children:"this"})," and other ways we can use it, ",(0,s.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this",children:"visit the MS docs"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"static-method",children:"Static Method"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"At this point we have the code in place to populate our list, but we still do not have any tools to access or manage the list outside of our class. So let's do just that. We'll create two public and static methods, one that acts as a getter, and the other that acts as a setter."}),"\n",(0,s.jsx)(n.h3,{id:"trianglegetall",children:(0,s.jsx)(n.code,{children:"Triangle.GetAll()"})}),"\n",(0,s.jsxs)(n.p,{children:["We'll name our static getter method ",(0,s.jsx)(n.code,{children:"Triangle.GetAll()"})," and it will return ",(0,s.jsx)(n.code,{children:"_instances"}),", our list of triangle objects. Here's the new method that we'll add at the end of our file:"]}),"\n",(0,s.jsx)(n.div,{className:"filename",children:"Models/Triangle.cs"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"namespace ShapeTracker.Models \n{\n  public class Triangle \n  {\n    private int _side1;\n    private int _side2;\n    private int _side3;\n    private static List<Triangle> _instances = new List<Triangle> {};\n\n    public Triangle(int length1, int length2, int length3) \n    {\n      _side1 = length1;\n      _side2 = length2;\n      _side3 = length3;\n      _instance.Add(this);  // new code\n    }\n\n    ... // other code omitted for brevity\n\n    public static List<Triangle> GetAll()\n    {\n      return _instances;\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This looks like other getter methods we've created, with two differences:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["We've included the ",(0,s.jsx)(n.code,{children:"static"})," keyword to make this a static method called on the class."]}),"\n",(0,s.jsxs)(n.li,{children:["We're not following the getter naming convention of ",(0,s.jsx)(n.code,{children:"Get"})," + ",(0,s.jsx)(n.code,{children:"NameOfField"})," in Pascal case. Instead of ",(0,s.jsx)(n.code,{children:"GetInstances"}),", we're using the shortened name ",(0,s.jsx)(n.code,{children:"GetAll"}),". Variations like this are fine so long as your code is easy to understand."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"triangleclearall",children:(0,s.jsx)(n.code,{children:"Triangle.ClearAll()"})}),"\n",(0,s.jsxs)(n.p,{children:["Next, let's create a static setter method called ",(0,s.jsx)(n.code,{children:"Triangle.ClearAll()"}),". As the name implies, this method will clear all triangle objects from our list."]}),"\n",(0,s.jsxs)(n.p,{children:["Here's the new method that we'll add below the ",(0,s.jsx)(n.code,{children:"GetAll()"})," method:"]}),"\n",(0,s.jsx)(n.div,{className:"filename",children:"Models/Triangle.cs"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"namespace ShapeTracker.Models \n{\n  public class Triangle \n  {\n    private int _side1;\n    private int _side2;\n    private int _side3;\n    private static List<Triangle> _instances = new List<Triangle> {};\n\n    public Triangle(int length1, int length2, int length3) \n    {\n      _side1 = length1;\n      _side2 = length2;\n      _side3 = length3;\n      _instance.Add(this);  // new code\n    }\n\n    ... // other code omitted for brevity\n\n    public static List<Triangle> GetAll()\n    {\n      return _instances;\n    }\n\n    public static void ClearAll()\n    {\n      _instances.Clear();\n    }\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Since we don't return anything we specify ",(0,s.jsx)(n.code,{children:"void"})," in the ",(0,s.jsx)(n.code,{children:"ClearAll()"})," method signature."]}),"\n",(0,s.jsxs)(n.p,{children:["Within the method body, we call on ",(0,s.jsxs)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1.clear?view=net-6.0",children:["the built in ",(0,s.jsx)(n.code,{children:"List<T>.Clear()"})," method"]}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"using-static-methods",children:"Using Static Methods"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["Now we're ready to put our new methods into practice. In ",(0,s.jsx)(n.code,{children:"Program.cs"}),", let's update the UI logic within the ",(0,s.jsx)(n.code,{children:"Main()"})," method to show the contents of ",(0,s.jsx)(n.code,{children:"_instances"})," after we create two  triangle objects."]}),"\n",(0,s.jsx)(n.div,{className:"filename",children:"Program.cs"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using System;\nusing ShapeTracker.Models;\nusing System.Collections.Generic;  // new using directive!\n\nnamespace ShapeTracker\n{\n  class Program\n  {\n    static void Main()\n    {\n      List<Triangle> allTriangles = Triangle.GetAll();\n      Triangle testTriangle = new Triangle(3,4,5);\n      Triangle secondTriangle = new Triangle(32,74,75);\n      if (allTriangles.Count == 0)\n      {\n        Console.WriteLine("There are no triangles!");\n      }\n      else\n      {\n        Console.WriteLine("----------------------------------");\n        foreach (Triangle tri in allTriangles)\n        {\n          Console.WriteLine($"Side one of the triangle: {tri.GetSide1()}");\n          Console.WriteLine($"Side two of the triangle: {tri.GetSide2()}");\n          Console.WriteLine($"Side three of the triangle: {tri.GetSide3()}");\n          Console.WriteLine("----------------------------------");\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Our user interface logic is a bit more complicated than before, because we're now using branching and a foreach loop. Let's discuss the changes."}),"\n",(0,s.jsx)(n.p,{children:"Towards the top of the file:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Since our new UI logic uses the ",(0,s.jsx)(n.code,{children:"List<T>"})," type, the very first update we make is adding a new using directive for the namespace ",(0,s.jsx)(n.code,{children:"System.Collections.Generic;"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Within the ",(0,s.jsx)(n.code,{children:"Main()"})," method:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["First we call the static ",(0,s.jsx)(n.code,{children:"Triangle.GetAll()"})," method to get our static list of triangle objects. There won't be any triangles in it at this point, but that doesn't matter because the value of the ",(0,s.jsx)(n.code,{children:"allTriangles"})," variable will update as we create new triangles."]}),"\n",(0,s.jsx)(n.li,{children:"Next, we create two new triangle instances."}),"\n",(0,s.jsxs)(n.li,{children:["Then, we run our code through a conditional:\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["In the ",(0,s.jsx)(n.code,{children:"if"}),' statement, we check if our list of triangles is empty, and if so, we show a message saying "There are no triangles!".']}),"\n",(0,s.jsxs)(n.li,{children:["In the ",(0,s.jsx)(n.code,{children:"else"})," statement, we handle all other cases, that is, when there are triangles in our list. If there are triangles, then we loop through the list and print information about each triangle."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The output of the new UI logic will look like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"You have triangles!\n----------------------------------\nSide one of the triangle: 3\nSide two of the triangle: 4\nSide three of the triangle: 5\n----------------------------------\nSide one of the triangle: 32\nSide two of the triangle: 74\nSide three of the triangle: 75\n----------------------------------\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We can update our UI logic to clear the triangles before our ",(0,s.jsx)(n.code,{children:"if"})," statement using the ",(0,s.jsx)(n.code,{children:"Triangle.ClearAll()"})," method:"]}),"\n",(0,s.jsx)(n.div,{className:"filename",children:"Program.cs"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using System;\nusing ShapeTracker.Models;\nusing System.Collections.Generic;\n\nnamespace ShapeTracker\n{\n  class Program\n  {\n    static void Main()\n    {\n      List<Triangle> allTriangles = Triangle.GetAll();\n      Triangle testTriangle = new Triangle(3,4,5);\n      Triangle secondTriangle = new Triangle(32,74,75);\n      // new code below!!\n      Triangle.ClearAll();\n      // new code above!!   \n      if (allTriangles.Count == 0)\n      {\n        Console.WriteLine("There are no triangles!");\n      }\n      else\n      {\n        Console.WriteLine("----------------------------------");\n        foreach (Triangle tri in allTriangles)\n        {\n          Console.WriteLine($"Side one of the triangle: {tri.GetSide1()}");\n          Console.WriteLine($"Side two of the triangle: {tri.GetSide2()}");\n          Console.WriteLine($"Side three of the triangle: {tri.GetSide3()}");\n          Console.WriteLine("----------------------------------");\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"If we do that the terminal output will let us know:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"There are no triangles!\n"})}),"\n",(0,s.jsx)(n.h3,{id:"repository-reference",children:"Repository Reference"}),"\n",(0,s.jsx)(n.p,{children:"Follow the link below to view how a sample version of the project should look at this point. Note that this is a link to a specific branch in the repository."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsxs)(n.a,{href:"https://github.com/epicodus-lessons/prework-shape-tracker-csharp-net6/tree/4_static_class_members",children:[(0,s.jsx)(n.i,{className:"glyphicon glyphicon-folder-open"})," Example GitHub Repo for Shape Tracker: ",(0,s.jsx)(n.code,{children:"4_static_class_members"})]})})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);