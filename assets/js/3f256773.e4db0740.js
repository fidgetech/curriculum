"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[76091],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>k});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var r=a.createContext({}),d=function(e){var t=a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},h=function(e){var t=d(e.components);return a.createElement(r.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,r=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),p=d(n),c=i,k=p["".concat(r,".").concat(c)]||p[c]||u[c]||o;return n?a.createElement(k,l(l({ref:t},h),{},{components:n})):a.createElement(k,l({ref:t},h))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,l=new Array(o);l[0]=c;var s={};for(var r in t)hasOwnProperty.call(t,r)&&(s[r]=t[r]);s.originalType=e,s[p]="string"==typeof e?e:i,l[1]=s;for(var d=2;d<o;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},65390:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=n(87462),i=(n(67294),n(3905));const o={title:"\ud83d\udcd3 Linked Lists",id:"linked-lists",slug:"linked-lists",hide_table_of_contents:!0,sidebar_position:40,day:"thursday",type:"lesson",url:"https://github.com/epicodus-curriculum/capstone/blob/main/linked_lists.md"},l=void 0,s={unversionedId:"capstone/capstone-week-1/linked-lists",id:"capstone/capstone-week-1/linked-lists",title:"\ud83d\udcd3 Linked Lists",description:"In this lesson, we are going to cover a data structure called a linked list. A linked list is a collection of elements that's very different than an array because its elements are not indexed. Instead, a linked list is a collection of nodes that are linked together. Linked lists are commonly either singly linked or doubly linked. In a singly linked list, each element has a link to the next element in a list. In a doubly linked list, each element has a link to both the prior element and the next element.",source:"@site/docs/capstone/1_capstone-week-1/BN-linked-lists.md",sourceDirName:"capstone/1_capstone-week-1",slug:"/capstone/capstone-week-1/linked-lists",permalink:"/v1/capstone/capstone-week-1/linked-lists",draft:!1,tags:[],version:"current",sidebarPosition:40,frontMatter:{title:"\ud83d\udcd3 Linked Lists",id:"linked-lists",slug:"linked-lists",hide_table_of_contents:!0,sidebar_position:40,day:"thursday",type:"lesson",url:"https://github.com/epicodus-curriculum/capstone/blob/main/linked_lists.md"},sidebar:"capstone",previous:{title:"\ud83d\udcd3 Quicksort",permalink:"/v1/capstone/capstone-week-1/quicksort"},next:{title:"\u270f\ufe0f Linked Lists - Exercise",permalink:"/v1/capstone/capstone-week-1/linked-lists---exercise"}},r={},d=[{value:"Advantages of Linked List",id:"advantages-of-linked-list",level:2},{value:"Building a TDD Linked List Application",id:"building-a-tdd-linked-list-application",level:3},{value:"Testing and Writing a <code>Node</code> Class",id:"testing-and-writing-a-node-class",level:3},{value:"Instantiating a Linked List",id:"instantiating-a-linked-list",level:3},{value:"Adding a Head Node to a Linked List",id:"adding-a-head-node-to-a-linked-list",level:3},{value:"Inserting a Node in a Populated Linked List",id:"inserting-a-node-in-a-populated-linked-list",level:3},{value:"Removing a Node from a Linked List",id:"removing-a-node-from-a-linked-list",level:3},{value:"What If the Index to Remove Doesn&#39;t Exist?",id:"what-if-the-index-to-remove-doesnt-exist",level:3}],h={toc:d},p="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In this lesson, we are going to cover a data structure called a ",(0,i.kt)("strong",{parentName:"p"},"linked list"),". A linked list is a collection of elements that's very different than an array because its elements ",(0,i.kt)("em",{parentName:"p"},"are not")," indexed. Instead, a linked list is a collection of nodes that are linked together. Linked lists are commonly either ",(0,i.kt)("strong",{parentName:"p"},"singly linked")," or ",(0,i.kt)("strong",{parentName:"p"},"doubly linked"),". In a singly linked list, each element has a link to the ",(0,i.kt)("em",{parentName:"p"},"next")," element in a list. In a doubly linked list, each element has a link to both the prior element and the next element."),(0,i.kt)("p",null,"Here's a depiction of a linked list with three nodes:"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://learnhowtoprogram.s3.us-west-2.amazonaws.com/computer-science-curriculum-2020/linked_list.png",alt:"A linked list with three nodes."})),(0,i.kt)("p",null,"In this simple depiction, each node has a numerical value (its data) and a ",(0,i.kt)("inlineCode",{parentName:"p"},"next")," property. The first node is the ",(0,i.kt)("strong",{parentName:"p"},"head"),". The node's ",(0,i.kt)("inlineCode",{parentName:"p"},"next")," property is what links it to the next node. In other words, a reference to the next node is stored in the previous node. As you can see, the final node has a ",(0,i.kt)("inlineCode",{parentName:"p"},"next")," property of ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," because there is no node after it that it can link to."),(0,i.kt)("p",null,"In a doubly-linked list, each node would have a ",(0,i.kt)("inlineCode",{parentName:"p"},"previous")," property, too. In a singly-linked list like the one depicted above, we can only navigate the linked list sequentially moving forward \u2014 nodes have no knowledge of the node that's before them, only the ones that come next. It's like being in a conga line where you can only see the person in front of you \u2014 not the person behind you."),(0,i.kt)("p",null,"A linked list can be ordered or unordered. The linked list above is unordered because the values don't increase sequentially."),(0,i.kt)("h2",{id:"advantages-of-linked-list"},"Advantages of Linked List"),(0,i.kt)("p",null,"Why would we ever use a linked list? What advantage do they have over arrays? Well, it is generally more efficient to ",(0,i.kt)("em",{parentName:"p"},"insert")," and ",(0,i.kt)("em",{parentName:"p"},"remove")," elements in a linked list than in an array. We'll discuss why in a moment. However, a linked list must ",(0,i.kt)("em",{parentName:"p"},"sequentially")," go through an array using each node's reference to find the next node. For that reason, it is not efficient to search linked lists. It's the equivalent of doing a linear search from the beginning to the end of an array. The difference with arrays is that there are lots of other effective search algorithms we can use (such as a binary search algorithm) to make searching more efficient."),(0,i.kt)("p",null,"The advantages of linked lists are more obvious in lower-level languages \u2014 so why should we bother to learn this data structure when we have focused on high-level languages at Epicodus? Is there any good reason to learn about them other than the fact that they are considered an essential computer science concept for programmers to know about?"),(0,i.kt)("p",null,"Well, linked lists can have applications in front end JavaScript (even if we might not need to directly create linked lists ourselves). One key example is ",(0,i.kt)("a",{parentName:"p",href:"https://indepth.dev/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree/"},"React's algorithms for rendering graphics, which use linked lists"),"."),(0,i.kt)("p",null,"So why is it faster to insert and remove elements from a linked list than an array?"),(0,i.kt)("p",null,"Well, when we add a node to a linked list, we only need to change two small things to add the node:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"this.next")," property of the new node will become the previous node's ",(0,i.kt)("inlineCode",{parentName:"li"},"this.next")," property. "),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"this.next")," property of the previous node needs to be updated to reference the new node.")),(0,i.kt)("p",null,"So imagine that we insert a node at the head of a linked list that has one million elements. Only two small things need to be changed. On the other hand, if we added an element to the first position of an array, ",(0,i.kt)("em",{parentName:"p"},"all one million elements that come afterwards must be reindexed"),". JavaScript will take care of this for us \u2014 but it won't be nearly as efficient as changing a single node."),(0,i.kt)("p",null,"The same thing is true if we remove a node. We only need to change ",(0,i.kt)("em",{parentName:"p"},"one")," thing to remove a node in a linked list:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The node before the node to be deleted needs a small update: its ",(0,i.kt)("inlineCode",{parentName:"li"},"this.next")," property needs to be updated to ",(0,i.kt)("inlineCode",{parentName:"li"},"this.next.next"),", which is the node that comes directly ",(0,i.kt)("em",{parentName:"li"},"after")," the deleted node. We are essentially removing a link from the middle of a chain and then reattaching the link that came before and after the link that's been removed.")),(0,i.kt)("p",null,"Once again, this is much more efficient than the same process in an array."),(0,i.kt)("p",null,"Let's say, for instance, we are creating an application where we occasionally completely re-render a page. All the elements of that page are stored in an array. Because we'd need to walk through every element in the array anyway (since we are doing a complete re-rendering), this could be a great opportunity for a linked list. Again, because this is a full re-rendering, there's also no need to search the nodes \u2014 yet another bonus point for using a linked list instead of an array. It should be clearer now why React developers took this path for rendering graphics more quickly."),(0,i.kt)("p",null,"As you've probably guessed, we need to be very careful when removing a node from a linked list. If we don't properly attach the previous node to the node that comes after the removed node, ",(0,i.kt)("em",{parentName:"p"},"we'll lose all the data that comes after the removed node"),"."),(0,i.kt)("h3",{id:"building-a-tdd-linked-list-application"},"Building a TDD Linked List Application"),(0,i.kt)("p",null,"Let's look at a basic JavaScript implementation of a linked list. We'll use a test-driven approach to construct our code."),(0,i.kt)("p",null,"Our code will have two classes: ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList"),". An instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList")," will be made up of instances of linked ",(0,i.kt)("inlineCode",{parentName:"p"},"Nodes"),". We'll write methods for adding a node to the end of a linked list and removing a node based on its index. At the end of this lesson, there will be an exercise where you can test and write a few additional methods on your own."),(0,i.kt)("p",null,"Here's the structure of our project:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},".vscode\n__tests__\n  |- linked-list.test.js\n  |_ node.test.js\nsrc\n  |-linked-list.js\n  |_ node.js\n.babelrc\n.gitignore\npackage.json\n")),(0,i.kt)("h3",{id:"testing-and-writing-a-node-class"},"Testing and Writing a ",(0,i.kt)("inlineCode",{parentName:"h3"},"Node")," Class"),(0,i.kt)("p",null,"Let's start with our ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," class. It's not going to need much \u2014 just a constructor. We will keep that constructor very simple. Here's a test:"),(0,i.kt)("div",{class:"filename"},"__tests__/node.test.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"\nimport Node from '../src/node.js';\n\ndescribe('Node', () => {\n\n  test('should correctly create a node', () => {\n    const node = new Node(\"head\");\n    expect(node.data).toEqual(\"head\");\n    expect(node.next).toEqual(null);\n  });\n});\n")),(0,i.kt)("p",null,"When a node is constructed, it should have some data. It will also have a ",(0,i.kt)("inlineCode",{parentName:"p"},"next")," property, though the linked list will take care of setting that up that relationship with other nodes. A node could certainly have a lot more information than this but we'll keep it simple so we can focus on the basic concepts."),(0,i.kt)("p",null,"Now let's get this test passing:"),(0,i.kt)("div",{class:"filename"},"src/node.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"export default class Node {\n  constructor(data) {\n    this.data = data;\n    this.next = null;\n  }\n}\n")),(0,i.kt)("p",null,"That is all we need from our ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," class. Our ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList")," class will take care of everything else."),(0,i.kt)("p",null,"It should be clear from the constructor that this is a singly-linked list since there is a ",(0,i.kt)("inlineCode",{parentName:"p"},"next")," property but no ",(0,i.kt)("inlineCode",{parentName:"p"},"previous")," property."),(0,i.kt)("h3",{id:"instantiating-a-linked-list"},"Instantiating a Linked List"),(0,i.kt)("p",null,"Now we're ready to start coding our ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList")," class. As always, we'll start with the simplest possible behavior. A linked list has a ",(0,i.kt)("strong",{parentName:"p"},"head")," node \u2014 this is the first node in the linked list. That means when we instantiate a linked list, it should include this ",(0,i.kt)("inlineCode",{parentName:"p"},"head")," property."),(0,i.kt)("p",null,"Here's a test:"),(0,i.kt)("div",{class:"filename"},"__tests__/linked-list.test.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"\nimport LinkedList from '../src/linked-list.js';\n\ndescribe('LinkedList', () => {\n\n  test('it should construct a linked list with a head property', () => {\n    let linkedList = new LinkedList();\n    expect(linkedList.head).toEqual(null);\n  });\n\n});\n")),(0,i.kt)("p",null,"Our test is just going to check if a constructed linked list has a ",(0,i.kt)("inlineCode",{parentName:"p"},"head")," property set to ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),". It will be ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," because it's an empty linked list."),(0,i.kt)("p",null,"Here's the constructor to get this test passing:"),(0,i.kt)("div",{class:"filename"},"linked-list.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"export default class LinkedList {\n  constructor() {\n    this.head = null;\n  }\n}\n")),(0,i.kt)("p",null,"The first node that is added to an empty list will become the head. Because the head is the reference point for every other node in a linked list, it's important to be very careful about changing it, especially if different developers need access to the head. For that reason, it's common to make the head immutable by declaring it as a symbol. A ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol"},"symbol")," is a primitive data type that is immutable. We aren't working with other developers here, though, and we'll stay focused on the basic concepts of a linked list, which means we won't do anything special with the head node."),(0,i.kt)("p",null,"Based on this information, it should be clear what needs to happen next. When a node is added to an empty linked list, that node needs to become the head."),(0,i.kt)("h3",{id:"adding-a-head-node-to-a-linked-list"},"Adding a Head Node to a Linked List"),(0,i.kt)("p",null,"Here's a test:"),(0,i.kt)("div",{class:"filename"},"__tests__/linked-list.test.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'...\n  test(\'LinkedList.prototype.insertLast() should add a node at head if a linked list has no head\', () => {\n    let linkedList = new LinkedList();\n    linkedList.insertLast("head");\n    expect(linkedList.head.data).toEqual("head");\n  });\n...\n')),(0,i.kt)("p",null,"We're calling our insertion method ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList.prototype.insertLast(data)")," because it will always insert a node at the end of the list. That means we'll need to traverse through ",(0,i.kt)("em",{parentName:"p"},"each")," node to find the final node to link a new node to. But we aren't there yet! That's why we are using TDD \u2014 to build this up in a simple, manageable way."),(0,i.kt)("p",null,"So what is the simplest implementation to get our new test passing?"),(0,i.kt)("div",{class:"filename"},"linked-list.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"// We'll need to import the Node class so our LinkedList class can instantiate nodes in a linked list.\n\nimport Node from './node.js';\n\nexport default class LinkedList {\n  constructor() {\n    this.head = null;\n  }\n\n  insertLast(data) {\n    const newNode = new Node(data);\n    this.head = newNode;\n  }\n}\n")),(0,i.kt)("p",null,"As you can see, our first implementation is very simple. We instantiate a new node with data that the user passes in. Then we set ",(0,i.kt)("inlineCode",{parentName:"p"},"this.head")," equal to that new node. Our list now has a reference point!"),(0,i.kt)("h3",{id:"inserting-a-node-in-a-populated-linked-list"},"Inserting a Node in a Populated Linked List"),(0,i.kt)("p",null,"So now we are ready for the next behavior. We need to be able to insert a node ",(0,i.kt)("em",{parentName:"p"},"after")," the head node. That means we have to traverse the linked list. We can't rely on a built-in method like ",(0,i.kt)("inlineCode",{parentName:"p"},"Array.prototype.push()")," to add the node."),(0,i.kt)("p",null,"Let's write the test now. We're also going to add a ",(0,i.kt)("inlineCode",{parentName:"p"},"beforeEach()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"afterEach()")," block to clean up our tests a bit."),(0,i.kt)("div",{class:"filename"},"__tests__/linked-list.test.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'import LinkedList from \'../src/linked-list.js\';\n\ndescribe(\'LinkedList\', () => {\n\n  let linkedListWithNodes = new LinkedList();\n\n  beforeEach(() => {\n    linkedListWithNodes.insertLast("node1");\n    linkedListWithNodes.insertLast("node2");\n    linkedListWithNodes.insertLast("node3");\n    linkedListWithNodes.insertLast("node4");\n  });\n\n  afterEach(() => {\n    linkedListWithNodes.head = null;\n  });\n\n  ...\n\n  test(\'LinkedList.prototype.insertLast() should add a node at the end of a linked list\', () => {\n    linkedListWithNodes.insertLast("new last");\n    expect(linkedListWithNodes.head.next.next.next.next.data).toEqual("new last");\n  });\n});\n')),(0,i.kt)("p",null,"We start by creating a new instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList")," called ",(0,i.kt)("inlineCode",{parentName:"p"},"linkedListWithNodes")," that will be available for our tests. Our ",(0,i.kt)("inlineCode",{parentName:"p"},"beforeEach()")," block will add three nodes to ",(0,i.kt)("inlineCode",{parentName:"p"},"linkedListWithNodes"),". Then our ",(0,i.kt)("inlineCode",{parentName:"p"},"afterEach()")," block will set ",(0,i.kt)("inlineCode",{parentName:"p"},"linkedListWithNodes.head = null;"),". This is just some clean up \u2014 removing the head of a linked list is the equivalent of deleting it! This way, we can make sure there's no remnant of the linked list from one test polluting the next test."),(0,i.kt)("p",null,"Now for the test itself. Our method should add a node at the end of our instantiated linked list \u2014 since our linked list already has three nodes, this update to our test will verify that ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList.prototype.insertLast()")," correctly traverses the linked list to the final node and then links a new node to it. ",(0,i.kt)("inlineCode",{parentName:"p"},"linkedListWithNodes.head.next.next.next.next.data")," \u2014 but that is the way we'd verify that our new node has been added at the fifth position of the linked list!"),(0,i.kt)("p",null,"Fortunately, traversing a linked list is pretty simple. Here's our updated method:"),(0,i.kt)("div",{class:"filename"},"linked-list.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"...\ninsertLast(data) {\n  const newNode = new Node(data);\n  if (this.head === null) {\n    this.head = newNode;\n  } else {\n    let currentNode = this.head;\n    while (currentNode.next != null) {\n      currentNode = currentNode.next\n    }\n    currentNode.next = newNode;\n  }\n}\n")),(0,i.kt)("p",null,"The first three lines of code are essentially the same \u2014 we just need to add a conditional so ",(0,i.kt)("inlineCode",{parentName:"p"},"this.head")," is only updated if the list is empty."),(0,i.kt)("p",null,"Now let's look at the code in the ",(0,i.kt)("inlineCode",{parentName:"p"},"else")," statement."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A journey of a thousand nodes begins with a single step \u2014 so we need to start at the head node. We'll create a new variable called ",(0,i.kt)("inlineCode",{parentName:"li"},"currentNode")," which is set to ",(0,i.kt)("inlineCode",{parentName:"li"},"this.head"),"."),(0,i.kt)("li",{parentName:"ul"},"Next, we need to traverse the linked list to the end. We'll do this with a while loop. The loop will run while ",(0,i.kt)("inlineCode",{parentName:"li"},"currentNode.next != null"),". It will take the ",(0,i.kt)("inlineCode",{parentName:"li"},"currentNode.next")," property and update ",(0,i.kt)("inlineCode",{parentName:"li"},"currentNode")," to equal the ",(0,i.kt)("inlineCode",{parentName:"li"},"next")," node. That way, we can traverse the linked list until ",(0,i.kt)("inlineCode",{parentName:"li"},"currentNode.next")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"null"),". At that point, we know we've reached the end of the linked list because there isn't a node at ",(0,i.kt)("inlineCode",{parentName:"li"},"currentNode.next"),".")),(0,i.kt)("p",null,"So the loop ends when ",(0,i.kt)("inlineCode",{parentName:"p"},"currentNode")," is the final node . We simply need to set the ",(0,i.kt)("inlineCode",{parentName:"p"},"currentNode.next")," property to our newly created node to add it to the list."),(0,i.kt)("p",null,"If we run our test, we'll see it passes."),(0,i.kt)("p",null,"Now we're ready to move onto testing and writing a method for removing a node."),(0,i.kt)("h3",{id:"removing-a-node-from-a-linked-list"},"Removing a Node from a Linked List"),(0,i.kt)("p",null,"Removing a node from a linked list is a little more involved. Why is that? Well, in the method we've already written, we just need to keep track of the current node and keep traversing until ",(0,i.kt)("inlineCode",{parentName:"p"},"currentNode.next")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,i.kt)("p",null,"We will still need to keep track of the current node when we remove an item from a linked list. Because the nodes in our linked list aren't indexed and we will be removing a node based on its index, we'll need to keep track of the index, too."),(0,i.kt)("p",null,"Let's start with a test. Our method will be called ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList.prototype.remove(indexToRemove)")," and will take the index we want to remove as an argument. What's the simplest possible behavior we can add? Let's write a test for removing and updating the head. This is a simpler behavior than removing another node because it doesn't require any traversal."),(0,i.kt)("div",{class:"filename"},"__tests__/linked-list.test.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"...\n  test('it should set a new head if the head is removed', () => {\n    linkedListWithNodes.remove(0);\n    expect(linkedListWithNodes.head.data).toEqual(\"node2\");\n  });\n...\n")),(0,i.kt)("p",null,"The first position of the linked list will be 0 just as it is with an array. When the first position is removed, we'll expect the ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," property of the linked list's ",(0,i.kt)("inlineCode",{parentName:"p"},"head")," property to be ",(0,i.kt)("inlineCode",{parentName:"p"},'"node2"')," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},'"node1"'),"."),(0,i.kt)("p",null,"Now let's get this test passing:"),(0,i.kt)("div",{class:"filename"},"linked-list.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"...\nremove(indexToRemove) {\n  this.head = this.head.next;\n}\n...\n")),(0,i.kt)("p",null,"All we have to do is set ",(0,i.kt)("inlineCode",{parentName:"p"},"this.head")," to be equal to ",(0,i.kt)("inlineCode",{parentName:"p"},"this.head.next"),". That cuts the first node out of the list entirely. "),(0,i.kt)("p",null,"Now we are ready for our next test. We should be able to traverse the linked list and remove a node."),(0,i.kt)("div",{class:"filename"},"__tests__/linked-list.test.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"...\n  test('it should remove a node from the middle', () => {\n    linkedListWithNodes.remove(2);\n    expect(linkedListWithNodes.head.next.next.data).toEqual(\"node4\");\n  });\n...\n")),(0,i.kt)("p",null,"Remember that ",(0,i.kt)("inlineCode",{parentName:"p"},"linkedListWithNodes")," is set up in our ",(0,i.kt)("inlineCode",{parentName:"p"},"beforeEach()")," block with four nodes. In this test, we are removing the third node \u2014 and then checking to see if the new third node is equal to the previous fourth node. That will verify the old third node has been removed."),(0,i.kt)("p",null,"Now let's update our method to get the test passing:"),(0,i.kt)("div",{class:"filename"},"src/linked-list.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"remove(indexToRemove) {\n  if (indexToRemove === 0) {\n    this.head = this.head.next;\n  } else {\n    let currentNode = this.head;\n    let currentIndex = 0;\n    while ((currentIndex +1) <= indexToRemove) {\n      if ((currentIndex + 1) === indexToRemove) {\n        currentNode.next = currentNode.next.next;\n        break;\n      }\n      currentNode = currentNode.next;\n      currentIndex++;\n    }\n  }\n}\n")),(0,i.kt)("p",null,"First, we have to set up a conditional so ",(0,i.kt)("inlineCode",{parentName:"p"},"this.head")," is only modified if the index to be removed is 0."),(0,i.kt)("p",null,"Otherwise, we'll start traversing. Just as with our ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList.prototype.add(data)")," method, we'll set a ",(0,i.kt)("inlineCode",{parentName:"p"},"currentNode")," variable equal to ",(0,i.kt)("inlineCode",{parentName:"p"},"this.head"),". We'll also set up a ",(0,i.kt)("inlineCode",{parentName:"p"},"currentIndex")," method which is specific to this method since our linked list isn't indexed."),(0,i.kt)("p",null,"Now let's look at our loop, which will run as long as the ",(0,i.kt)("inlineCode",{parentName:"p"},"(currentIndex + 1) <= indexToRemove"),". Why the ",(0,i.kt)("inlineCode",{parentName:"p"},"+1"),"? Well, remember that our linked list only knows about the node that comes ",(0,i.kt)("em",{parentName:"p"},"next")," \u2014 not the one that comes ",(0,i.kt)("em",{parentName:"p"},"before")," it. However, once we get to the node we want to remove, we need to make an update to the node that comes ",(0,i.kt)("em",{parentName:"p"},"before")," it."),(0,i.kt)("p",null,"There are two approaches to solving this. One is to just have a ",(0,i.kt)("inlineCode",{parentName:"p"},"previousNode")," variable that provides a pointer so we always have access to the previous node. However, this isn't necessary. When ",(0,i.kt)("inlineCode",{parentName:"p"},"(currentIndex + 1) === indexToRemove"),", we know that we've reached the node that's directly before the node we want to remove. So instead of traversing all the way to the node we want to remove, we'll stop our traversal at the node before it instead. Then we just need to update that node's ",(0,i.kt)("inlineCode",{parentName:"p"},"next")," property to ",(0,i.kt)("inlineCode",{parentName:"p"},"currentNode.next.next")," \u2014 which cuts the node we want to remove out of the linked list. At this point, we can break out of the loop because are done."),(0,i.kt)("p",null,"If we haven't reached the node directly before the one we want to remove yet, we'll traverse to the next node and increment the ",(0,i.kt)("inlineCode",{parentName:"p"},"currentIndex")," by 1:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"currentNode = currentNode.next;\ncurrentIndex++;\n")),(0,i.kt)("p",null,"If we run our test, it will be passing."),(0,i.kt)("h3",{id:"what-if-the-index-to-remove-doesnt-exist"},"What If the Index to Remove Doesn't Exist?"),(0,i.kt)("p",null,"There's one more important problem we need to consider. What happens if the index doesn't exist in the linked list? Our method should return ",(0,i.kt)("inlineCode",{parentName:"p"},"-1")," if this is the case. (Alternatively, we could choose to throw an error.)"),(0,i.kt)("p",null,"Let's write a test:"),(0,i.kt)("div",{class:"filename"},"__tests__/linked-list.test.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"...\ntest('it should return -1 if the index does not exist', () => {\n  expect(linkedListWithNodes.remove(9)).toEqual(-1);\n});\n...\n")),(0,i.kt)("p",null,"There's no 9th position in this linked list. Once we verify the test is properly failing, let's get it passing. Here's the full method:"),(0,i.kt)("div",{class:"filename"},"linked-list.js"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"remove(indexToRemove) {\n  if (indexToRemove === 0) {\n    this.head = this.head.next;\n  } else {\n    let currentNode = this.head;\n    let currentIndex = 0;\n    while ((currentIndex +1 ) <= indexToRemove) {\n      if (currentNode.next === null ) {\n        return -1;\n      }\n      if ((currentIndex + 1) === indexToRemove) {\n        currentNode.next = currentNode.next.next;\n        break;\n      }\n      currentNode = currentNode.next;\n      currentIndex++;\n    }\n  }\n}\n")),(0,i.kt)("p",null,"The only update is the following conditional inside the while loop:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"if (currentNode.next === null ) {\n  return -1;\n}\n")),(0,i.kt)("p",null,"If we reach a node that has no next node and we still haven't found the index yet, we know the index is out of range and doesn't exist. Our method will ",(0,i.kt)("inlineCode",{parentName:"p"},"return -1")," and our test will pass."))}u.isMDXComponent=!0}}]);