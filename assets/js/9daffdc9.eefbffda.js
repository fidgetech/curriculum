"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[60316],{3905:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>y});var r=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=r.createContext({}),c=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},h=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),p=c(a),u=n,y=p["".concat(l,".").concat(u)]||p[u]||d[u]||o;return a?r.createElement(y,i(i({ref:t},h),{},{components:a})):r.createElement(y,i({ref:t},h))}));function y(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:n,i[1]=s;for(var c=2;c<o;c++)i[c]=a[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}u.displayName="MDXCreateElement"},8112:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var r=a(87462),n=(a(67294),a(3905));const o={title:"\ud83d\udcd3 Binary Search Trees Introduction",day:"monday",id:"binary-search-trees-introduction",hide_table_of_contents:!0},i=void 0,s={unversionedId:"capstone/capstone-week-1/binary-search-trees-introduction",id:"capstone/capstone-week-1/binary-search-trees-introduction",title:"\ud83d\udcd3 Binary Search Trees Introduction",description:"In this lesson, we'll give an overview of two data structures: the binary tree and the binary search tree. They are quite similar \u2014 the main difference is that a binary search tree has additional restraints that make it better for searching.",source:"@site/docs/capstone/1_capstone-week-1/AJ-binary-search-trees-introduction.md",sourceDirName:"capstone/1_capstone-week-1",slug:"/capstone/capstone-week-1/binary-search-trees-introduction",permalink:"/capstone/capstone-week-1/binary-search-trees-introduction",draft:!1,tags:[],version:"current",frontMatter:{title:"\ud83d\udcd3 Binary Search Trees Introduction",day:"monday",id:"binary-search-trees-introduction",hide_table_of_contents:!0},sidebar:"capstone",previous:{title:"\ud83d\udcd3 Introduction to Trees",permalink:"/capstone/capstone-week-1/introduction-to-trees"},next:{title:"\ud83d\udcd3 Binary Search Trees Part 1",permalink:"/capstone/capstone-week-1/binary-search-trees-part-1"}},l={},c=[{value:"Binary Tree",id:"binary-tree",level:2},{value:"Binary Search Tree",id:"binary-search-tree",level:2}],h={toc:c},p="wrapper";function d(e){let{components:t,...o}=e;return(0,n.kt)(p,(0,r.Z)({},h,o,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"In this lesson, we'll give an overview of two data structures: the ",(0,n.kt)("strong",{parentName:"p"},"binary tree")," and the ",(0,n.kt)("strong",{parentName:"p"},"binary search tree"),". They are quite similar \u2014 the main difference is that a binary search tree has additional restraints that make it better for searching."),(0,n.kt)("h2",{id:"binary-tree"},"Binary Tree"),(0,n.kt)("p",null,"A binary tree is a type of general tree structure. As the name suggests, it's a structure where each node can have no more than two child nodes. (We can infer this from the name because binary can be defined as something that has two parts.)"),(0,n.kt)("p",null,"Here's an example of a binary tree:"),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Image of a binary tree.",src:a(91278).Z,width:"611",height:"441"})),(0,n.kt)("p",null,"In the diagram above, each parent node has at most two child nodes. However, it's also fine if a parent has one or zero nodes. (In the latter case, it's technically not a parent.) By the way, don't worry about how the keys line up on the nodes. They do not need to be ordered in a specific fashion in a binary tree."),(0,n.kt)("p",null,"When a parent has two child nodes in a binary tree, the child nodes are referred to as the ",(0,n.kt)("strong",{parentName:"p"},"left child")," and the ",(0,n.kt)("strong",{parentName:"p"},"right child")," based on whether the node is on the left or right."),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"When a parent has two nodes, the nodes are referred to as the left and right child.",src:a(87545).Z,width:"271",height:"221"})),(0,n.kt)("p",null,"Binary trees have many uses. In fact, compilers often use them to build what is known as an ",(0,n.kt)("strong",{parentName:"p"},"abstract syntax tree")," (or AST) \u2014 an intermediate representation of the code that is not yet fully compiled. The JavaScript parser uses an AST as well, though it's a general tree, not a binary tree."),(0,n.kt)("h2",{id:"binary-search-tree"},"Binary Search Tree"),(0,n.kt)("p",null,"A binary search tree is very similar to a binary tree but also has a few additional restrictions. Let's take a look at an example."),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"An example of a binary search tree.",src:a(60336).Z,width:"611",height:"441"})),(0,n.kt)("p",null,"In the example above, you'll see that all child nodes ",(0,n.kt)("em",{parentName:"p"},"to the left")," of the root node have a value ",(0,n.kt)("em",{parentName:"p"},"less than")," the root node. Meanwhile, all child nodes ",(0,n.kt)("em",{parentName:"p"},"to the right")," of the root node have a value ",(0,n.kt)("em",{parentName:"p"},"greater than")," the root node. This pattern continues all the way down the tree. The left-hand child always has a value ",(0,n.kt)("em",{parentName:"p"},"less than")," its parent while the right-hand child always has a value ",(0,n.kt)("em",{parentName:"p"},"greater than")," its parent. Based on this pattern, we automatically know a few things about a few values in a binary search tree. The bottom left leaf node will be the lowest value in the tree while the bottom right leaf node will be the greatest value in the tree."),(0,n.kt)("p",null,"Duplicate keys aren't allowed in a binary search tree. This should make intuitive sense \u2014 because each child node must be either ",(0,n.kt)("em",{parentName:"p"},"less than")," or ",(0,n.kt)("em",{parentName:"p"},"greater than")," its parent node's key, there is no possibility of repeat keys."),(0,n.kt)("p",null,"Over the next several lessons, we'll create a small application that makes a binary search tree from scratch. In the process, we'll also learn how to search a binary search tree."))}d.isMDXComponent=!0},60336:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/binary_search_tree-54ebcc9db374af91e8e43feebaf49f7d.svg"},91278:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/binary_tree-7141fc9fcfe43f50b22d32efac20f7f7.png"},87545:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/left_and_right_child-5600982925ce9e1a2eb11ec173d0bf7c.png"}}]);