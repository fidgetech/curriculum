"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[41333],{22235:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"intermediate-javascript/asynchrony-and-apis/2-3-2-4-further-exploration-iifes","title":"\ud83d\udcd3 2.3.2.4 Further Exploration: IIFEs","description":"This lesson is optional further exploration. You can skip it entirely if you want. We\'ll use a more advanced technique called an IIFE to refactor the code we wrote in the last lesson.","source":"@site/docs/2_intermediate-javascript/3_asynchrony-and-apis/2-3-2-04-further-exploration-iifes.md","sourceDirName":"2_intermediate-javascript/3_asynchrony-and-apis","slug":"/intermediate-javascript/asynchrony-and-apis/2-3-2-4-further-exploration-iifes","permalink":"/v1.2/intermediate-javascript/asynchrony-and-apis/2-3-2-4-further-exploration-iifes","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 2.3.2.4 Further Exploration: IIFEs","day":"tuesday","id":"2-3-2-4-further-exploration-iifes","hide_table_of_contents":true},"sidebar":"intermediate-javascript","previous":{"title":"\ud83d\udcd3 2.3.2.3 Async and Await","permalink":"/v1.2/intermediate-javascript/asynchrony-and-apis/2-3-2-3-async-and-await"},"next":{"title":"\u270f\ufe0f 2.3.3.1 Bike Index, Cryptocurrency Analytics App, API of Choice (Longer Project)","permalink":"/v1.2/intermediate-javascript/asynchrony-and-apis/2-3-3-1-bike-index-cryptocurrency-analytics-app-api-of-choice-longer-project"}}');var o=t(74848),s=t(28453);const r={title:"\ud83d\udcd3 2.3.2.4 Further Exploration: IIFEs",day:"tuesday",id:"2-3-2-4-further-exploration-iifes",hide_table_of_contents:!0},a=void 0,c={},l=[{value:"Immediately-Invoked Function Expressions",id:"immediately-invoked-function-expressions",level:2},{value:"IFFE Syntax",id:"iffe-syntax",level:3},{value:"Benefits of IIFEs",id:"benefits-of-iifes",level:3}];function d(e){const n={a:"a",code:"code",div:"div",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["This lesson is ",(0,o.jsx)(n.strong,{children:"optional further exploration"}),". You can skip it entirely if you want. We'll use a more advanced technique called an IIFE to refactor the code we wrote in the last lesson."]}),"\n",(0,o.jsx)(n.h2,{id:"immediately-invoked-function-expressions",children:"Immediately-Invoked Function Expressions"}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.p,{children:"An IIFE is an Immediately-Invoked Function Expression. IIFEs definitely have their use cases (there's more on this below) but they really aren't necessary for beginners or even intermediate developers to know about. However, you may run into them in the wild, so it can be helpful to get some exposure now."}),"\n",(0,o.jsxs)(n.p,{children:["So, to get familiar with how we can use an IIFE, let's turn our async ",(0,o.jsx)(n.code,{children:"getWeather"})," function into an IIFE that's a part of our ",(0,o.jsx)(n.code,{children:"handleFormSubmission"}),". This is what our ",(0,o.jsx)(n.code,{children:"index.js"})," file will look like:"]}),"\n",(0,o.jsx)(n.div,{className:"filename",children:"src/index.js"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import 'bootstrap';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport './css/styles.css';\nimport WeatherService from './weather-service.js';\n\n// UI Logic\n\nfunction handleFormSubmission(event) {\n  event.preventDefault();\n  const city = document.querySelector('#location').value;\n  document.querySelector('#location').value = null;\n  (async function() {\n    const response = await WeatherService.getWeather(city);\n    if (response.main) {\n      printElements(response, city);\n    } else {\n      printError(response, city);\n    }\n  })();  \n}\n\nfunction printElements(response, city) {\n  document.querySelector('#showResponse').innerText = `The humidity in ${city} is ${response.main.humidity}%.\n  The temperature in Kelvins is ${response.main.temp} degrees.`;\n}\n\nfunction printError(error, city) {\n  document.querySelector('#showResponse').innerText = `There was an error accessing the weather data for ${city}: \n  ${error}.`;\n}\n\nwindow.addEventListener(\"load\", function() {\n  document.querySelector('form').addEventListener(\"submit\", handleFormSubmission);\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["As noted, we've removed the ",(0,o.jsx)(n.code,{children:"getWeather"})," function, and now we have an IIFE inside of ",(0,o.jsx)(n.code,{children:"handleFormSubmission"})," that does the same thing as the ",(0,o.jsx)(n.code,{children:"getWeather"})," function:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function handleFormSubmission() {\n  ...\n\n  (async function() {\n    const response = await WeatherService.getWeather(city);\n    if (response.main) {\n      printElements(response, city);\n    } else {\n      printError(response, city);\n    }\n  })();  \n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"iffe-syntax",children:"IFFE Syntax"}),"\n",(0,o.jsx)(n.p,{children:"So what exactly is going on here? And what's with the weird additional parens? Well, that's the syntax for an IIFE \u2014 a function that's immediately invoked. Here's the syntax in a nutshell:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// Pseudocode example!\n\n(function() {\n  // A function to be invoked immediately.\n})();\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The key thing here is that we wrap the function itself in ",(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Grouping",children:"grouping parentheses"})," and then we also have a closing parens at the end of the IIFE:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The parentheses around the function are so the JavaScript compiler doesn't throw an error."}),"\n",(0,o.jsx)(n.li,{children:"The parens at the end invoke the function just like we'd invoke any named function."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"We can even use a named function for an IIFE:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// Pseudocode!\n\n(function thisIsImmediatelyInvoked() {\n  // A function to be invoked immediately.\n})();\n"})}),"\n",(0,o.jsx)(n.h3,{id:"benefits-of-iifes",children:"Benefits of IIFEs"}),"\n",(0,o.jsxs)(n.p,{children:["Updating our code in ",(0,o.jsx)(n.code,{children:"index.js"})," to use an IIFE changed the way our code was structured, but it wasn't necessarily an improvement. So, the question remains, why use an IIFE?"]}),"\n",(0,o.jsx)(n.p,{children:"Well, the biggest benefit of IIFEs is data privacy. Any variables or data in an IIFE are scoped to it and aren't available elsewhere. If we don't use an IIFE, those variables will be available in other scopes, perhaps even the global scope, which isn't good."}),"\n",(0,o.jsx)(n.p,{children:"Let's quickly demonstrate:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'> (function() {\n  const secret = "This is a secret!"\n})();\n> secret;\nVM126:4 Uncaught ReferenceError: secret is not defined\n'})}),"\n",(0,o.jsxs)(n.p,{children:["If we run this in the DevTools console, we'll get a ",(0,o.jsx)(n.code,{children:"secret is not defined"})," error. As we know, it's very important to scope our code. For instance, think about the projects we did before we implemented JavaScript. We might have something like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function doSomething() {\n  // This function will do something.\n}\n\nwindow.onload = function() {\n  doSomething();\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Well, that ",(0,o.jsx)(n.code,{children:"doSomething()"})," function is available globally \u2014 we could even access it by typing in ",(0,o.jsx)(n.code,{children:"window.doSomething"})," in the DevTools console when we run our project."]}),"\n",(0,o.jsx)(n.p,{children:"So traditionally, it was common to use an IIFE to wrap the code in the user interface source code like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"(function() {\n  \n  function doSomething() {\n    // This function will do something.\n  }\n\n  window.onload = function() {\n    doSomething();\n  };\n})();\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This way, the ",(0,o.jsx)(n.code,{children:"doSomething()"})," function will no longer be in the global scope (or accessible via the ",(0,o.jsx)(n.code,{children:"window"})," object). It would just be available within the scope of the IIFE, which is where we want it."]}),"\n",(0,o.jsx)(n.p,{children:"Fortunately, webpack solves this problem for us, too, and doesn't allow code to leak into the global scope, so you won't see an IIFE used in this way with webpack. They can still be a useful tool for scoping code, though, and they can make an async function look a little bit cleaner."}),"\n",(0,o.jsxs)(n.p,{children:["The example repository hasn't been updated to include this code because it's optional. However, if you are interested in working with IIFEs, we recommend trying them out when you are writing async functions. For more information on the use cases for IIFEs, ",(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Glossary/IIFE",children:"visit the MDN documentation on IIFEs"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(96540);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);