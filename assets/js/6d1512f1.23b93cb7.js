"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[4845],{28453:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>i});var o=n(96540);const s={},a=o.createContext(s);function c(e){const t=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),o.createElement(a.Provider,{value:t},e.children)}},29590:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>i,default:()=>d,frontMatter:()=>c,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"react/react-with-nosql/3-4-0-2-introduction-to-hooks-with-the-usestate-hook","title":"\ud83d\udcd3 3.4.0.2 Introduction to Hooks with the useState Hook","description":"In this course section, we\'ll be leaving behind class components to focus on a purely functional approach to developing React components. To do this, we\'ll need to use special functions that are called hooks. As the React docs explain,","source":"@site/versioned_docs/version-WIP/3_react/4_react-with-nosql/3-4-0-02-introduction-to-hooks-with-the-usestate-hook.md","sourceDirName":"3_react/4_react-with-nosql","slug":"/react/react-with-nosql/3-4-0-2-introduction-to-hooks-with-the-usestate-hook","permalink":"/WIP/react/react-with-nosql/3-4-0-2-introduction-to-hooks-with-the-usestate-hook","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 3.4.0.2 Introduction to Hooks with the useState Hook","day":"weekend","id":"3-4-0-2-introduction-to-hooks-with-the-usestate-hook","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 3.4.0.1 React with NoSQL Objectives","permalink":"/WIP/react/react-with-nosql/3-4-0-1-react-with-nosql-objectives"},"next":{"title":"\ud83d\udcd3 3.4.0.3 Running Side Effects with the useEffect Hook","permalink":"/WIP/react/react-with-nosql/3-4-0-3-running-side-effects-with-the-useeffect-hook"}}');var s=n(74848),a=n(28453);const c={title:"\ud83d\udcd3 3.4.0.2 Introduction to Hooks with the useState Hook",day:"weekend",id:"3-4-0-2-introduction-to-hooks-with-the-usestate-hook",hide_table_of_contents:!0},i=void 0,r={},l=[{value:"The <code>useState</code> Hook",id:"the-usestate-hook",level:2},{value:"<code>useState</code> As Compared To <code>this.state</code>",id:"usestate-as-compared-to-thisstate",level:3},{value:"Multiple State Variables",id:"multiple-state-variables",level:3}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["In this course section, we'll be leaving behind class components to focus on a purely functional approach to developing React components. To do this, we'll need to use special functions that are called ",(0,s.jsx)(t.strong,{children:"hooks"}),". ",(0,s.jsx)(t.a,{href:"https://reactjs.org/docs/hooks-overview.html",children:"As the React docs"})," explain,"]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"Hooks are functions that let you \u201chook into\u201d React state and lifecycle features from function components. Hooks don\u2019t work inside classes \u2014 they let you use React without classes."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Hooks were released in version 16.8 of React as a solution to many pain points for React developers. We can boil down these pain points into two main issues:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"How can we use React state and lifecycle features in a function component without having to refactor it into a class component?"}),"\n",(0,s.jsxs)(t.li,{children:["Is there an easier way to ",(0,s.jsx)(t.em,{children:"re"}),"use stateful logic in multiple places?"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The advent of hooks solved both of these issues."}),"\n",(0,s.jsxs)(t.p,{children:["But before we get too much into the weeds of React's motivation to create hooks, let's introduce ourselves to the basics of hooks by learning how to use React's ",(0,s.jsx)(t.code,{children:"useState"})," hook."]}),"\n",(0,s.jsxs)(t.p,{children:["In this course section, we'll also learn about the ",(0,s.jsx)(t.code,{children:"useEffect"})," hook. Then, in the next course section, we'll learn how to use the ",(0,s.jsx)(t.code,{children:"useReducer"})," and ",(0,s.jsx)(t.code,{children:"useContext"})," hooks."]}),"\n",(0,s.jsxs)(t.h2,{id:"the-usestate-hook",children:["The ",(0,s.jsx)(t.code,{children:"useState"})," Hook"]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsxs)(t.p,{children:["We'll learn to use React's built-in ",(0,s.jsx)(t.code,{children:"useState"})," hook by looking at an example of a simple counter app. This example includes a button that increases the value of a counter, a button to show and hide, and a display of the counter's value. You do not need to code along with this lesson, though you are welcome to do so."]}),"\n",(0,s.jsxs)(t.p,{children:["We'll start by creating a new app so we can implement ",(0,s.jsx)(t.code,{children:"useState"}),". Navigate to your desktop in your terminal, and input this command:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"$ npx create-react-app intro-to-hooks\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Next, replace the code in ",(0,s.jsx)(t.code,{children:"src/App.js"})," with the following code:"]}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"src/App.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"import './App.css';\nimport Counter from './Counter';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Counter />\n    </div>\n  );\n}\n\nexport default App;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We'll keep the styling with the class ",(0,s.jsx)(t.code,{children:"App"})," that centers the content on the page."]}),"\n",(0,s.jsxs)(t.p,{children:["Next, create a file called ",(0,s.jsx)(t.code,{children:"Counter.js"})," in the ",(0,s.jsx)(t.code,{children:"src"})," folder with the following code:"]}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"src/Counter.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"import React, { useState } from 'react';\n\nfunction Counter() {\n  return(\n    <React.Fragment>\n    </React.Fragment>\n  )\n}\n\nexport default Counter;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Here we've set up a basic function component and we've imported the ",(0,s.jsx)(t.code,{children:"{ useState }"})," hook from react. Now we're ready to implement the ",(0,s.jsx)(t.code,{children:"useState"})," function."]}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"src/Counter.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"...\n\nfunction Counter() {\n  const [counter, setCounter] = useState(0);\n\n  return(\n    <React.Fragment>\n    </React.Fragment>\n  )\n}\n\n...\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"useState"})," hook returns an array that we destructure into two variables. The first variable contains the state value, and the second variable is a function that we can use to set the state value. We could also rewrite ",(0,s.jsx)(t.code,{children:"const [counter, setCounter] = useState(0);"})," like so:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"  const counterState = useState(0);\n  const counter = counterState[0];\n  const setCounter = counterState[1];\n"})}),"\n",(0,s.jsx)(t.p,{children:"However, that's not common practice."}),"\n",(0,s.jsxs)(t.p,{children:["As far as naming conventions, the first variable should be named after the state the variable represents. Since we're setting up a counter, we name our state ",(0,s.jsx)(t.code,{children:"counter"}),". The second variable should always start with ",(0,s.jsx)(t.code,{children:"set"})," followed by the first variable, like we have with ",(0,s.jsx)(t.code,{children:"setCounter"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"useState"})," hook also takes an argument, which will set the state property's initial value. We can initialize this with a number, a boolean, a string, an object, or even ",(0,s.jsx)(t.code,{children:"null"}),". For our counter, we initialize ",(0,s.jsx)(t.code,{children:"useState"})," with the number 0."]}),"\n",(0,s.jsx)(t.p,{children:"Now we're ready to actually utilize this new functionality. We'll create a button to update the value of the counter \u2014 and we'll also display the value of the counter as well."}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"src/Counter.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"...\n\nfunction Counter() {\n  const [counter, setCounter] = useState(0);\n\n  return (\n    <React.Fragment>\n      <h1>{counter}</h1>\n      <button onClick={() => setCounter(counter + 1)}>Count!</button>\n    </React.Fragment>\n  );\n}\n\n...\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We can simply call ",(0,s.jsx)(t.code,{children:"counter"})," using JSX, which will display that property's current value. We also create an ",(0,s.jsx)(t.code,{children:"onClick"})," listener so that a user can click a button to trigger the ",(0,s.jsx)(t.code,{children:"setCounter"})," method. We need this to be a callback function so we can pass in an argument, otherwise it'll run on page load. This will replace the current value of ",(0,s.jsx)(t.code,{children:"counter"}),", overwriting its previous value."]}),"\n",(0,s.jsx)(t.p,{children:"With just a couple of lines, we have local state in a function component! Very cool!"}),"\n",(0,s.jsxs)(t.h3,{id:"usestate-as-compared-to-thisstate",children:[(0,s.jsx)(t.code,{children:"useState"})," As Compared To ",(0,s.jsx)(t.code,{children:"this.state"})]}),"\n",(0,s.jsxs)(t.p,{children:["Now, let's compare what our functional ",(0,s.jsx)(t.code,{children:"Counter"})," component would look like as a class component. We won't add this to our ",(0,s.jsx)(t.code,{children:"intro-to-hooks"})," application:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"class Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      counter: 0\n    };\n  }\n\n  render() {\n    return (\n      <React.Fragment>\n        <h1>{this.state.counter}</h1>\n        <button onClick={() => this.setState({counter: this.state.counter + 1})}>Count!</button>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default Counter;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["As we can see, instead of storing ",(0,s.jsx)(t.code,{children:"counter"})," as a slice of state in our state object, like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We instead store state in a variable, as returned by our ",(0,s.jsx)(t.code,{children:"useState"})," function:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const [counter, setCounter] = useState(0);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["And instead of updating state with the ",(0,s.jsx)(t.code,{children:"this.setState"})," method, like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"<button onClick={() => this.setState({counter: this.state.counter + 1})}>Count!</button>\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We instead use ",(0,s.jsx)(t.code,{children:"setCounter"}),", like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"<button onClick={() => setCounter(counter + 1)}>Count!</button>\n"})}),"\n",(0,s.jsx)(t.h3,{id:"multiple-state-variables",children:"Multiple State Variables"}),"\n",(0,s.jsxs)(t.p,{children:["Let's say we want to add another property to our ",(0,s.jsx)(t.code,{children:"Counter"})," component's local state. We could approach that by doing the following:"]}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"src/Counter.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:'\n...\nfunction Counter() {\n\n  const [bundle, setBundle] = useState({"hidden": false, "counter": 0});\n\n  return (\n    <React.Fragment>\n      {bundle.hidden ? <h1>Count Hidden</h1> : <h1>{bundle.counter}</h1>} \n\n      <button onClick={() => setBundle({...bundle, "counter": bundle.counter +1})}>Count!</button>\n      <button onClick={() => setBundle({...bundle, "hidden": !bundle.hidden})}>Hide/Show</button>\n    </React.Fragment>\n  );\n}\n\n...\n'})}),"\n",(0,s.jsxs)(t.p,{children:["React's ",(0,s.jsx)(t.code,{children:"useState"})," hook accepts any data type as an argument, including objects. So just like in the above example, we could create as many properties as we like and call on them using dot notation."]}),"\n",(0,s.jsxs)(t.p,{children:["But while the above approach works, it isn't recommended. The React documentation instead recommends creating multiple instances of ",(0,s.jsx)(t.code,{children:"useState"})," and calling on them as separate variables. Take a look at this approach instead:"]}),"\n",(0,s.jsx)(t.div,{className:"filename",children:"src/Counter.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"\n...\nfunction Counter() {\n\n  const [counter, setCounter] = useState(0);\n  const [hidden, setHidden] = useState(false);\n\n  return (\n    <React.Fragment>\n      {hidden ? <h1>Count Hidden</h1> : <h1>{counter}</h1>}\n      <button onClick={() => setCounter(counter + 1)}>Count!</button>\n      <button onClick={() => setHidden(!hidden)}>Hide/Show</button>\n    </React.Fragment>\n  );\n}\n\n...\n"})}),"\n",(0,s.jsx)(t.p,{children:"It's not only easier to read the state variable declarations, it's easier to use the state in our JSX, because each state variable has a separate name and updater function. This structure puts into practice the design principle called separation of concerns."}),"\n",(0,s.jsxs)(t.p,{children:["That said, it may just make more sense in your application to combine two state slices into one object that is created and managed via ",(0,s.jsx)(t.code,{children:"useState"}),", just like we saw in this example:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'const [bundle, setBundle] = useState({"hidden": false, "counter": 0});\n'})}),"\n",(0,s.jsxs)(t.p,{children:["If you opt for this, just know that the ",(0,s.jsx)(t.em,{children:"setState"})," function (i.e.: ",(0,s.jsx)(t.code,{children:"setBundle"}),") replaces the previous state variable, instead of merging the new state with the old state as with the ",(0,s.jsx)(t.code,{children:"this.setState"})," method. That's why when we want to update the count within our ",(0,s.jsx)(t.code,{children:"bundle"})," state, we need to include all values in the ",(0,s.jsx)(t.code,{children:"setBundle"})," function:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'<button onClick={() => setBundle({...bundle, "counter": bundle.counter +1})}>Count!</button>\n'})}),"\n",(0,s.jsxs)(t.p,{children:["As we can see, we use ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#description",children:"spread syntax"})," to copy over the object saved in ",(0,s.jsx)(t.code,{children:"bundle"}),", and then specify that we want to update the ",(0,s.jsx)(t.code,{children:'"counter"'})," key."]}),"\n",(0,s.jsxs)(t.p,{children:["In contrast, if the ",(0,s.jsx)(t.em,{children:"Count!"})," button only ran this code:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'<button onClick={() => setBundle({"counter": bundle.counter +1})}>Count!</button>\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Then we'd have no more ",(0,s.jsx)(t.code,{children:'"hidden"'})," key and our application would break."]}),"\n",(0,s.jsxs)(t.p,{children:["So, with this lesson we've learned how to use the very useful ",(0,s.jsx)(t.code,{children:"useState"})," hook, which means we can now use state in our function components. But what about our component lifecycle methods? What if I want to run a side effect when my component mounts or updates? In the next lesson, we'll learn about the ",(0,s.jsx)(t.code,{children:"useEffect"})," hook which gives us the same ability to run side effects in function components as lifecycle methods let us do in class components."]}),"\n",(0,s.jsx)(t.p,{children:"After that, we'll review best practices for using hooks. Then, we'll move onto updating our Help Queue application to use hooks."}),"\n",(0,s.jsxs)(t.p,{children:["If you'd like to learn more about the ",(0,s.jsx)(t.code,{children:"useState"})," hook, check the official ",(0,s.jsxs)(t.a,{href:"https://reactjs.org/docs/hooks-state.html",children:["React Docs on the ",(0,s.jsx)(t.code,{children:"useState"})," hook"]}),"."]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);