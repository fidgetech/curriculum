"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[25412],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var r=t(96540);const i={},o=r.createContext(i);function s(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:n},e.children)}},69280:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"c-and-net/test-driven-development-with-c/5-1-1-4--trycatch-blocks","title":"\ud83d\udcd3 5.1.1.4- Try/Catch Blocks","description":"When our application throws an error, the program is throwing an exception. Almost every time the compiler throws an error, it uses the term \\"exception.\\" An exception occurs when we execute or interact with a program that results in the program crashing.","source":"@site/versioned_docs/version-WIP/c-and-net/1_test-driven-development-with-c/3-1-1-04--trycatch-blocks.md","sourceDirName":"c-and-net/1_test-driven-development-with-c","slug":"/c-and-net/test-driven-development-with-c/5-1-1-4--trycatch-blocks","permalink":"/WIP/c-and-net/test-driven-development-with-c/5-1-1-4--trycatch-blocks","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 5.1.1.4- Try/Catch Blocks","day":"monday","id":"5-1-1-4--trycatch-blocks","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 5.1.1.3- Overloading Constructors and Methods","permalink":"/WIP/c-and-net/test-driven-development-with-c/5-1-1-3--overloading-constructors-and-methods"},"next":{"title":"\ud83d\udcd3 5.1.1.5- More Built-In C# Classes and Tips for Using the MS Docs","permalink":"/WIP/c-and-net/test-driven-development-with-c/5-1-1-5--more-built-in-c-classes-and-tips-for-using-the-ms-docs"}}');var i=t(74848),o=t(28453);const s={title:"\ud83d\udcd3 5.1.1.4- Try/Catch Blocks",day:"monday",id:"5-1-1-4--trycatch-blocks",hide_table_of_contents:!0},a=void 0,c={},l=[{value:"Try/Catch Blocks",id:"trycatch-blocks",level:2},{value:"Example",id:"example",level:3},{value:"A Note on Composite Formatting",id:"a-note-on-composite-formatting",level:3},{value:"Another Try/Catch Example",id:"another-trycatch-example",level:3}];function h(e){const n={a:"a",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["When our application throws an error, the program is ",(0,i.jsx)(n.strong,{children:"throwing an exception"}),'. Almost every time the compiler throws an error, it uses the term "exception." An ',(0,i.jsx)(n.strong,{children:"exception"})," occurs when we execute or interact with a program that results in the program crashing."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Exception handling"}),' refers to the act of coding a program to handle exceptions in a manner that doesn\'t lead to the application crashing. When an exception is thrown, we can program our application to "catch" and handle the exception appropriately. We can do this with a ',(0,i.jsx)(n.strong,{children:"try/catch block"}),". As we'll see C# try/catch blocks offer the same functionality as try/catch blocks in JavaScript."]}),"\n",(0,i.jsx)(n.h2,{id:"trycatch-blocks",children:"Try/Catch Blocks"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["When an exception is thrown, the CLR (Common Language Runtime) automatically looks for a ",(0,i.jsx)(n.strong,{children:"catch"})," statement to handle the exception. If no catch statement is found, the exception is considered ",(0,i.jsx)(n.strong,{children:"unhandled"})," and the execution of the program halts. In other words, our program crashes."]}),"\n",(0,i.jsxs)(n.p,{children:["We can manually add code to tell our application how to handle exceptions in try/catch blocks. The ",(0,i.jsx)(n.strong,{children:"try"})," part is where we put the code that ",(0,i.jsx)(n.em,{children:"may"})," cause an exception. If everything is fine and no exception is thrown, the application simply moves on. If an exception ",(0,i.jsx)(n.em,{children:"is"})," thrown, the program will automatically run the code in the ",(0,i.jsx)(n.strong,{children:"catch"})," part to handle that exception."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"catch"})," blocks can take an ",(0,i.jsx)(n.code,{children:"Exception"})," object as a parameter, which can help handle exceptions even more effectively. ",(0,i.jsxs)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.exception?view=net-6.0",children:["The ",(0,i.jsx)(n.code,{children:"Exception"})," class"]})," has a number of useful properties:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Message"}),": a short description of the exception;"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Source"}),": the application name;"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"StackTrace"}),": the path to what caused the exception;"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TargetSite"}),": the name of the method where the exception occurred."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Also note that the ",(0,i.jsx)(n.code,{children:"Exception"})," class lives in the ",(0,i.jsx)(n.code,{children:"System"})," namespace, so we'll need to include the using directive ",(0,i.jsx)(n.code,{children:"using System;"})," wherever we use the ",(0,i.jsx)(n.code,{children:"Exception"})," class."]}),"\n",(0,i.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,i.jsxs)(n.p,{children:["Let's work through an example of how we could use a try/catch block. Note that the following example is adapted from the ",(0,i.jsx)(n.a,{href:"http://www.dotnetperls.com/exception",children:"Exception Handling Tutorial on dotnetperls"}),"."]}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"DivideByZero.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'using System;\n\nclass Program\n{\n  static void Main()\n  {\n    try\n    {\n      int value = 1 / int.Parse("0");\n    }\n    catch (Exception ex)\n    {\n      Console.WriteLine("Message = {0}", ex.Message);\n      Console.WriteLine("Source = {0}", ex.Source);\n      Console.WriteLine("StackTrace = {0}", ex.StackTrace);\n      Console.WriteLine("TargetSite = {0}", ex.TargetSite);\n    }\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["This program is going to ",(0,i.jsx)(n.em,{children:"try"})," to return the ",(0,i.jsx)(n.code,{children:"value"})," of an integer that's divided by zero. Everything compiles as expected but when we actually try to run the program and divide by zero, an exception is thrown because it isn't possible to divide by zero."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Normally this exception would halt the program entirely. However, because the code throwing an exception resides in the ",(0,i.jsx)(n.code,{children:"try"})," of our try/catch block, C# will automatically run the code within the ",(0,i.jsx)(n.code,{children:"catch"})," portion in an attempt to gracefully handle the exception."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The code in ",(0,i.jsx)(n.code,{children:"catch"})," logs details about the exception to the console instead of halting the program entirely."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Compiling and running this program would result in the following output in the console:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"Message = Attempted to divide by zero.\nSource = DivideByZero\nStackTrace =    at Program.Main()\nTargetSite = Void Main()\n"})}),"\n",(0,i.jsx)(n.p,{children:"So even though our code has an exception in it, we've successfully handled it in our try/catch block!"}),"\n",(0,i.jsx)(n.h3,{id:"a-note-on-composite-formatting",children:"A Note on Composite Formatting"}),"\n",(0,i.jsxs)(n.p,{children:["Notice how we pass in two arguments to each ",(0,i.jsx)(n.code,{children:"Console.WriteLine()"})," method call, like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'Console.WriteLine("StackTrace = {0}", ex.StackTrace);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The second argument ",(0,i.jsx)(n.code,{children:"ex.StackTrace"})," supplies the value for ",(0,i.jsx)(n.code,{children:"{0}"})," within the first argument's string. This is called a ",(0,i.jsx)(n.strong,{children:"composite format string"}),", in which we include ",(0,i.jsx)(n.strong,{children:"format items"})," in a string whose values get evaluated and set by an additional argument. Let's see another example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'string name = "Stacey";\nstring age = "12";\nConsole.WriteLine("Name = {0}, Age = {1}", name, age);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Try out the above code in the ",(0,i.jsx)(n.code,{children:"dotnet-script"})," REPL if you like!"]}),"\n",(0,i.jsxs)(n.p,{children:["In the above code we have a string with format items: ",(0,i.jsx)(n.code,{children:'"Name = {0}, Age = {1}"'}),". The format items are ",(0,i.jsx)(n.code,{children:"{0}"})," and ",(0,i.jsx)(n.code,{children:"{1}"})," and will be replaced by the next two arguments that are passed into the ",(0,i.jsx)(n.code,{children:"Console.WriteLine()"})," method, ",(0,i.jsx)(n.code,{children:"name"})," and ",(0,i.jsx)(n.code,{children:"age"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["To learn other ways to use composite format strings, visit ",(0,i.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/standard/base-types/composite-formatting",children:"the MS docs"}),"!"]}),"\n",(0,i.jsx)(n.h3,{id:"another-trycatch-example",children:"Another Try/Catch Example"}),"\n",(0,i.jsx)(n.p,{children:"We now have a sense of how try/catch blocks work, so let's see how we can use try/catch within the Shape Tracker console app."}),"\n",(0,i.jsx)(n.p,{children:"Right now, we can get an unhandled exception if a user does NOT put in numbers when our program requests three sides. Check it out:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*\nWelcome to the Shape Tracker app!\nWe'll calculate what type of triangle you have based off of the lengths of the triangle's 3 sides.\nPlease enter a number:\na\nEnter another number:\nf\nEnter a third number:\ng\nUnhandled exception. System.FormatException: Input string was not in a correct format.\n   at System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)    \n   at System.Int32.Parse(String s)\n   at ShapeTracker.Program.Main() in C:\\Users\\brook\\Desktop\\csharp-sect-1\\shp\\8\\private-ver2-shapetracker\\ShapeTracker\\Program.cs:line 19\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The above unhandled exception is generated when we try to parse the ",(0,i.jsx)(n.code,{children:"string"})," user input into ",(0,i.jsx)(n.code,{children:"int"})," with the ",(0,i.jsx)(n.code,{children:"int.Parse()"})," static method. This makes sense \u2014 we can't parse ",(0,i.jsx)(n.code,{children:'"a"'})," or ",(0,i.jsx)(n.code,{children:'"g"'})," into a number!!"]}),"\n",(0,i.jsx)(n.p,{children:"So let's see how a try/catch block can add the right error handling in this situation:"}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"ShapeTracker/Models/Triangle.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'using System;\nusing ShapeTracker.Models;\n\nnamespace ShapeTracker\n{\n  class Program\n  {\n    static void Main()\n    {\n      Console.WriteLine("*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*");\n      Console.WriteLine("Welcome to the Shape Tracker app!");\n      Console.WriteLine("We\'ll calculate what type of triangle you have based off of the lengths of the triangle\'s 3 sides.");\n      Console.WriteLine("Please enter a number:");\n      string stringNumber1 = Console.ReadLine();  \n      Console.WriteLine("Enter another number:");\n      string stringNumber2 = Console.ReadLine();  \n      Console.WriteLine("Enter a third number:");\n      string stringNumber3 = Console.ReadLine();  \n      try\n      {\n        int length1 = int.Parse(stringNumber1);  \n        int length2 = int.Parse(stringNumber2);  \n        int length3 = int.Parse(stringNumber3);\n        Triangle tri = new Triangle(length1, length2, length3);\n        ConfirmOrEditTriangle(tri);  \n      }\n      catch\n      {\n        Console.WriteLine("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");\n        Console.WriteLine("ERROR: Please only enter in numbers! Special symbols and alphabetic characters will not be accepted.");\n        Console.WriteLine("Please try again...");\n        Main();\n      }\n    }\n\n    ... // other code omitted for brevity!\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["We've added the code that could throw an unhandled exception within a ",(0,i.jsx)(n.code,{children:"try"})," block."]}),"\n",(0,i.jsxs)(n.p,{children:["If our code works as expected, like when a user only enters strings with a number like ",(0,i.jsx)(n.code,{children:'"3"'})," or ",(0,i.jsx)(n.code,{children:'"5000"'}),", those strings will be parsed correctly and our application's logic will continue creating a new ",(0,i.jsx)(n.code,{children:"Triangle"})," instance and calling the ",(0,i.jsx)(n.code,{children:"ConfirmOrEditTriangle()"})," method."]}),"\n",(0,i.jsxs)(n.p,{children:["If our code fails, like when a user enters anything other than a string with a number in it, like ",(0,i.jsx)(n.code,{children:'"s"'}),", then the ",(0,i.jsx)(n.code,{children:"catch"})," block will be run. Within our catch block, we let the user know what went wrong and we call ",(0,i.jsx)(n.code,{children:"Main()"})," again to start the program over."]}),"\n",(0,i.jsxs)(n.p,{children:["Notice that we don't use the ",(0,i.jsx)(n.code,{children:"Exception"})," class within the catch block. Well, you don't have to! You should always do what makes sense for your app, and sometimes we can write more human-understandable error messages than the compiler generates."]}),"\n",(0,i.jsx)(n.p,{children:"If we did want to incorporate the runtime error message, we could do something like this:"}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"ShapeTracker/Models/Triangle.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'using System;\nusing ShapeTracker.Models;\n\nnamespace ShapeTracker\n{\n  class Program\n  {\n    static void Main()\n    {\n      Console.WriteLine("*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*");\n      Console.WriteLine("Welcome to the Shape Tracker app!");\n      Console.WriteLine("We\'ll calculate what type of triangle you have based off of the lengths of the triangle\'s 3 sides.");\n      Console.WriteLine("Please enter a number:");\n      string stringNumber1 = Console.ReadLine();  \n      Console.WriteLine("Enter another number:");\n      string stringNumber2 = Console.ReadLine();  \n      Console.WriteLine("Enter a third number:");\n      string stringNumber3 = Console.ReadLine();  \n      try\n      {\n        int length1 = int.Parse(stringNumber1);  \n        int length2 = int.Parse(stringNumber2);  \n        int length3 = int.Parse(stringNumber3);\n        Triangle tri = new Triangle(length1, length2, length3);\n        ConfirmOrEditTriangle(tri);  \n      }\n      catch (Exception ex)\n      {\n        Console.WriteLine("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");\n        Console.WriteLine("ERROR: {0}", ex.Message);\n        Console.WriteLine("Please only enter in numbers! Special symbols and alphabetic characters will not be accepted.");\n        Console.WriteLine("Please try again...");\n        Main();\n      }\n    }\n\n    ... // other code omitted for brevity!\n  }\n}\n'})})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);