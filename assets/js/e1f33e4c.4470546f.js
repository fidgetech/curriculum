"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[90935],{4116:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>r});const o=JSON.parse('{"id":"react/react-with-redux/4-3-3-3-component-lifecycle-methods","title":"\ud83d\udcd3 4.3.3.3 Component Lifecycle Methods","description":"Note: While you are not expected to incorporate any of the concepts from the homework on date-fns into your independent project, it\'s important to understand how the component lifecycle works. Pay close attention to the material in this lesson!","source":"@site/docs/4_react/3_react-with-redux/4-3-3-03-component-lifecycle-methods.md","sourceDirName":"4_react/3_react-with-redux","slug":"/react/react-with-redux/4-3-3-3-component-lifecycle-methods","permalink":"/v1.2/react/react-with-redux/4-3-3-3-component-lifecycle-methods","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 4.3.3.3 Component Lifecycle Methods","day":"wednesday","id":"4-3-3-3-component-lifecycle-methods","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 4.3.3.2 Introduction to date-fns","permalink":"/v1.2/react/react-with-redux/4-3-3-2-introduction-to-date-fns"},"next":{"title":"\ud83d\udcd3 4.3.3.4 Adding Wait Time to the Queue","permalink":"/v1.2/react/react-with-redux/4-3-3-4-adding-wait-time-to-the-queue"}}');var i=n(74848),c=n(28453);const s={title:"\ud83d\udcd3 4.3.3.3 Component Lifecycle Methods",day:"wednesday",id:"4-3-3-3-component-lifecycle-methods",hide_table_of_contents:!0},l=void 0,d={},r=[{value:"Using a Timer to Demonstrate Lifecycle Methods",id:"using-a-timer-to-demonstrate-lifecycle-methods",level:3}];function a(e){const t={a:"a",code:"code",div:"div",em:"em",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note:"})," While you are not expected to incorporate any of the concepts from the homework on date-fns into your independent project, it's important to understand how the component lifecycle works. Pay close attention to the material in this lesson!"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.p,{children:"In this lesson, we'll learn about the lifecycle of a React component. We'll also add a timer to our Help Queue to see how lifecycle methods work."}),"\n",(0,i.jsxs)(t.p,{children:["The React lifecycle is a series of methods that is always called in a certain order. We can use these lifecycle methods to call our own methods at a very specific time during a component's lifecycle. We've actually used the most common lifecycle methods before: ",(0,i.jsx)(t.code,{children:"constructor()"})," and ",(0,i.jsx)(t.code,{children:"render()"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"We can roughly break the component lifecycle down into three stages:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Mounting"})," refers to the stages where a component is instantiated and then added to the DOM. It includes the following common lifecycle methods, which are called in order:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"constructor()"})}),": We've used this method extensively. This is where we specify any properties the component should have such as local state."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"render()"})}),": We're also familiar with this method, which is used to render elements. It's the only lifecycle method that's required in a class component."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"componentDidMount()"})}),": We haven't used this method before. ",(0,i.jsx)(t.code,{children:"componentDidMount()"})," is invoked after a component has finished inserting all DOM nodes. The React documentation recommends setting up subscriptions during this lifecycle method. We will use this method to instantiate a timer to keep track of our Help Queue."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Updating"})," is a stage that can happen multiple times during a component's lifecycle. For instance, this stage would occur each time a user increments a counter."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"render()"})}),": Not surprisingly, ",(0,i.jsx)(t.code,{children:"render()"})," gets called again. That way, any DOM nodes that have changed can be refreshed."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"componentDidUpdate()"})}),": If we have a method that we want to call any time the component updates, we could do so here. Be careful, though \u2014 it may be called many times and this isn't necessarily very efficient."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Unmounting"})," occurs when the component is being removed from the DOM. It only has one method:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"componentWillUnmount()"})}),": We can use this method to perform any cleanup such as unsubscribing or canceling a timer. We will utilize this method to cancel the timer in our own Help Queue."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["It's important to understand the component lifecycle and the order of these lifecycle methods. There are a number of other lifecycle methods listed in the ",(0,i.jsx)(t.a,{href:"https://reactjs.org/docs/react-component.html",children:"React documentation"})," but they are not commonly used. However, we recommend taking a look at the docs to get a better sense of the full lifecycle. Each lifecycle method is well documented if you want more information."]}),"\n",(0,i.jsxs)(t.p,{children:["If we review the lifecycle methods above, there are three new lifecycle methods we haven't used before: ",(0,i.jsx)(t.code,{children:"componentDidMount()"}),", ",(0,i.jsx)(t.code,{children:"componentDidUpdate()"})," and ",(0,i.jsx)(t.code,{children:"componentWillUnmount()"}),". We will use the first and the third in our Help Queue application."]}),"\n",(0,i.jsx)(t.h3,{id:"using-a-timer-to-demonstrate-lifecycle-methods",children:"Using a Timer to Demonstrate Lifecycle Methods"}),"\n",(0,i.jsx)(t.p,{children:"Before we move on, let's implement a simple timer in our Help Queue application. We'll add all three of the lifecycle methods we just learned. We'll also incorporate much (but not all) of the code below in the next lesson as well."}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"src/components/TicketControl.js"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:'...\n// Add the following code after the constructor.\n\ncomponentDidMount() {\n    this.waitTimeUpdateTimer = setInterval(() =>\n      this.updateTicketElapsedWaitTime(),\n    1000\n    );\n  }\n\n  // We won\'t be using this method for our Help Queue update \u2014 but it\'s important to see how it works.\n  componentDidUpdate() {\n    console.log("component updated!");\n  }\n\n  componentWillUnmount(){\n    console.log("component unmounted!");\n    clearInterval(this.waitTimeUpdateTimer);\n  }\n\n  updateTicketElapsedWaitTime = () => {\n    console.log("tick");\n  }\n'})}),"\n",(0,i.jsxs)(t.p,{children:["When our component is mounted, ",(0,i.jsx)(t.code,{children:"componentDidMount()"})," will be called. That will trigger the following code:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"this.waitTimeUpdateTimer = setInterval(() =>\n  this.updateTicketElapsedWaitTime(),\n1000\n);\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This code should be relatively familiar from Intermediate JavaScript. The ",(0,i.jsx)(t.code,{children:"setInterval()"})," method is a function. The function call itself includes two parts: the code to be executed and the delay between each interval. In this case, the interval is set to 1000 milliseconds \u2014 a single second."]}),"\n",(0,i.jsxs)(t.p,{children:["We set the value of the code to be executed to another function called ",(0,i.jsx)(t.code,{children:"this.updateTicketElapsedWaitTime()"}),". We ",(0,i.jsx)(t.em,{children:"could"})," call all the code we want to execute inside ",(0,i.jsx)(t.code,{children:"componentDidMount()"})," but that wouldn't be very clean. All we want to do is have a timer here. Updating the UI of the queue to reflect the elapsed time should be a separate concern."]}),"\n",(0,i.jsxs)(t.p,{children:["We set the value of the ",(0,i.jsx)(t.code,{children:"setInterval()"})," function to ",(0,i.jsx)(t.code,{children:"this.waitTimeUpdateTimer"}),". We make it a property of the component so that we can use it in other functions. This way, we can actually cancel the timer when we need to."]}),"\n",(0,i.jsx)(t.p,{children:"We will keep this method for our Help Queue application \u2014 though we will change the interval to 60000 ms so the queue updates every minute \u2014 just like the one at Epicodus."}),"\n",(0,i.jsxs)(t.p,{children:["Next, we call ",(0,i.jsx)(t.code,{children:"componentDidUpdate()"}),". We add a ",(0,i.jsx)(t.code,{children:'console.log("component updated!")'})," so we can see when this method is called in our component. We won't be using ",(0,i.jsx)(t.code,{children:"componentDidUpdate()"})," in our Help Queue \u2014 but it's still helpful to see how this lifecycle method works."]}),"\n",(0,i.jsxs)(t.p,{children:["Then we call ",(0,i.jsx)(t.code,{children:"componentWillUnmount()"}),". This method will be called when our component is cleared from the UI. It includes the following code:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:'console.log("component unmounted!");\nclearInterval(this.waitTimeUpdateTimer);\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"console.log()"})," will tell us when the component is about to be unmounted. Then we need to call ",(0,i.jsx)(t.code,{children:"clearInterval()"})," to actually clear the timer. If we hadn't saved the timer inside ",(0,i.jsx)(t.code,{children:"this.waitTimeUpdateTimer"}),", we wouldn't have a way to clear our interval."]}),"\n",(0,i.jsx)(t.p,{children:'Finally, we have the following method, which just logs a "tick" to the console.'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:'updateTicketElapsedWaitTime = () => {\n  console.log("tick");\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["This method is triggered each second in our ",(0,i.jsx)(t.code,{children:"setInterval()"})," function. Right now, it's not doing much. However, this method will be responsible for communicating with Redux in the next lesson."]}),"\n",(0,i.jsxs)(t.p,{children:["Now let's run ",(0,i.jsx)(t.code,{children:"npm start"})," and open the console. Try adding, updating and closing a few tickets. Note the following:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"componentDidMount()"})," is called once, when we run the application. At that point, the timer is triggered and ",(0,i.jsx)(t.code,{children:"tick"})," is logged to the console every second."]}),"\n",(0,i.jsxs)(t.li,{children:["Each time we add, update, or close a ticket, ",(0,i.jsx)(t.code,{children:"component updated!"})," is logged to the console. As we can see, the ",(0,i.jsx)(t.code,{children:"componentDidUpdate()"})," method is triggered each time a change is made to the UI. The timer has no effect on it. If we execute code that doesn't affect the UI, ",(0,i.jsx)(t.code,{children:"componentDidUpdate()"})," won't be triggered. This makes sense, because the component ",(0,i.jsx)(t.em,{children:"itself"})," (eg, its UI) isn't updated."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"componentWillUnmount()"})," is never called. If we think about the structure of our application, this makes sense. ",(0,i.jsx)(t.code,{children:"componentWillUnmount()"})," is called inside ",(0,i.jsx)(t.code,{children:"TicketControl.js"}),". However, this component is essentially a container determining which child component should be rendered \u2014 the ticket list, a ticket form, or the ticket detail. ",(0,i.jsx)(t.code,{children:"TicketControl.js"})," is always there and is never unmounted. On the other hand, all the various child components such as ticket list and our form component are unmounted each time they are closed. Why bother to add code to ",(0,i.jsx)(t.code,{children:"componentWillUnmount()"})," at all then? Well, if our application were to expand and ",(0,i.jsx)(t.code,{children:"TicketControl"})," could be unmounted, we'd want this code to trigger. We are writing code that is both proactive (thinking about future expansion) and defensive (trying to avoid future bugs)."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Now that we have a general sense of how these lifecycle methods work, we are ready to implement time elapsed functionality in our Help Queue. We'll do that in the next lesson."})]})}function h(e={}){const{wrapper:t}={...(0,c.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>l});var o=n(96540);const i={},c=o.createContext(i);function s(e){const t=o.useContext(c);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(c.Provider,{value:t},e.children)}}}]);