"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[50532],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var i=n(96540);const r={},o=i.createContext(r);function s(e){const t=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:t},e.children)}},41958:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/unbalanced_tree-b218695d2c55ea0afda6ec20737ad7b7.png"},44362:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>c,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"capstone/capstone-week-1/binary-search-trees-practice","title":"\u270f\ufe0f Binary Search Trees Practice","description":"Now that you\'re done following along with the lessons to build and traverse a binary search tree, it\'s time for an additional challenge. Try adding the functionality listed below to your application. It\'s okay if you do not get the functionality fully implemented \u2014 these are both challenging features and there\'s a reason we don\'t walk through them in-depth in our curriculum.","source":"@site/versioned_docs/version-WIP/capstone/1_capstone-week-1/binary-search-trees-practice.md","sourceDirName":"capstone/1_capstone-week-1","slug":"/capstone/capstone-week-1/binary-search-trees-practice","permalink":"/WIP/capstone/capstone-week-1/binary-search-trees-practice","draft":false,"unlisted":false,"tags":[],"version":"WIP","sidebarPosition":16,"frontMatter":{"title":"\u270f\ufe0f Binary Search Trees Practice","id":"binary-search-trees-practice","slug":"binary-search-trees-practice","hide_table_of_contents":true,"sidebar_position":16,"day":"monday","type":"exercise","url":"https://github.com/epicodus-curriculum/capstone/blob/main/6_binary_search_tree_practice.md"},"sidebar":"capstone","previous":{"title":"\ud83d\udcd3 Binary Search Trees Part 3","permalink":"/WIP/capstone/capstone-week-1/binary-search-trees-part-3"},"next":{"title":"\ud83d\udcd3 Introduction to Graphs","permalink":"/WIP/capstone/capstone-week-1/introduction-to-graphs"}}');var r=n(74848),o=n(28453);const s={title:"\u270f\ufe0f Binary Search Trees Practice",id:"binary-search-trees-practice",slug:"binary-search-trees-practice",hide_table_of_contents:!0,sidebar_position:16,day:"monday",type:"exercise",url:"https://github.com/epicodus-curriculum/capstone/blob/main/6_binary_search_tree_practice.md"},a=void 0,h={},l=[{value:"Add a <code>BST.prototype.remove()</code> Method",id:"add-a-bstprototyperemove-method",level:3},{value:"Keep the Tree Balanced",id:"keep-the-tree-balanced",level:3}];function d(e){const t={a:"a",code:"code",em:"em",h3:"h3",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"Now that you're done following along with the lessons to build and traverse a binary search tree, it's time for an additional challenge. Try adding the functionality listed below to your application. It's okay if you do not get the functionality fully implemented \u2014 these are both challenging features and there's a reason we don't walk through them in-depth in our curriculum."}),"\n",(0,r.jsxs)(t.h3,{id:"add-a-bstprototyperemove-method",children:["Add a ",(0,r.jsx)(t.code,{children:"BST.prototype.remove()"})," Method"]}),"\n",(0,r.jsx)(t.p,{children:"At first glance, this may not seem overly challenging \u2014 just find and remove a node, right? We already have methods to traverse the tree to insert or find nodes, so why would removing a node be any more difficult?"}),"\n",(0,r.jsx)(t.p,{children:"Well, what happens if you remove a node from the middle of a tree? You can't just leave that space empty \u2014 another node needs to replace it, but which one? And once that node is removed, what about filling in the space that moved node left behind?"}),"\n",(0,r.jsx)(t.p,{children:"Fortunately, we can use a TDD approach to solve this problem one step at a time. See how many steps you can get through on your own \u2014 and then do some research on your own to find a full solution if you can't solve the problem yourself. There are plenty of resources online \u2014 including implementations in JavaScript."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"BST.prototype.remove()"})," method should return ",(0,r.jsx)(t.code,{children:"false"})," if the node to be removed doesn't exist in the tree."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["The method should remove a ",(0,r.jsx)(t.strong,{children:"leaf node"}),". Remember that a leaf node is a node at the very bottom of the tree. That means it doesn't have any children \u2014 and we can simply remove the node."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Don't forget to check if the root node is the only node in the tree \u2014 that would make it a leaf node \u2014 so it's the only one that would need to be updated."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Next, the method should remove a node that has ",(0,r.jsx)(t.strong,{children:"only one child"}),". This is also relatively easy to do. Since there is only one child, the child takes the place of the removed node \u2014 and there is nothing else we need to worry about. This is true even if it is the root node."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Next, the method should remove a node that has ",(0,r.jsx)(t.strong,{children:"two children"}),". This is much harder to do. Several things need to happen."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"First, one of the child nodes needs to take the place of the deleted node. This can be either the left child or the right child. In this case, we will use the left child."}),"\n",(0,r.jsx)(t.li,{children:"Once the former left child has taken the place of the deleted parent node, the former right child becomes the child of its former sibling. In other words, what was once the left child is now the parent of what was once the right child."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"The diagrams below illustrate what happens:"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"The node is removed and its left child takes its place \u2014 which means the right child becomes the child of what used to be its sibling.",src:n(53940).A+"",width:"721",height:"451"})}),"\n",(0,r.jsxs)(t.p,{children:["In the left diagram, ",(0,r.jsx)(t.em,{children:"Node to delete"})," hasn't been deleted yet. We see that it has links to its parent node and two child nodes. All of those connections need to be updated."]}),"\n",(0,r.jsxs)(t.p,{children:["In the right diagram, ",(0,r.jsx)(t.em,{children:"Deleted Node"})," has been removed. ",(0,r.jsx)(t.em,{children:"Former Left Child"})," used to be ",(0,r.jsx)(t.em,{children:"Deleted Node's"})," left child \u2014 but now it has taken its place. Now, ",(0,r.jsx)(t.em,{children:"Deleted Node"})," is no longer ",(0,r.jsx)(t.em,{children:"Former Left Child's"})," parent \u2014 instead ",(0,r.jsx)(t.em,{children:"Parent"})," is. Meanwhile, ",(0,r.jsx)(t.em,{children:"Former Right Child"})," becomes the right child of ",(0,r.jsx)(t.em,{children:"Former Left Child"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"Think of it as two siblings next in line for succession to be the king. The king dies, then the first child becomes the king. The second child is next in line for succession. Any other children of those two children still need to be accounted for!"}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Once you've successfully written a method that replaces a deleted node with its left child, write another that replaces a deleted node with its right child instead."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"keep-the-tree-balanced",children:"Keep the Tree Balanced"}),"\n",(0,r.jsx)(t.p,{children:"Next, we'll move onto another challenging problem. The first couple of steps will be easy to solve, but the problem will get progressively harder. How can we keep a tree balanced? Well, first, we need to think about what it even means for a tree to be balanced. Fortunately, this is actually very easy to do \u2014 the difference between the height of the root's left subtree and the height of the root's right subtree needs to be either 1 or 0. We can depict this with an illustration."}),"\n",(0,r.jsx)(t.p,{children:"Here's an example of a balanced tree with its height:"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"In this illustration, the difference between the subtree&#39;s heights is 1.",src:n(85628).A+"",width:"821",height:"398"})}),"\n",(0,r.jsx)(t.p,{children:"Here we can see that the height of the left subtree is 1 while the height of the right subtree is 2. The difference between those heights is 1 so this is a balanced tree."}),"\n",(0,r.jsx)(t.p,{children:"On the other hand, let's review this illustration of an unbalanced tree from a few lessons ago:"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"The image shows a binary search tree where all child nodes are to the right of their parent node.",src:n(41958).A+"",width:"561",height:"581"})}),"\n",(0,r.jsx)(t.p,{children:"The tree above has a left subtree with a height of 0 and a right subtree with a height of 6 \u2014 a difference much greater than one. This tree isn't balanced at all!"}),"\n",(0,r.jsx)(t.p,{children:"Having a balanced tree makes it more efficient. It means that the maximum number of iterations a search or insert algorithm has to do is approximately the same for both sides of the tree."}),"\n",(0,r.jsx)(t.p,{children:"Try writing an algorithm to check a binary search tree's balance \u2014 and rebalance it if necessary. Make sure to use TDD. Once again, the first few steps are much easier \u2014 but the problem gets progressively harder."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["First, add two properties to the ",(0,r.jsx)(t.code,{children:"BST"})," constructor. One will store the height of the left subtree while the other will store the height of the right subtree. ",(0,r.jsx)(t.strong,{children:"Note:"})," It's considerably harder to compute the height of a tree than to store information about its height. We would need to use a depth-first or breadth-first search to determine the greatest height in a subtree otherwise."]}),"\n",(0,r.jsxs)(t.li,{children:["Next, update the ",(0,r.jsx)(t.code,{children:"BST.prototype.insertNode()"})," method so that it keeps track of the height of an inserted element. That means that each time the method traverses down a node, the temporary height should be increased by one. If the temporary height is greater than the actual height of the subtree when the element is inserted, the actual height should be updated."]}),"\n",(0,r.jsxs)(t.li,{children:["Next, write a ",(0,r.jsx)(t.code,{children:"BST.prototype.check()"})," method. This method will just check to see if the tree is balanced or not. It should return the difference in height between the left and right subtrees."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["The next steps are challenging \u2014 but we recommend trying them out if you have the time. You may want to read this informative article on ",(0,r.jsx)(t.a,{href:"https://adrianmejia.com/self-balanced-binary-search-trees-with-avl-tree-data-structure-for-beginners/",children:"Self-balanced Binary Search Trees with AVL in JavaScript"}),". In addition to having some good basic information on trees, the article describes how to balance a binary search tree."]}),"\n",(0,r.jsx)(t.p,{children:"The article is a full walk-through of the process, so you can choose either to follow along with the coding steps in the article or try to solve at least a few steps of the problem on your own. For a greater challenge, we recommend using the article only for hints and trying to solve as many steps without additional assistance."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["If the tree is imbalanced, use rotation to rebalance the tree. Write and test a ",(0,r.jsx)(t.code,{children:"BST.prototype.rebalance()"})," method."]}),"\n",(0,r.jsx)(t.li,{children:"Finally, try writing an AVL tree. This is a self-balancing tree named for its inventors (Georgy Adelson-Velsky and Evgenii Landis). The article linked above walks through the process."}),"\n"]})]})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},53940:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/tree-node-removal-cacbee9162dd7861b605c56f080e841a.png"},85628:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/balanced-tree-with-height-62343eecdebdaf622514f634b35bfffb.png"}}]);