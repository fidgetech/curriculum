"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[24263],{28453:(e,t,o)=>{o.d(t,{R:()=>r,x:()=>c});var n=o(96540);const i={},s=n.createContext(i);function r(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(s.Provider,{value:t},e.children)}},89522:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"react/react-with-redux/3-3-1-3-adding-combined-reducers-to-react","title":"\ud83d\udcd3 3.3.1.3 Adding Combined Reducers to React","description":"We\'ve successfully added two additional reducers to our application \u2014 one for handling form visibility and another to combine our reducers into a single root reducer. Now we need to refactor our help application to utilize our new root reducer.","source":"@site/versioned_docs/version-WIP/3_react/3_react-with-redux/3-3-1-03-adding-combined-reducers-to-react.md","sourceDirName":"3_react/3_react-with-redux","slug":"/react/react-with-redux/3-3-1-3-adding-combined-reducers-to-react","permalink":"/WIP/react/react-with-redux/3-3-1-3-adding-combined-reducers-to-react","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 3.3.1.3 Adding Combined Reducers to React","day":"monday","id":"3-3-1-3-adding-combined-reducers-to-react","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 3.3.1.2 Combining Redux Reducers","permalink":"/WIP/react/react-with-redux/3-3-1-2-combining-redux-reducers"},"next":{"title":"\ud83d\udcd3 3.3.1.4 Building a React Application with Redux From Scratch","permalink":"/WIP/react/react-with-redux/3-3-1-4-building-a-react-application-with-redux-from-scratch"}}');var i=o(74848),s=o(28453);const r={title:"\ud83d\udcd3 3.3.1.3 Adding Combined Reducers to React",day:"monday",id:"3-3-1-3-adding-combined-reducers-to-react",hide_table_of_contents:!0},c=void 0,a={},d=[{value:"1. Update the Root Reducer",id:"1-update-the-root-reducer",level:3},{value:"2. Update <code>mapStateToProps</code>",id:"2-update-mapstatetoprops",level:3},{value:"3. Remove <code>formVisibleOnPage</code> State From <code>TicketControl.js</code>",id:"3-remove-formvisibleonpage-state-from-ticketcontroljs",level:3},{value:"4. Handle Form Visibility State with Redux",id:"4-handle-form-visibility-state-with-redux",level:3},{value:"5. Change <code>this.state</code> to <code>this.props</code> for Form Visibility Property",id:"5-change-thisstate-to-thisprops-for-form-visibility-property",level:3},{value:"Conclusion",id:"conclusion",level:3}];function l(e){const t={code:"code",div:"div",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"We've successfully added two additional reducers to our application \u2014 one for handling form visibility and another to combine our reducers into a single root reducer. Now we need to refactor our help application to utilize our new root reducer."}),"\n",(0,i.jsx)(t.p,{children:"We'll need to make the following changes:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Pass the root reducer into our store in ",(0,i.jsx)(t.code,{children:"src/index.js"})," (our application entry point \u2014 not the file where our root reducer is stored)!"]}),"\n",(0,i.jsxs)(t.li,{children:["Update our ",(0,i.jsx)(t.code,{children:"mapStateToProps"})," function to handle our new slice of state."]}),"\n",(0,i.jsxs)(t.li,{children:["Remove ",(0,i.jsx)(t.code,{children:"formVisibleOnPage"})," from ",(0,i.jsx)(t.code,{children:"TicketControl"}),"'s state \u2014 our Redux store will handle it now."]}),"\n",(0,i.jsxs)(t.li,{children:["Refactor our application to correctly dispatch the ",(0,i.jsx)(t.code,{children:"'TOGGLE_FORM'"})," action where needed."]}),"\n",(0,i.jsxs)(t.li,{children:["Ensure that our ",(0,i.jsx)(t.code,{children:"TicketControl"})," component receives information about ",(0,i.jsx)(t.code,{children:"formVisibleOnPage"})," from ",(0,i.jsx)(t.code,{children:"this.props"})," (because our props have been mapped from the store) instead of ",(0,i.jsx)(t.code,{children:"this.state"})," (the component's state)."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Because we are refactoring the simplest piece of shared state in our application and moving it into Redux, these changes will be fairly minimal."}),"\n",(0,i.jsx)(t.h3,{id:"1-update-the-root-reducer",children:"1. Update the Root Reducer"}),"\n",(0,i.jsx)(t.p,{children:"First, we need to import our new root reducer into our application's entry point file \u2014 and then pass the root reducer into our store:"}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"src/index.js"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"// import reducer from './reducers/ticket-list-reducer';\nimport rootReducer from './reducers/index';\n\nconst store = createStore(rootReducer);\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We import ",(0,i.jsx)(t.code,{children:"rootReducer"})," and pass it into the store. Note that our previous reducer is now commented-out. We only need to import the root reducer and any other reducer imports can now be removed from this file."]}),"\n",(0,i.jsxs)(t.h3,{id:"2-update-mapstatetoprops",children:["2. Update ",(0,i.jsx)(t.code,{children:"mapStateToProps"})]}),"\n",(0,i.jsxs)(t.p,{children:["Next, we need to update the state we are mapping to props in our ",(0,i.jsx)(t.code,{children:"TicketControl"})," component. Currently, the function returns the following object:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"{\n  mainTicketList: state\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["However, we now want it to return slices of state to be mapped to props. The updated ",(0,i.jsx)(t.code,{children:"mapStateToProps"})," function should look like this:"]}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"components/TicketControl.js"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"...\nconst mapStateToProps = state => {\n  return {\n    mainTicketList: state.mainTicketList,\n    formVisibleOnPage: state.formVisibleOnPage\n  }\n}\n...\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Now each prop corresponds to a property of ",(0,i.jsx)(t.code,{children:"state"}),". We can map as many state slices to props as we need. In this case, we are only using two \u2014 but complex applications could easily have more."]}),"\n",(0,i.jsx)(t.p,{children:"We also need to add prop types as well:"}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"components/TicketControl.js"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"TicketControl.propTypes = {\n  mainTicketList: PropTypes.object,\n  formVisibleOnPage: PropTypes.bool\n};\n"})}),"\n",(0,i.jsxs)(t.h3,{id:"3-remove-formvisibleonpage-state-from-ticketcontroljs",children:["3. Remove ",(0,i.jsx)(t.code,{children:"formVisibleOnPage"})," State From ",(0,i.jsx)(t.code,{children:"TicketControl.js"})]}),"\n",(0,i.jsxs)(t.p,{children:["Next, we will remove the ",(0,i.jsx)(t.code,{children:"formVisibleOnPage"})," property from our ",(0,i.jsx)(t.code,{children:"TicketControl"})," component's state. While we are at it, we will remove any lines where we use React's ",(0,i.jsx)(t.code,{children:"setState()"})," method to update ",(0,i.jsx)(t.code,{children:"formVisibleOnPage"}),". Because Redux will be handling this slice of state, we won't be using React or ",(0,i.jsx)(t.code,{children:"setState()"})," to take care of form visibility any longer."]}),"\n",(0,i.jsxs)(t.p,{children:["Several lines of code need to be removed from ",(0,i.jsx)(t.code,{children:"TicketControl.js"}),". They are commented out in the code below. You may comment out these lines in your code or remove them completely."]}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"components/TicketControl.js"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"...\nconstructor(props) {\n  super(props);\n  console.log(props);\n  this.state = {\n    // formVisibleOnPage: false,\n    selectedTicket: null,\n    editing: false\n  };\n}\n\nhandleClick = () => {\n    if (this.state.selectedTicket != null) {\n      this.setState({\n        // formVisibleOnPage: false,\n        selectedTicket: null,\n        editing: false\n      });\n    } else {\n      // this.setState(prevState => ({\n      //   formVisibleOnPage: !prevState.formVisibleOnPage,\n      // }));\n    }\n  }\n\n...\n\nhandleAddingNewTicketToList = (newTicket) => {\n  const { dispatch } = this.props;\n  const { id, names, location, issue } = newTicket;\n  const action = {\n    type: 'ADD_TICKET',\n    id: id,\n    names: names,\n    location: location,\n    issue: issue,\n  }\n  dispatch(action);\n  // this.setState({formVisibleOnPage: false});\n}\n\n...\n"})}),"\n",(0,i.jsxs)(t.p,{children:["It should be clear where we will need to dispatch Redux actions \u2014 the exact same place where we previously used ",(0,i.jsx)(t.code,{children:"setState()"})," to change our form's visibility. When refactoring an application to use Redux instead of React for state, this can be a very helpful way to see where the refactor needs to happen. We don't necessarily need to create new methods in our components. We just need to rewire the relevant methods to use Redux instead of React for state."]}),"\n",(0,i.jsx)(t.h3,{id:"4-handle-form-visibility-state-with-redux",children:"4. Handle Form Visibility State with Redux"}),"\n",(0,i.jsxs)(t.p,{children:["We're ready to update ",(0,i.jsx)(t.code,{children:"TicketControl.js"})," to use Redux instead of React for form visibility state. As shown in the previous section, we'll need to dispatch actions to our store in two different methods. You may want to try wiring this up yourself before continuing with this lesson \u2014 it's good practice and you learned how to dispatch actions over the weekend homework."]}),"\n",(0,i.jsx)(t.p,{children:"Here are the revised methods. (Note that the commented-out code from the previous section has been removed now.)"}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"components/TicketControl.js"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"...\n\nhandleClick = () => {\n  if (this.state.selectedTicket != null) {\n    this.setState({\n      selectedTicket: null,\n      editing: false\n    });\n  } else {\n    const { dispatch } = this.props;\n    const action = {\n      type: 'TOGGLE_FORM'\n    }\n    dispatch(action);\n  }\n}\n\n...\n\nhandleAddingNewTicketToList = (newTicket) => {\n  const { dispatch } = this.props;\n  const { id, names, location, issue } = newTicket;\n  const action = {\n    type: 'ADD_TICKET',\n    id: id,\n    names: names,\n    location: location,\n    issue: issue,\n  }\n  dispatch(action);\n  const action2 = {\n    type: 'TOGGLE_FORM'\n  }\n  dispatch(action2);\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We deconstruct the dispatch function from ",(0,i.jsx)(t.code,{children:"this.props"})," if needed, define the action in a constant, and then dispatch it."]}),"\n",(0,i.jsxs)(t.p,{children:["Our ",(0,i.jsx)(t.code,{children:"handleClick()"})," method just got a bit more clunky \u2014 but our goal here is to demonstrate combining reducers. If we were to refactor this now, it would probably be best to break it down into two methods."]}),"\n",(0,i.jsxs)(t.p,{children:["Note that the second method above now dispatches two actions. You may be wondering if the code above is smelly or not. It certainly has the potential to be buggy. This is because the ",(0,i.jsx)(t.code,{children:"dispatch()"})," function is asynchronous. If one of our actions depended on the other, we could run into race conditions where the first action isn't complete before the second one starts. In the example above, the two actions aren't dependent on each other. In future lessons, we will learn how to use middleware to deal with this issue."]}),"\n",(0,i.jsxs)(t.h3,{id:"5-change-thisstate-to-thisprops-for-form-visibility-property",children:["5. Change ",(0,i.jsx)(t.code,{children:"this.state"})," to ",(0,i.jsx)(t.code,{children:"this.props"})," for Form Visibility Property"]}),"\n",(0,i.jsxs)(t.p,{children:["This is a small change but a necessary one for our application to work correctly. Currently, our conditional rendering is still using ",(0,i.jsx)(t.code,{children:"this.state.formVisibleOnPage"}),". We need to update that line of code to ",(0,i.jsx)(t.code,{children:"this.props.formVisibleOnPage"})," because information about the property is now coming from ",(0,i.jsx)(t.code,{children:"mapStateToProps"}),". There is only one place in our code that uses this property:"]}),"\n",(0,i.jsx)(t.div,{className:"filename",children:"components/TicketControl.js"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"...\n//else if (this.state.formVisibleOnPage) {\nelse if (this.props.formVisibleOnPage) {\n...\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Change the code from the commented out line (which you can delete) to the active line of code that uses ",(0,i.jsx)(t.code,{children:"this.props"})," instead of ",(0,i.jsx)(t.code,{children:"this.state"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsxs)(t.p,{children:["At this point, we've successfully refactored our application to use a root reducer. We now know how to use our root reducer and ",(0,i.jsx)(t.code,{children:"mapStateToProps"})," to manage multiple reducers and multiple slices of state. We refactored our React Help Queue to use Redux for ",(0,i.jsx)(t.code,{children:"formVisibleOnPage"})," information instead of our component's local state. In the upcoming classwork, you will have the opportunity to refactor the Help Queue to use Redux instead of local state."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);