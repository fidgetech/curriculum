"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[25457],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(96540);const a={},r=s.createContext(a);function i(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:n},e.children)}},30465:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"capstone/capstone-week-1/representing-graph-structures-with-code","title":"\ud83d\udcd3 Representing Graph Structures with Code","description":"In the last lesson, we learned about the basics of graph theory and looked at a few visual representations of graphs. While visualizing graphs is very useful, as we\'ve learned from working with tree structures, we can\'t simply apply visualization to code. For instance, a search tree isn\'t actually a tree in code \u2014 even though we can depict it that way on a piece of paper. Instead, a search tree is simply a series of nodes where the parent nodes have references to their children.","source":"@site/versioned_docs/version-WIP/capstone/1_capstone-week-1/representing-graph-structures-with-code.md","sourceDirName":"capstone/1_capstone-week-1","slug":"/capstone/capstone-week-1/representing-graph-structures-with-code","permalink":"/WIP/capstone/capstone-week-1/representing-graph-structures-with-code","draft":false,"unlisted":false,"tags":[],"version":"WIP","sidebarPosition":18,"frontMatter":{"title":"\ud83d\udcd3 Representing Graph Structures with Code","id":"representing-graph-structures-with-code","slug":"representing-graph-structures-with-code","hide_table_of_contents":true,"sidebar_position":18,"day":"tuesday","type":"lesson","url":"https://github.com/epicodus-curriculum/capstone/blob/main/2_representing_graph_structures_with_code.md"},"sidebar":"capstone","previous":{"title":"\ud83d\udcd3 Introduction to Graphs","permalink":"/WIP/capstone/capstone-week-1/introduction-to-graphs"},"next":{"title":"\ud83d\udcd3 Building Graphs Part 1","permalink":"/WIP/capstone/capstone-week-1/building-graphs-part-1"}}');var a=t(74848),r=t(28453);const i={title:"\ud83d\udcd3 Representing Graph Structures with Code",id:"representing-graph-structures-with-code",slug:"representing-graph-structures-with-code",hide_table_of_contents:!0,sidebar_position:18,day:"tuesday",type:"lesson",url:"https://github.com/epicodus-curriculum/capstone/blob/main/2_representing_graph_structures_with_code.md"},o=void 0,d={},c=[{value:"Edge Lists",id:"edge-lists",level:3},{value:"Adjacency Lists",id:"adjacency-lists",level:3},{value:"Adjacency Matrix",id:"adjacency-matrix",level:3},{value:"Summary",id:"summary",level:3}];function l(e){const n={code:"code",em:"em",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"In the last lesson, we learned about the basics of graph theory and looked at a few visual representations of graphs. While visualizing graphs is very useful, as we've learned from working with tree structures, we can't simply apply visualization to code. For instance, a search tree isn't actually a tree in code \u2014 even though we can depict it that way on a piece of paper. Instead, a search tree is simply a series of nodes where the parent nodes have references to their children."}),"\n",(0,a.jsx)(n.p,{children:"So how can we represent a graph as code? Let's take a look at our interstellar travel again \u2014 but this time we'll make it an undirected graph. The aliens of Wobox are relieved!"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Undirected graph showing connections between planets.",src:t(46668).A+"",width:"371",height:"361"})}),"\n",(0,a.jsx)(n.p,{children:"To simplify things even further, we've also made it so there are no circuits. That means that it's not possible to \"loop\" back to a planet without backtracking."}),"\n",(0,a.jsx)(n.p,{children:"To depict the graph above, we need to know about two things: the nodes and the edges."}),"\n",(0,a.jsx)(n.p,{children:"We can start by storing all the nodes in a data structure such as an array."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const nodes = ["Lub", "Nu", "Zygob", "Wobox", "Cyra"];\n'})}),"\n",(0,a.jsx)(n.p,{children:"So how do we represent the edges? There are several ways to do this."}),"\n",(0,a.jsx)(n.h3,{id:"edge-lists",children:"Edge Lists"}),"\n",(0,a.jsxs)(n.p,{children:["We can use an ",(0,a.jsx)(n.strong,{children:"edge list"})," to list all the edges between various nodes. Each edge can be written as a pair of values. For instance, we could depict the edge between Lub and Nu as:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'["Lub", "Nu"]\n'})}),"\n",(0,a.jsx)(n.p,{children:"To depict all of the edges in our graph, we could do the following:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const edges = [["Lub", "Nu"], ["Zygob", "Nu"], ["Nu", "Wobox"], ["Wobox", "Cyra"]];\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Each pair represents one of the edges in our graph. The order of the pairs doesn't matter. We also only need to depict the pair once and don't also need to have a reversed copy. For instance, since we already have ",(0,a.jsx)(n.code,{children:'["Lub", "Nu"]'}),", we don't need ",(0,a.jsx)(n.code,{children:'["Nu", "Lub"]'}),"."]}),"\n",(0,a.jsx)(n.p,{children:"If we wanted to see if a specific edge exists in a collection where the edges aren't ordered, we'd have to do a linear search through the collection, so that means O(N) runtime."}),"\n",(0,a.jsx)(n.h3,{id:"adjacency-lists",children:"Adjacency Lists"}),"\n",(0,a.jsxs)(n.p,{children:["Another way to represent all the edges in a graph is with an ",(0,a.jsx)(n.strong,{children:"adjacency list"}),". With an adjacency list, we'd list ",(0,a.jsx)(n.em,{children:"all"})," of the nodes that each node is adjacent to. Let's use a JavaScript object to demonstrate."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const adjacencyList = {\n  "Zygob": ["Nu"],\n  "Lub": ["Nu"],\n  "Nu": ["Lub", "Zygob", "Wobox"],\n  "Wobox": ["Nu", "Cyra"],\n  "Cyra": ["Wobox"]\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"As we can see, each node is a key and all of the adjacent nodes are stored as a value. Adjacent nodes are stored multiple times \u2014 as we can see, Lub includes Nu as a value and Nu includes Lub as a value."}),"\n",(0,a.jsx)(n.p,{children:"We can also use an adjacency list to represent directed edges as well. For instance:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const adjacencyList = {\n  "Wobox": [],\n  "Cyra": ["Wobox"]\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"In this adjacency list, Wobox can't reach any nodes but Cyra can reach Wobox. Poor Wobox!"}),"\n",(0,a.jsx)(n.h3,{id:"adjacency-matrix",children:"Adjacency Matrix"}),"\n",(0,a.jsxs)(n.p,{children:["Finally, we can use an ",(0,a.jsx)(n.strong,{children:"adjacency matrix"})," to depict all the edges in a graph. An adjacency matrix uses a series of zeroes and ones or booleans to depict whether two nodes are adjacent or not."]}),"\n",(0,a.jsx)(n.p,{children:"Here's how this looks organized in a table."}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{}),(0,a.jsx)(n.th,{children:"Lub"}),(0,a.jsx)(n.th,{children:"Zygob"}),(0,a.jsx)(n.th,{children:"Cyra"}),(0,a.jsx)(n.th,{children:"Nu"}),(0,a.jsx)(n.th,{children:"Wobox"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Lub"}),(0,a.jsx)(n.td,{children:"0"}),(0,a.jsx)(n.td,{children:"0"}),(0,a.jsx)(n.td,{children:"0"}),(0,a.jsx)(n.td,{children:"1"}),(0,a.jsx)(n.td,{children:"0"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Zygob"}),(0,a.jsx)(n.td,{children:"0"}),(0,a.jsx)(n.td,{children:"0"}),(0,a.jsx)(n.td,{children:"0"}),(0,a.jsx)(n.td,{children:"1"}),(0,a.jsx)(n.td,{children:"0"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Cyra"}),(0,a.jsx)(n.td,{children:"0"}),(0,a.jsx)(n.td,{children:"0"}),(0,a.jsx)(n.td,{children:"0"}),(0,a.jsx)(n.td,{children:"0"}),(0,a.jsx)(n.td,{children:"1"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Nu"}),(0,a.jsx)(n.td,{children:"1"}),(0,a.jsx)(n.td,{children:"1"}),(0,a.jsx)(n.td,{children:"0"}),(0,a.jsx)(n.td,{children:"0"}),(0,a.jsx)(n.td,{children:"1"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Wobox"}),(0,a.jsx)(n.td,{children:"0"}),(0,a.jsx)(n.td,{children:"0"}),(0,a.jsx)(n.td,{children:"1"}),(0,a.jsx)(n.td,{children:"1"}),(0,a.jsx)(n.td,{children:"0"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:"To depict this in JavaScript, we'd use nested arrays to represent each row in the matrix:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const adjacencyMatrix = [\n  [0, 0, 0, 1, 0],\n  [0, 0, 0, 1, 0],\n  [0, 0, 0, 0, 1],\n  [1, 1, 0, 0, 1],\n  [0, 0, 1, 1, 0],\n];\n"})}),"\n",(0,a.jsxs)(n.p,{children:["It may seem silly to represent a planet's relationship with itself in an adjacency matrix. However, there is a type of graph known as a ",(0,a.jsx)(n.strong,{children:"multigraph"})," where nodes can have multiple edges \u2014 including an edge that starts and ends at the same node. For example, a multigraph could look like this (some planets omitted for simplicity)."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"An example of a multigraph.",src:t(45317).A+"",width:"319",height:"307"})}),"\n",(0,a.jsx)(n.p,{children:"For this reason, it makes sense that an adjacency matrix also checks to see if an edge connects a node to itself."}),"\n",(0,a.jsx)(n.p,{children:"Note that an adjacency matrix can also be used to show directed edges. For instance, the intersection of the row Cyra with the column Wobox could have a value of 1 while the intersection of the row Wobox with the column Cyra could be 0. Then the trip to Wobox would be one way after all."}),"\n",(0,a.jsxs)(n.p,{children:["If we want to see whether two nodes are adjacent in an adjacency matrix, we can do so in constant time O(1). For instance, in order to check if Lub and Nu are adjacent, we simply need to check ",(0,a.jsx)(n.code,{children:"adjacencyMatrix[0][3]"}),". In other words, we just need to find the intersection of a specific column and row in the matrix."]}),"\n",(0,a.jsxs)(n.p,{children:["However, there's also a downside. Adjacency matrixes can take up a lot of space, especially when considering ",(0,a.jsx)(n.strong,{children:"sparse"})," graphs. A graph is sparse if it doesn't have very many edges in relation to nodes. Why does this matter in terms of an adjacency matrix? Well, look at all the zeroes in the matrix above. We have to store information about the relationship between ",(0,a.jsx)(n.em,{children:"every pair of nodes in the graph"})," \u2014 even if they don't have an edge between them. That's a lot of empty space that doesn't exist in either an edge list or an adjacency list."]}),"\n",(0,a.jsx)(n.p,{children:"Also, if we want to find all the edges that the row Cyra has, we need to do a linear search of the entire row. Many of those values could be zeroes, so in a large data set, we are searching a lot of elements just to find a few adjacent nodes \u2014 especially in a sparse graph. Meanwhile, in an adjacency list, all the values corresponding to a node would represent adjacent nodes so there are fewer values to iterate through to get all the adjacent nodes."}),"\n",(0,a.jsx)(n.h3,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(n.p,{children:"In this lesson, we've learned three ways to represent the relationships (or edges) between nodes:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Edge lists"}),"\n",(0,a.jsx)(n.li,{children:"Adjacency lists"}),"\n",(0,a.jsx)(n.li,{children:"Adjacency Matrixes"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"In the next lesson, we'll start building out a small TDD application to create a graph, including adding and removing nodes and edges. At that point, we'll be ready to start learning algorithms to traverse a graph."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},45317:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/multigraph-a867bf7e7090901e3e82eed8c6e9053a.png"},46668:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/undirected_graph_planets-228aa3d65a8d55beacab9ea94e2dc59f.png"}}]);