"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[90538],{28453:(e,t,n)=>{n.d(t,{R:()=>d,x:()=>c});var i=n(96540);const o={},s=i.createContext(o);function d(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:d(e.components),i.createElement(s.Provider,{value:t},e.children)}},90427:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>r});const i=JSON.parse('{"id":"react/react-with-redux/3-3-3-5-adding-wait-time-to-the-queue-part-2","title":"\ud83d\udcd3 3.3.3.5 Adding Wait Time to the Queue Part 2","description":"In the last lesson, we covered the \\"business\\" logic for updating a ticket\'s elapsed time in the Redux store. In the process, we had to write and test a reducer action, update and test another reducer action, and write action creators.","source":"@site/versioned_docs/version-WIP/3_react/3_react-with-redux/3-3-3-05-adding-wait-time-to-the-queue-part-2.md","sourceDirName":"3_react/3_react-with-redux","slug":"/react/react-with-redux/3-3-3-5-adding-wait-time-to-the-queue-part-2","permalink":"/WIP/react/react-with-redux/3-3-3-5-adding-wait-time-to-the-queue-part-2","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 3.3.3.5 Adding Wait Time to the Queue Part 2","day":"wednesday","id":"3-3-3-5-adding-wait-time-to-the-queue-part-2","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 3.3.3.4 Adding Wait Time to the Queue","permalink":"/WIP/react/react-with-redux/3-3-3-4-adding-wait-time-to-the-queue"},"next":{"title":"\u270f\ufe0f 3.3.4.1 Forum, Word Puzzle, Tic Tac Toe (Three-Day Project) - Part 3 (day 3)","permalink":"/WIP/react/react-with-redux/3-3-4-1-forum-word-puzzle-tic-tac-toe-three-day-project---part-3-day-3"}}');var o=n(74848),s=n(28453);const d={title:"\ud83d\udcd3 3.3.3.5 Adding Wait Time to the Queue Part 2",day:"wednesday",id:"3-3-3-5-adding-wait-time-to-the-queue-part-2",hide_table_of_contents:!0},c=void 0,a={},r=[{value:"Changes to <code>NewTicketForm.js</code>",id:"changes-to-newticketformjs",level:3},{value:"Changes to <code>TicketControl.js</code>",id:"changes-to-ticketcontroljs",level:3},{value:"Changes to <code>TicketList.js</code>",id:"changes-to-ticketlistjs",level:3},{value:"Changes to <code>Ticket.js</code>",id:"changes-to-ticketjs",level:3},{value:"Changes to <code>EditTicketForm.js</code>",id:"changes-to-editticketformjs",level:3},{value:"Conclusion",id:"conclusion",level:3}];function l(e){const t={code:"code",div:"div",em:"em",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:'In the last lesson, we covered the "business" logic for updating a ticket\'s elapsed time in the Redux store. In the process, we had to write and test a reducer action, update and test another reducer action, and write action creators.'}),"\n",(0,o.jsx)(t.p,{children:"Now that we're ready to implement this functionality in the UI, we should think carefully about where it's needed."}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["We know that a new ticket should have a ",(0,o.jsx)(t.code,{children:"timeOpen"})," and ",(0,o.jsx)(t.code,{children:"formattedWaitTime"})," property, which means that we'll need to add these in ",(0,o.jsx)(t.code,{children:"NewTicketForm.js"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["Next, we'll need to implement a timer in our ",(0,o.jsx)(t.code,{children:"TicketControl"})," component. Fortunately, we added most of the code for that a few lessons ago. We'll go over it again in this lesson."]}),"\n",(0,o.jsxs)(t.li,{children:["When we demonstrated how our timer would work, we created an ",(0,o.jsx)(t.code,{children:"updateTicketElapsedWaitTime()"})," method that logged ",(0,o.jsx)(t.code,{children:'"tick"'})," to the queue. In this lesson, we'll update that method to actually update the elapsed wait time for a ticket."]}),"\n",(0,o.jsxs)(t.li,{children:["Once that's complete, we'll need to pass the ",(0,o.jsx)(t.code,{children:"timeOpen"})," and ",(0,o.jsx)(t.code,{children:"formattedWaitTime"})," properties of a ticket to the ",(0,o.jsx)(t.code,{children:"Ticket"})," component via ",(0,o.jsx)(t.code,{children:"TicketList"}),". (And we can't forget to add PropTypes, either.)"]}),"\n",(0,o.jsxs)(t.li,{children:["We'll also need to make a tweak to our ",(0,o.jsx)(t.code,{children:"EditTicketForm"})," so that ",(0,o.jsx)(t.code,{children:"timeOpen"})," and ",(0,o.jsx)(t.code,{children:"formattedWaitTime"})," don't become undefined when we update tickets."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"To recap, we'll need to make changes to the following five components:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"NewTicketForm.js"}),";"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"TicketControl.js"}),";"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"TicketList.js"}),";"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"Ticket.js"}),";"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"EditTicketForm.js"}),"."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"We'll make the changes in that order."}),"\n",(0,o.jsxs)(t.h3,{id:"changes-to-newticketformjs",children:["Changes to ",(0,o.jsx)(t.code,{children:"NewTicketForm.js"})]}),"\n",(0,o.jsxs)(t.p,{children:["We just need to make a few small changes to ",(0,o.jsx)(t.code,{children:"NewTicketForm.js"}),":"]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"NewTicketForm.js"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"...\nimport { formatDistanceToNow } from 'date-fns';\n...\n\nfunction NewTicketForm(props){\n  function handleNewTicketFormSubmission(event) {\n    event.preventDefault();\n    props.onNewTicketCreation({\n      names: event.target.names.value,\n      location: event.target.location.value, \n      issue: event.target.issue.value,\n      id: v4(),\n      timeOpen: new Date(),\n      formattedWaitTime: formatDistanceToNow(new Date(), {\n        addSuffix: true\n      })\n    });\n  }\n...\n"})}),"\n",(0,o.jsxs)(t.p,{children:["First we need to import date-fns. Then we need to add ",(0,o.jsx)(t.code,{children:"timeOpen"})," and ",(0,o.jsx)(t.code,{children:"formattedWaitTime"})," properties to the ticket object. ",(0,o.jsx)(t.code,{children:"timeOpen"})," will be set to the value of a ",(0,o.jsx)(t.code,{children:"new Date()"}),". That way, when a user adds a ticket via the form and this function is triggered, the current date and time will be created for a ticket's ",(0,o.jsx)(t.code,{children:"timeOpen"})," property. Meanwhile, ",(0,o.jsx)(t.code,{children:"formattedWaitTime"})," will be set to the formatted elapsed time since the ticket was opened. Later, we'll use the date set for ",(0,o.jsx)(t.code,{children:"timeOpen"})," to update the ",(0,o.jsx)(t.code,{children:"formattedWaitTime"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["If we wanted to, we could define ",(0,o.jsx)(t.code,{children:"timeOpen"})," and ",(0,o.jsx)(t.code,{children:"formattedWaitTime"})," in ",(0,o.jsx)(t.code,{children:"TicketControl.js"})," instead. After all, these aren't values that are being pulled from the form. ",(0,o.jsx)(t.code,{children:"TicketControl.js"})," actually processes the new tickets and passes them to the Redux store, so why not add these values to ",(0,o.jsx)(t.code,{children:"TicketControl"}),"'s ",(0,o.jsx)(t.code,{children:"handleAddingNewTicketToList()"})," method instead?"]}),"\n",(0,o.jsxs)(t.p,{children:["An argument could be made for that \u2014 but there are advantages to creating all the properties a ticket needs in the same place. This keeps our code modular and makes it easier for other developers to read. Since ",(0,o.jsx)(t.code,{children:"NewTicketForm"})," already creates the other properties, it makes sense to create the ",(0,o.jsx)(t.code,{children:"timeOpen"})," and ",(0,o.jsx)(t.code,{children:"formattedWaitTime"})," properties here as well."]}),"\n",(0,o.jsxs)(t.h3,{id:"changes-to-ticketcontroljs",children:["Changes to ",(0,o.jsx)(t.code,{children:"TicketControl.js"})]}),"\n",(0,o.jsx)(t.p,{children:"Most of our updates will be made in this component. However, we already implemented almost all of the changes we need when we learned about lifecycle methods and implemented a timer. Here's what we have so far from that lesson:"}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"TicketControl.js"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"...\n\ncomponentDidMount() {\n    this.waitTimeUpdateTimer = setInterval(() =>\n      this.updateTicketElapsedWaitTime(),\n    60000\n    );\n  }\n\n  componentWillUnmount(){\n    clearInterval(this.waitTimeUpdateTimer);\n  }\n\n  updateTicketElapsedWaitTime = () => {\n    // New code will go here.\n  }\n"})}),"\n",(0,o.jsx)(t.p,{children:"A few things to note:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["We've changed the interval of our ",(0,o.jsx)(t.code,{children:"setInterval()"})," function to ",(0,o.jsx)(t.code,{children:"60000"})," because the Help Queue at Epicodus updates every minute."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["There's no need to use the ",(0,o.jsx)(t.code,{children:"componentDidUpdate()"})," lifecycle method here so it's been removed."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["The only other new code we will need to add to ",(0,o.jsx)(t.code,{children:"TicketControl"})," will go in ",(0,o.jsx)(t.code,{children:"updatedTicketElapsedWaitTime()"}),". Every 60 seconds, this function will be called. As you may have already guessed, we'll be dispatching our new action here."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Let's add the code to implement date-fns now:"}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"src/components/TicketControl.js"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"...\nimport { formatDistanceToNow } from 'date-fns';\n...\n\n...\nupdateTicketElapsedWaitTime = () => {\n  const { dispatch } = this.props;\n  Object.values(this.props.mainTicketList).forEach(ticket => {\n      const newFormattedWaitTime = formatDistanceToNow(ticket.timeOpen, {\n        addSuffix: true\n      });\n    const action = a.updateTime(ticket.id, newFormattedWaitTime);\n    dispatch(action);\n  });\n}\n...\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Note that we've added a new import statement to the top of ",(0,o.jsx)(t.code,{children:"TicketControl.js"})," to import the help function ",(0,o.jsx)(t.code,{children:"formatDistanceToNow()"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Next, let's cover exactly what the ",(0,o.jsx)(t.code,{children:"updateTicketElapsedWaitTime"})," function is doing. This will all be review of concepts we've already covered."]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["We start by deconstructing the ",(0,o.jsx)(t.code,{children:"dispatch"})," function from ",(0,o.jsx)(t.code,{children:"this.props"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["We iterate over the values in the ",(0,o.jsx)(t.code,{children:"mainTicketList"}),". For each ticket, we determine the ",(0,o.jsx)(t.code,{children:"formattedWaitTime"})," using the ",(0,o.jsx)(t.code,{children:"formatDistanceToNow()"})," method from date-fns. This time we pass in ",(0,o.jsx)(t.code,{children:"ticket.timeOpen"})," as the first argument. That's because we want to calculate the distance between the time the ticket was first opened that's stored in the ",(0,o.jsx)(t.code,{children:"timeOpen"})," property, and now."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["Note that we use ",(0,o.jsx)(t.code,{children:"forEach()"}),". Technically, we could use ",(0,o.jsx)(t.code,{children:"map()"})," and it would work. However, this function only has side effects (updating the store) and ",(0,o.jsx)(t.code,{children:"map()"})," is supposed to return something without side effects. For that reason, ",(0,o.jsx)(t.code,{children:"forEach()"})," communicates our intentions here."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["There's another important thing to note about this code. It's not going to scale up very well. Every minute, this function will dispatch an action for ",(0,o.jsx)(t.em,{children:"every single ticket"})," in the queue. That wouldn't be very efficient if our queue was meant to handle thousands of tickets. Since this is just a simple implementation \u2014 and our queue doesn't need to handle a lot of tickets anyway \u2014 we won't worry about it. However, you may want to see if you can refactor it to be more efficient on your own."]}),"\n",(0,o.jsxs)(t.h3,{id:"changes-to-ticketlistjs",children:["Changes to ",(0,o.jsx)(t.code,{children:"TicketList.js"})]}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"Ticket.js"})," component needs to have access to the ",(0,o.jsx)(t.code,{children:"formattedWaitTime"})," property. In order to pass these props to ",(0,o.jsx)(t.code,{children:"Ticket.js"}),", though, we first need to pass them to ",(0,o.jsx)(t.code,{children:"TicketList.js"}),", which is the direct parent of ",(0,o.jsx)(t.code,{children:"Ticket.js"})," and the child of ",(0,o.jsx)(t.code,{children:"TicketControl.js"}),":"]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"src/components/TicketList.js"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"...\nfunction TicketList(props){\n  return (\n    <React.Fragment>\n      <hr/>\n      {Object.values(props.ticketList).map((ticket) => {\n        return <Ticket\n          whenTicketClicked = { props.onTicketSelection }\n          names={ticket.names}\n          location={ticket.location}\n          issue={ticket.issue}\n          formattedWaitTime={ticket.formattedWaitTime}\n          id={ticket.id}\n          key={ticket.id}/>\n  })}\n    </React.Fragment>\n  );\n}\n...\n"})}),"\n",(0,o.jsxs)(t.p,{children:["We just add ",(0,o.jsx)(t.code,{children:"formattedWaitTime"})," as a prop to pass down to ",(0,o.jsx)(t.code,{children:"Ticket.js"}),". We don't need to pass ",(0,o.jsx)(t.code,{children:"timeOpen"})," as a prop because we won't be displaying it in ",(0,o.jsx)(t.code,{children:"Ticket.js"}),". We'll only be showing the ",(0,o.jsx)(t.code,{children:"formattedWaitTime"}),"."]}),"\n",(0,o.jsxs)(t.h3,{id:"changes-to-ticketjs",children:["Changes to ",(0,o.jsx)(t.code,{children:"Ticket.js"})]}),"\n",(0,o.jsxs)(t.p,{children:["Now we just need to add ",(0,o.jsx)(t.code,{children:"formattedWaitTime"})," as a prop type to ",(0,o.jsx)(t.code,{children:"Ticket.js"})," and then actually use the prop in our React fragment:"]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"src/components/Ticket.js"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"...\n\nfunction Ticket(props){\n  return (\n    <React.Fragment>\n      <div onClick = {()=> props.whenTicketClicked(props.id)}>\n        <h3>{props.location} - {props.names}</h3>\n        <p><em>{props.issue}</em></p>\n        { /* new code below. */}\n        <p><em>{props.formattedWaitTime}</em></p>\n        <hr/>\n      </div>\n    </React.Fragment>\n  );\n}\n\nTicket.propTypes = {\n  // New prop type added.\n  ...\n  formattedWaitTime: PropTypes.string\n};\n\n...\n"})}),"\n",(0,o.jsx)(t.p,{children:"Only two lines of code have been added here. Comments have been included to highlight the new lines of code."}),"\n",(0,o.jsxs)(t.h3,{id:"changes-to-editticketformjs",children:["Changes to ",(0,o.jsx)(t.code,{children:"EditTicketForm.js"})]}),"\n",(0,o.jsxs)(t.p,{children:["If we run our application, everything will work correctly when we add a new ticket. The time for a new ticket will display as ",(0,o.jsx)(t.code,{children:"'less than a minute ago'"}),". If we wait a minute, it will update to ",(0,o.jsx)(t.code,{children:"'One minute ago'"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"However, if we edit a ticket, the elapsed time will no longer display. See if you can figure out the issue on your own first \u2014 it's a quick fix."}),"\n",(0,o.jsxs)(t.p,{children:["The issue is in the ",(0,o.jsx)(t.code,{children:"handleEditTicketFormSubmission()"})," function. When we call ",(0,o.jsx)(t.code,{children:"props.onEditTicket()"}),", we don't specify that the ",(0,o.jsx)(t.code,{children:"timeOpen"})," and ",(0,o.jsx)(t.code,{children:"formattedWaitTime"})," properties should be included in the ticket object. Remember that when we update a ticket, it's almost exactly the same as adding a new ticket \u2014 we just happen to be overwriting the pre-existing ticket with the same ",(0,o.jsx)(t.code,{children:"id"}),". To fix this issue, we just need to pass the ",(0,o.jsx)(t.code,{children:"timeOpen"})," and ",(0,o.jsx)(t.code,{children:"formattedWaitTime"})," properties into the method."]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"src/components/EditTicketForm.js"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"...\nfunction handleEditTicketFormSubmission(event) {\n  event.preventDefault();\n  props.onEditTicket({\n    names: event.target.names.value, \n    location: event.target.location.value, \n    issue: event.target.issue.value, \n    id: ticket.id, \n    timeOpen: ticket.timeOpen, \n    formattedWaitTime: ticket.formattedWaitTime \n  });\n}\n...\n"})}),"\n",(0,o.jsx)(t.p,{children:"At this point, our Help Queue should now show the elapsed time since the ticket was opened regardless of whether the ticket was updated."}),"\n",(0,o.jsx)(t.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(t.p,{children:"As we've already stated, you won't be expected to add this kind of functionality to your independent projects. The most important takeaway from these lessons isn't using a timer or incorporating date-fns \u2014 although it's fun to do both \u2014 or getting the Help Queue fully functional. Instead, it's essential to know about how the component lifecycle works \u2014 and to have at least a basic understanding of the following methods and what they do:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"constructor()"}),": Called when a state-based component is instantiated;"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"render()"}),": Called both when a component is being loaded and also when it's updated;"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"componentDidMount()"}),": Called when a component has finished updating the DOM;"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"componentDidUpdate()"}),": Called immediately after a component updates;"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"componentWillUnmount()"}),"; Called right before a component is unmounted and destroyed."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);