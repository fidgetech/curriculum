"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[16249],{17374:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"react/functional-programming-with-javascript/4-1-0-11-map-reduce-and-filter","title":"\ud83d\udcd3 4.1.0.11 Map, Reduce and Filter","description":"JavaScript provides some built-in methods that are commonly used in functional programming. In fact, we already have experience with Array.prototype.map(), one of the most popular of these methods.","source":"@site/docs/4_react/1_functional-programming-with-javascript/4-1-0-11-map-reduce-and-filter.md","sourceDirName":"4_react/1_functional-programming-with-javascript","slug":"/react/functional-programming-with-javascript/4-1-0-11-map-reduce-and-filter","permalink":"/v1.2/react/functional-programming-with-javascript/4-1-0-11-map-reduce-and-filter","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 4.1.0.11 Map, Reduce and Filter","day":"weekend","id":"4-1-0-11-map-reduce-and-filter","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 4.1.0.10 Currying","permalink":"/v1.2/react/functional-programming-with-javascript/4-1-0-10-currying"},"next":{"title":"\ud83d\udcd3 4.1.0.12 Recursion","permalink":"/v1.2/react/functional-programming-with-javascript/4-1-0-12-recursion"}}');var r=a(74848),o=a(28453);const i={title:"\ud83d\udcd3 4.1.0.11 Map, Reduce and Filter",day:"weekend",id:"4-1-0-11-map-reduce-and-filter",hide_table_of_contents:!0},s=void 0,l={},c=[{value:"<code>map()</code>",id:"map",level:2},{value:"<code>reduce()</code>",id:"reduce",level:2},{value:"<code>filter()</code>",id:"filter",level:2},{value:"Summary",id:"summary",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["JavaScript provides some built-in methods that are commonly used in functional programming. In fact, we already have experience with ",(0,r.jsx)(n.code,{children:"Array.prototype.map()"}),", one of the most popular of these methods."]}),"\n",(0,r.jsxs)(n.p,{children:["We'll start by taking a look at why ",(0,r.jsx)(n.code,{children:"map()"})," is so useful in functional programming. Then we'll cover ",(0,r.jsx)(n.code,{children:"reduce()"})," and ",(0,r.jsx)(n.code,{children:"filter()"}),", two other extremely popular methods used in functional programming."]}),"\n",(0,r.jsx)(n.h2,{id:"map",children:(0,r.jsx)(n.code,{children:"map()"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["Let's say we want to take all the numbers in an array and multiply them by 2. We'll quickly compare how we can solve this problem using both a loop and ",(0,r.jsx)(n.code,{children:"map()"}),". This is review from Introduction to Programming:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const numArray = [1, 2, 3, 4, 5];\nlet doubledArray = [];\nnumArray.forEach(function(element) {\n  doubledArray.push(element * 2);\n});\ndoubledArray;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the example above, we use ",(0,r.jsx)(n.code,{children:"forEach()"})," to double each element in an array. From a functional perspective, there are several issues:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"We must initialize an empty array and then store the new values in this array. As a result, we are mutating an array instead of creating a new constant. This is something we want to avoid."}),"\n",(0,r.jsx)(n.li,{children:"The example above is imperative instead of declarative. We are telling the computer exactly what to do (imperative) instead of telling the computer the end result we want (declarative)."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Now let's look at ",(0,r.jsx)(n.code,{children:"map()"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const numArray = [1, 2, 3, 4, 5];\nconst doubledArray = numArray.map(function(element) {\n  return element * 2;\n});\ndoubledArray;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the example above, we don't mutate an array. Instead, we save mapped ",(0,r.jsx)(n.code,{children:"numArray"})," into a new constant."]}),"\n",(0,r.jsx)(n.p,{children:"The example above is declarative, not imperative. We don't explicitly tell the computer to initialize a new array, loop through an array of numbers, double each element in the array, and then push those doubled numbers into the initialized array. Instead, we just tell the computer that we want a new array with each value doubled."}),"\n",(0,r.jsxs)(n.p,{children:["We can make ",(0,r.jsx)(n.code,{children:"map()"})," even more concise with arrow functions:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const doubledArray = numArray.map (e => e * 2);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Remember that with arrow functions we can take advantage of implicit return so we don't need to explicitly state ",(0,r.jsx)(n.code,{children:"return"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["We also make the variable more abstract (",(0,r.jsx)(n.code,{children:"e"})," instead of ",(0,r.jsx)(n.code,{children:"element"}),"), which makes this even more concise and abstracted."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Use ",(0,r.jsx)(n.code,{children:"Array.prototype.map()"})," whenever you want to modify every element in an array."]})}),"\n",(0,r.jsx)(n.h2,{id:"reduce",children:(0,r.jsx)(n.code,{children:"reduce()"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["We can use ",(0,r.jsx)(n.code,{children:"Array.prototype.reduce()"})," to reduce an array to a single element. One of the most common usages is to sum an array:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const numArray = [3, 7, 5];\nconst summedArray = numArray.reduce(function(currentValue, element) {\n  return element + currentValue;\n}, 0);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the example above, reduce takes two arguments. The first is the ",(0,r.jsx)(n.code,{children:"currentValue"})," of the ",(0,r.jsx)(n.code,{children:"reduce()"})," function. The second is the ",(0,r.jsx)(n.code,{children:"element"})," of the array. Finally, note the ",(0,r.jsx)(n.code,{children:"0"})," after the function itself. This is an initial value that we can optionally provide. That way, ",(0,r.jsx)(n.code,{children:"reduce()"})," knows what the ",(0,r.jsx)(n.code,{children:"currentValue"})," will start with. Note that if we wanted to multiply or divide, this initial value would be ",(0,r.jsx)(n.code,{children:"1"}),". Otherwise, we'd be multiplying or dividing by zero!"]}),"\n",(0,r.jsxs)(n.p,{children:["While this functionality is very helpful, we can use ",(0,r.jsx)(n.code,{children:"reduce()"})," to do so much more. For example, we can use ",(0,r.jsx)(n.code,{children:"reduce()"})," to do things like find the longest or shortest string in an array. However, we won't provide a code snippet for that here. Instead, let's look at a more complex example."]}),"\n",(0,r.jsx)(n.p,{children:"Let's say we have a group of friends that are planning on spending a weekend at the ocean. We have a data set that lists each friend's name as well as an array of the three things each friend most wants to do on the coast:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const friends = [\n  {\n    name: "Jasmine",\n    wantToDo: ["hike", "go out to eat", "swim"]\n  },\n  {\n    name: "Ada",\n    wantToDo: ["play games", "hike", "cook meals"]\n  },\n  {\n    name: "Desmond",\n    wantToDo: ["sleep", "swim", "play games"]\n  },\n  {\n    name: "Andres",\n    wantToDo: ["hike", "swim", "play games"]\n  }\n];\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Next, we want to determine which ",(0,r.jsx)(n.code,{children:"wantToDo"}),"s are most popular \u2014 that will help this group of friends determine how to spend the weekend."]}),"\n",(0,r.jsxs)(n.p,{children:["How could ",(0,r.jsx)(n.code,{children:"reduce()"})," possibly be helpful for this? Well, ",(0,r.jsx)(n.code,{children:"reduce()"})," is extremely helpful for manipulating data. In the example above, it would be difficult to find the most popular ",(0,r.jsx)(n.code,{children:"wantToDo"}),"s based on the structure of this data set. After all, the data we want is nested pretty deeply: we are looking for a series of arrays that are contained within the property of a series of objects which are in turn contained in an array."]}),"\n",(0,r.jsxs)(n.p,{children:["Fortunately, we can use ",(0,r.jsx)(n.code,{children:"reduce()"})," to turn our array of objects into an array that contains all of our ",(0,r.jsx)(n.code,{children:"wantToDo"}),"s:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const toDos = friends.reduce(function(array, friend) {\n  return array.concat(friend.wantToDo);\n}, []);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the snippet above, our initial condition is an empty array ",(0,r.jsx)(n.code,{children:"[]"}),". ",(0,r.jsx)(n.code,{children:"reduce()"})," will iterate through each ",(0,r.jsx)(n.code,{children:"friend"})," and return their ",(0,r.jsx)(n.code,{children:"wantToDo"})," property, which will be concatenated into our ",(0,r.jsx)(n.code,{children:"array"}),". Think of this as being like summing an array of numbers. However, in this case, instead of adding numbers, we are adding arrays to our original array. Because we are using ",(0,r.jsx)(n.code,{children:"concat"}),", which will add two arrays together into one larger array, our final result will be a series of arrays reduced into one single larger array:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'> toDos\n["hike", "go out to eat", "swim", "play games", "hike", "cook meals", "sleep", "swim", "play games", "hike", "swim", "play games"]`\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Now we have a more manageable dataset to work with. Let's use ",(0,r.jsx)(n.code,{children:"reduce()"})," yet again. This time, we will create a ",(0,r.jsx)(n.code,{children:"voteTally"})," object with key-value pairs. Each key will be a ",(0,r.jsx)(n.code,{children:"toDo"})," while the value of the key will be the number of times it shows up in the array. Here's how we can do this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const toDoTally = toDos.reduce(function(voteTally, toDo) {\n  voteTally[toDo] = (voteTally[toDo] || 0) + 1;\n  return voteTally;\n}, {});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In this snippet, our ",(0,r.jsx)(n.code,{children:"voteTally"})," starts with an initial value ",(0,r.jsx)(n.code,{children:"{}"}),". We will be adding key-value pairs to this object. We will set the value of the key in this line: ",(0,r.jsx)(n.code,{children:"voteTally[toDo] = (voteTally[toDo] || 0) + 1;"}),". Note the or (",(0,r.jsx)(n.code,{children:"||"}),") syntax here. This states that if there is no key ",(0,r.jsx)(n.code,{children:"voteTally[toDo]"})," in the object, then the value of ",(0,r.jsx)(n.code,{children:"voteTally[toDo]"})," should be set to 0. Otherwise, we'll use the value that already exists in the key. Finally, we'll increment the value by 1."]}),"\n",(0,r.jsx)(n.p,{children:"This returns the following:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'> toDoTally\n{\n  "hike:": 3,\n  "go out to eat": 1,\n  "swim": 3,\n  "play games": 3,\n  "cook meals": 1,\n  "sleep": 1\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Now we have a tally of each ",(0,r.jsx)(n.code,{children:"wantToDo"})," stored in a single object. Finally, we can sort this if we wish:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const mostPopular = Object.entries(toDoTally).sort(function(a,b) { return b[1] - a[1] });\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We pass an object as an argument into ",(0,r.jsx)(n.code,{children:"Object.entries()"}),", which will return all the key-value pairs in that object in the form of an array. Now we can sort these in descending order. If you aren't familiar with how ",(0,r.jsx)(n.code,{children:"sort()"})," works, check the Mozilla ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort",children:"documentation"}),". We won't explain it in depth here because ",(0,r.jsx)(n.code,{children:"sort()"})," mutates the array it is called on, which means it's generally a poor choice for functional programming. However, in the example above, at least we aren't mutating a variable. Nor is ",(0,r.jsx)(n.code,{children:"Object.entries(toDoTally)"})," a previously existing array, which makes it more acceptable here. This returns the following array of arrays:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'> mostPopular\n[["hike", 3], ["swim", 3], ["play games", 3], ["go out to eat", 1], ["cook meals", 1], ["sleep", 1]]\n'})}),"\n",(0,r.jsx)(n.p,{children:"Now we can clearly see that this group of friends would like to spend the weekend hiking, swimming, and playing games."}),"\n",(0,r.jsxs)(n.p,{children:["We can use ",(0,r.jsx)(n.code,{children:"reduce()"})," to manipulate much larger datasets as well. Note that our goal won't always be to come up with a final answer with ",(0,r.jsx)(n.code,{children:"reduce()"}),". Sometimes we might just want to take a dataset and then manipulate it into something more manageable to work with."]}),"\n",(0,r.jsxs)(n.p,{children:["At this point, it should be clear that we can use ",(0,r.jsx)(n.code,{children:"reduce()"})," to reduce arrays into any type of object, not just a string or a number. Many of the most powerful applications of ",(0,r.jsx)(n.code,{children:"reduce()"})," involve returning another array or an object."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Use ",(0,r.jsx)(n.code,{children:"Array.prototype.reduce()"}),' whenever you want to "reduce" an array down to a single element.']})}),"\n",(0,r.jsx)(n.h2,{id:"filter",children:(0,r.jsx)(n.code,{children:"filter()"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["We can use ",(0,r.jsx)(n.code,{children:"Array.prototype.filter()"})," any time we want to filter an array or collection based on certain conditions. For instance, let's say we want to filter the following array to only include numbers greater than 10:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const numArray = [7, 14, 32, 8];\nconst filteredArray = numArray.filter(e => e > 10);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the example above, we simply have to specify the condition (",(0,r.jsx)(n.code,{children:"e > 10"}),") that we want our final array to have. This is very declarative!"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"filter()"})," is extremely powerful. For instance, we can use it to \"search\" an array of objects by a specific property. Here's an example. Let's say we want to find all the employees at a company that are developers from the following array of objects:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const employees = [\n  {\n    name: "Ada",\n    role: "developer"\n  },\n  {\n    name: "Tom",\n    role: "HR"\n  },\n  {\n    name: "Jasmine",\n    role: "developer"\n  },\n  {\n    name: "Hank",\n    role: "administrative assistant"\n  }\n];\n'})}),"\n",(0,r.jsx)(n.p,{children:"Now we can use filter to see which employees are developers:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"> const developers = employees.filter(e => e.role === \"developer\");\n[ { name: 'Ada', role: 'developer' },\n  { name: 'Jasmine', role: 'developer' } ]\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We simply need to specify which employee has a ",(0,r.jsx)(n.code,{children:"role"})," equal to ",(0,r.jsx)(n.code,{children:'"developer"'}),", which we do with ",(0,r.jsx)(n.code,{children:'e.role === "developer"'}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Use ",(0,r.jsx)(n.code,{children:"Array.prototype.filter()"})," whenever you want to filter an array based on certain conditions."]})}),"\n",(0,r.jsx)(n.h3,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"In this lesson, we explored how we can use three common JavaScript array methods in functional programming. Remember that looping is imperative while the three methods detailed above are declarative. Just as importantly, none of these three methods mutate state. They all return new results, which makes them excellent for immutability."}),"\n",(0,r.jsx)(n.p,{children:"Try finding use cases in your own applications to apply these three methods. You will also get a chance to whiteboard with these methods in this course section."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>s});var t=a(96540);const r={},o=t.createContext(r);function i(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);