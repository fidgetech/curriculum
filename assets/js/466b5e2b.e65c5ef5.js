"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[51623],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var s=n(96540);const o={},i=s.createContext(o);function a(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:t},e.children)}},61506:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"c-and-net/database-basics/3-3-0-09-using-the-test-database","title":"\ud83d\udcd3 3.3.0.09 Using the Test Database","description":"In this lesson, we\'ll connect our test project to the test database and update our teardown method to empty it.","source":"@site/versioned_docs/version-v1_3/3_c-and-net/3_database-basics/3-3-0-09-using-the-test-database.md","sourceDirName":"3_c-and-net/3_database-basics","slug":"/c-and-net/database-basics/3-3-0-09-using-the-test-database","permalink":"/v1.3/c-and-net/database-basics/3-3-0-09-using-the-test-database","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 3.3.0.09 Using the Test Database","day":"weekend","id":"3-3-0-09-using-the-test-database","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.3.0.08 Creating a Test Database: Exporting and Importing Databases with MySQL Workbench","permalink":"/v1.3/c-and-net/database-basics/3-3-0-08-creating-a-test-database-exporting-and-importing-databases-with-mysql-workbench"},"next":{"title":"\ud83d\udcd3 3.3.0.10 Deleting Objects in the Database","permalink":"/v1.3/c-and-net/database-basics/3-3-0-10-deleting-objects-in-the-database"}}');var o=n(74848),i=n(28453);const a={title:"\ud83d\udcd3 3.3.0.09 Using the Test Database",day:"weekend",id:"3-3-0-09-using-the-test-database",hide_table_of_contents:!0},c=void 0,r={},d=[{value:"Using the Test Database",id:"using-the-test-database",level:2}];function l(e){const t={code:"code",div:"div",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"In this lesson, we'll connect our test project to the test database and update our teardown method to empty it."}),"\n",(0,o.jsx)(t.h2,{id:"using-the-test-database",children:"Using the Test Database"}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsxs)(t.p,{children:["First, let's run ",(0,o.jsx)(t.code,{children:"dotnet restore"})," in our ",(0,o.jsx)(t.code,{children:"ToDoList.Tests"})," directory to update the Tests project with the MySqlConnector package that we added to the production project."]}),"\n",(0,o.jsxs)(t.p,{children:["Next, let's update ",(0,o.jsx)(t.code,{children:"appsettings.json"})," in our production directory to include a new database connection string, this time for our test database. As usual, make sure to update the ",(0,o.jsx)(t.code,{children:"pwd"})," and ",(0,o.jsx)(t.code,{children:"uid"})," keys with your own values. In the lessons in LearnHowToProgram.com, we always assume the ",(0,o.jsx)(t.code,{children:"uid"})," is ",(0,o.jsx)(t.code,{children:"root"})," and the ",(0,o.jsx)(t.code,{children:"pwd"})," is ",(0,o.jsx)(t.code,{children:"epicodus"}),"."]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"ToDoList/appsettings.json"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-json",children:'{\n  "ConnectionStrings": {\n      "DefaultConnection": "Server=localhost;Port=3306;database=to_do_list_with_mysqlconnector;uid=[YOUR-USERNAME-HERE];pwd=[YOUR-PASSWORD-HERE];",\n      "TestConnection": "Server=localhost;Port=3306;database=to_do_list_with_mysqlconnector_test;uid=[YOUR-USERNAME-HERE];pwd=[YOUR-PASSWORD-HERE];"\n  }\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Next, we'll refactor our existing ",(0,o.jsx)(t.code,{children:"ItemTests.cs"})," file. Take a look at the new code, and then we'll discuss it below."]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"ToDoList.Tests/ModelTests/ItemTests.cs"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:'using Microsoft.Extensions.Configuration;\n...\n\nnamespace ToDoList.Tests\n{\n\n  [TestClass]\n  public class ItemTests : IDisposable\n  {\n    // we\'ve added a new property\n    public IConfiguration Configuration { get; set; }\n\n    public void Dispose()\n    {\n      Item.ClearAll();\n    }\n\n    // we\'ve added a constructor\n    public ItemTests()\n    {\n      IConfigurationBuilder builder = new ConfigurationBuilder()\n          .AddJsonFile("appsettings.json");\n      Configuration = builder.Build();\n      DBConfiguration.ConnectionString = Configuration["ConnectionStrings:TestConnection"];\n    }\n\n    // existing tests here\n    ...\n\n  }\n}\n'})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["First, we include a new ",(0,o.jsx)(t.code,{children:"using"})," directive to import ",(0,o.jsx)(t.code,{children:"Microsoft.Extensions.Configuration"})," namespace. From this namespace, we'll use the ",(0,o.jsx)(t.code,{children:"ConfigurationBuilder();"})," method to load ",(0,o.jsx)(t.code,{children:"appsettings.json"})," with our app's configurations."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"Then we create a property that we'll use to same our app's configurations."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["Finally, we set up a constructor for the ",(0,o.jsx)(t.code,{children:"ItemTests"})," class that does the work of setting up the database connection:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["We create a ",(0,o.jsx)(t.code,{children:"Configuration"})," object that includes all of the data in our ",(0,o.jsx)(t.code,{children:"appsettings.json"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["We set ",(0,o.jsx)(t.code,{children:"DBConfiguration.ConnectionString"})," to the ",(0,o.jsx)(t.code,{children:'"TestConnection"'})," database connection string, which we access through the ",(0,o.jsx)(t.code,{children:"Configuration"})," object. This overrides the ",(0,o.jsx)(t.code,{children:"DBConfiguration.ConnectionString"})," we set in ",(0,o.jsx)(t.code,{children:"DatabaseConfig.cs"}),", ensuring that our tests are connected to our test database, not our development database."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Take note of one detail: we're loading our app's configurations with different tools than we use in ",(0,o.jsx)(t.code,{children:"Program.cs"}),". In ",(0,o.jsx)(t.code,{children:"Program.cs"}),", ",(0,o.jsx)(t.code,{children:"appsettings.json"})," is implicitly loaded when we create a ",(0,o.jsx)(t.code,{children:"WebApplicationBuilder"})," with the ",(0,o.jsx)(t.code,{children:"WebApplication.CreateBuilder(args);"})," method. This does not happen with the ",(0,o.jsx)(t.code,{children:"ConfigurationBuilder()"})," method that we use in ",(0,o.jsx)(t.code,{children:"ItemTests.cs"}),". Instead, we need to load application configurations manually, which is why we call ",(0,o.jsx)(t.code,{children:'.AddJsonFile("appsettings.json");'}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["The scope of these two methods is also different: ",(0,o.jsx)(t.code,{children:"ConfigurationBuilder()"})," focuses on creating a configuration object, which is one aspect of creating a web application host, whereas ",(0,o.jsx)(t.code,{children:"WebApplication.CreateBuilder();"})," creates a basic web application host. It's not important to remember these details, just to note that we're using two different processes of loading ",(0,o.jsx)(t.code,{children:"appsettings.json"})," in our project."]}),"\n",(0,o.jsxs)(t.p,{children:["Finally, note that our ",(0,o.jsx)(t.code,{children:"ClearAll()"})," method isn't programmed to interact with the database yet, but we'll tackle that in the next lesson."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);