"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[15427],{15186:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"capstone/capstone-week-2/recap-recursion","title":"\ud83d\udcd3 Recap: Recursion","description":"Writing a Recursive Function","source":"@site/docs/capstone/2_capstone-week-2/recap-recursion.md","sourceDirName":"capstone/2_capstone-week-2","slug":"/capstone/capstone-week-2/recap-recursion","permalink":"/v1.2/capstone/capstone-week-2/recap-recursion","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"title":"\ud83d\udcd3 Recap: Recursion","id":"recap-recursion","slug":"recap-recursion","hide_table_of_contents":true,"sidebar_position":8,"day":"monday","type":"lesson","url":"https://github.com/epicodus-curriculum/capstone/blob/main/recursion_recap.md"},"sidebar":"capstone","previous":{"title":"\ud83d\udcd3 Recap: Whiteboarding Best Practices","permalink":"/v1.2/capstone/capstone-week-2/recap-whiteboarding-best-practices"},"next":{"title":"\u270f\ufe0f Whiteboarding Practice - Week 1","permalink":"/v1.2/capstone/capstone-week-2/whiteboarding-practice---week-1"}}');var s=t(74848),i=t(28453);const c={title:"\ud83d\udcd3 Recap: Recursion",id:"recap-recursion",slug:"recap-recursion",hide_table_of_contents:!0,sidebar_position:8,day:"monday",type:"lesson",url:"https://github.com/epicodus-curriculum/capstone/blob/main/recursion_recap.md"},o=void 0,a={},l=[{value:"Writing a Recursive Function",id:"writing-a-recursive-function",level:2}];function u(e){const n={code:"code",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"writing-a-recursive-function",children:"Writing a Recursive Function"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"Welcome back to Recursion. Let's take a quick look back at the basics behind recursion."}),"\n",(0,s.jsxs)(n.p,{children:["Let's start by looking at a very simple example of a recursive function. This function will increment a counter 3 times. We could easily do this with a ",(0,s.jsx)(n.code,{children:"for"})," loop like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let counter = 0\nfor (let i = 0; i < 3 ; i++ ) {\n counter += 1\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Once this loop is complete, the value of ",(0,s.jsx)(n.code,{children:"counter"})," will be ",(0,s.jsx)(n.code,{children:"3"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Now let's solve this same problem recursively:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const incrementCounter = (counter) => {\n if (counter >= 3) {\n   return counter;\n } else {\n   console.log(counter);\n   return incrementCounter(counter + 1);\n }\n}\n\n\nincrementCounter(0);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Our recursive function includes two conditionals. The first includes what is called the ",(0,s.jsx)(n.strong,{children:"base case"}),". This is the final condition where our function will stop calling itself. If we don't have a base case, a recursive function will call itself forever."]}),"\n",(0,s.jsxs)(n.p,{children:["The second conditional includes the recursion itself. Each time this conditional is reached, the function will call itself. The argument we pass in is ",(0,s.jsx)(n.code,{children:"counter + 1"})," because we want the new value of the counter to be incremented by one."]}),"\n",(0,s.jsxs)(n.p,{children:["We've also added a ",(0,s.jsx)(n.code,{children:"console.log()"})," so you can see the incrementing value in the console. Now, if you put this recursive function in the terminal, you'll see each value logged when you call ",(0,s.jsx)(n.code,{children:"incrementCounter(0);"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["However, be careful! Recursive functions should always include one more thing: a ",(0,s.jsx)(n.strong,{children:"termination case"}),". This case determines what the function should do if something goes wrong. For instance, if we were to pass a string into this function as it's currently written, the function will create an infinite loop because the function will just concatenate another ",(0,s.jsx)(n.code,{children:"1"})," to the string each time it's called."]}),"\n",(0,s.jsx)(n.p,{children:"Let's add a termination condition now:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const incrementCounter = (counter) => {\n // This is the termination condition.\n if (isNaN(counter)) {\n   return;\n }\n if (counter >= 3) {\n   return counter;\n } else {\n   console.log(counter);\n   return incrementCounter(counter + 1);\n }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["As we can see, we added a conditional to see if ",(0,s.jsx)(n.code,{children:"counter"})," is ",(0,s.jsx)(n.code,{children:"NaN"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"To recap, there are three main parts to a recursive function:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Base case"}),": The final condition of a successfully called recursive function."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Termination case"}),": A conditional that's called if something goes wrong. This prevents an infinite loop."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Recursion"}),": This part of the function is where the magic happens and the function calls itself."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["There's another very important aspect of recursive functions that can be difficult to understand at first. Each time we call ",(0,s.jsx)(n.code,{children:"incrementCounter()"})," again, we are still in the process of calling the previous function. When we are calling the function for the third time, both the first and second function call are still in process."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"incrementCounter() {\n // This call will complete last.\n return incrementCounter() {\n   // This call will complete second.\n   return incrementCounter() {\n     // This call will complete first.\n   }\n }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note the order that the functions above will be called in. This is because all functions in process go on the JavaScript stack. The stack is a place where all the actions that need to be completed are stored. The JS stack works on the principle of ",(0,s.jsx)(n.strong,{children:"LIFO"}),', which means "last in, first out." This is why the innermost function in the example above will complete first while the outermost function will complete last.']}),"\n",(0,s.jsxs)(n.p,{children:["Let's look at another implementation of a recursive function. In the process, the concept of LIFO should become clearer. We'll create a function that recursively does the same thing as ",(0,s.jsx)(n.code,{children:"reverse()"}),". When we input a word into our function, it will be returned to us backwards."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const recurseReverse = (string) => {\n if (string === "") {\n   return "";\n } else {\n   return recurseReverse(string.substring(1)) + string[0];\n }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In the example above, our ",(0,s.jsx)(n.code,{children:"recurseReverse()"})," function takes a ",(0,s.jsx)(n.code,{children:"string"})," as an argument. If the ",(0,s.jsx)(n.code,{children:"string"})," is equal to ",(0,s.jsx)(n.code,{children:'""'}),", it will return ",(0,s.jsx)(n.code,{children:'""'}),". This is our base case. Otherwise, it will call ",(0,s.jsx)(n.code,{children:"recurseReverse()"})," again. We will pass ",(0,s.jsx)(n.code,{children:"string.substring(1)) + string[0]"})," into our function. In the example above, the ",(0,s.jsx)(n.code,{children:"substring()"})," method will return all characters in the string except for the first (denoted by the ",(0,s.jsx)(n.code,{children:"1"})," passed in as an argument)."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's see what will happen if we call ",(0,s.jsx)(n.code,{children:'recurseReverse("fern")'}),"."]}),"\n",(0,s.jsx)(n.p,{children:"We call our function:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'string = "fern"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We reach our return statement and call ",(0,s.jsx)(n.code,{children:"recurseReverse()"})," again:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'recurseReverse("ern") + "f";\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This is ",(0,s.jsx)(n.strong,{children:"not"})," the same as returning ",(0,s.jsx)(n.code,{children:'"ern" + "f"'}),", so don't get tripped up here. Also, remember that we still haven't completed any of our function calls yet \u2014 we are still recursively calling the function and adding a letter to the end each time."]}),"\n",(0,s.jsx)(n.p,{children:"We call it yet again:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'recurseReverse("rn") + "e";\n'})}),"\n",(0,s.jsx)(n.p,{children:"The third time through, we get this result:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'recurseReverse("n") + "r";\n'})}),"\n",(0,s.jsx)(n.p,{children:"The next time, we will get the following:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'recurseReverse("") + "n";\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This alerts our function to stop recursion and to return the string ",(0,s.jsx)(n.code,{children:'""'}),"."]}),"\n",(0,s.jsx)(n.p,{children:"We now have multiple nested function calls. Our innermost function call will return first, followed by the second-innermost function call, and so on until we reach the outermost function call. Each function is returning a letter or an empty string like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'recurseReverse() {\n return "f";\n recurseReverse() {\n   return "e";\n   recurseReverse() {\n     return "r";\n     recurseReverse() {\n       return "n";\n       recurseReverse() {\n         return "";\n       }\n     }\n   }\n }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:'Because the JavaScript stack is "last in, first out," the letters will be concatenated in this order:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'"" + "n" + "r" + "e" + "f"\n'})}),"\n",(0,s.jsx)(n.p,{children:"Because we reached our base case (an empty string), our function stops calling itself and returns an empty string. If we didn't have that base case, our function would keep calling itself until the maximum callstack is exceeded."}),"\n",(0,s.jsx)(n.p,{children:'In short, "fern" is spelled backwards.'})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>o});var r=t(96540);const s={},i=r.createContext(s);function c(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);