"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[81155],{22518:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-3-3-es6-array-and-object-destructuring","title":"\ud83d\udcd3 2.2.3.3 ES6 Array and Object Destructuring","description":"One of the most popular ES6 features is object and array destructuring. Destructuring is the process of taking specific elements from an array or properties from an object and then turning them into variables.","source":"@site/docs/2_intermediate-javascript/2_test-driven-development-and-environments-with-javascript/2-2-3-03-es6-array-and-object-destructuring.md","sourceDirName":"2_intermediate-javascript/2_test-driven-development-and-environments-with-javascript","slug":"/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-3-3-es6-array-and-object-destructuring","permalink":"/v1.2/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-3-3-es6-array-and-object-destructuring","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 2.2.3.3 ES6 Array and Object Destructuring","day":"wednesday","id":"2-2-3-3-es6-array-and-object-destructuring","hide_table_of_contents":true},"sidebar":"intermediate-javascript","previous":{"title":"\ud83d\udcd3 2.2.3.2 Managing Images with webpack","permalink":"/v1.2/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-3-2-managing-images-with-webpack"},"next":{"title":"\ud83d\udcd3 2.2.3.4 ES6 Maps and Sets","permalink":"/v1.2/intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-3-4-es6-maps-and-sets"}}');var s=n(74848),o=n(28453);const a={title:"\ud83d\udcd3 2.2.3.3 ES6 Array and Object Destructuring",day:"wednesday",id:"2-2-3-3-es6-array-and-object-destructuring",hide_table_of_contents:!0},i=void 0,c={},d=[{value:"Array Destructuring",id:"array-destructuring",level:2},{value:"Object Destructuring",id:"object-destructuring",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["One of the most popular ES6 features is object and array ",(0,s.jsx)(t.strong,{children:"destructuring"}),". Destructuring is the process of taking specific elements from an array or properties from an object and then turning them into variables."]}),"\n",(0,s.jsx)(t.p,{children:"While it's not essential to incorporate this feature in our projects right now, it's a useful convenience. Object destructuring is very common in React, so even if you don't use it much now, it will come up again once we start working with React."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Note, that you will not be expected to incorporate destructuring for this section's independent project."})," However, you should recognize destructuring out in the wild, and give it a whirl in your projects."]}),"\n",(0,s.jsx)(t.h2,{id:"array-destructuring",children:"Array Destructuring"}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.p,{children:"Let's say we have an array of numbers that looks like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const numArray = [1, 2, 3];\n"})}),"\n",(0,s.jsx)(t.p,{children:"To get elements from the array and assign them to variables, we might do something like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const firstElement = numArray[0];\nconst secondElement = numArray[1];\nconst thirdElement = numArray[2];\n"})}),"\n",(0,s.jsx)(t.p,{children:"We can make this process much simpler with array destructuring:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const [firstElement, secondElement, thirdElement] = numArray;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In this example, we are destructuring the elements of the array into variables. ",(0,s.jsx)(t.code,{children:"firstElement"})," corresponds to the first element of the array, ",(0,s.jsx)(t.code,{children:"secondElement"})," corresponds to the second element, and so on. We could name these variables anything, but we decided to name them something that would help you make more sense of the example. For example, this would also work:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const [numberOfDogs, numberOfCats, numberOfChicks] = numArray;\n"})}),"\n",(0,s.jsx)(t.p,{children:"Try this out in the DevTools console and check the values of each of the variables."}),"\n",(0,s.jsx)(t.p,{children:"And with array destructuring, we've reduced three lines of code to one!"}),"\n",(0,s.jsx)(t.p,{children:"Note that we don't have to destructure the entire array. For instance, if we just need the first element, we could do this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const [firstEl] = numArray;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"firstElement"})," variable is now set to the first element in ",(0,s.jsx)(t.code,{children:"numArray"}),", but there is no ",(0,s.jsx)(t.code,{children:"secondElement"})," or ",(0,s.jsx)(t.code,{children:"thirdElement"}),". If we wanted to get the third element instead, we'd have to provide a comma for every element we don't want to destructure:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const [ , , thirdEl] = numArray;\n"})}),"\n",(0,s.jsx)(t.h2,{id:"object-destructuring",children:"Object Destructuring"}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.p,{children:"Object destructuring is both more useful and more common than array destructuring. We can use it to assign specific properties of an object to variables. Here's an example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'const obj = {\n  color1: "red",\n  color2: "blue",\n  description: "Information we don\'t need",\n  color3: "yellow",\n  anotherProp: "We don\'t need this info, either"\n};\n'})}),"\n",(0,s.jsx)(t.p,{children:"Let's say we just want to get the colors from this object. We can destructure them like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const { color1, color2, color3 } = obj;\n"})}),"\n",(0,s.jsx)(t.p,{children:"In this example, we are pulling out the properties from the object and saving them as constants with the same names. Unlike with array destructuring, with objects, we need to create variables that match the name of the property we are destructuring from the object."}),"\n",(0,s.jsx)(t.p,{children:"Try it in the DevTools console:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'color1;\n> "red"\ncolor2;\n> "blue"\ncolor3;\n> "yellow"\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Since we've only destructured the colors, we don't have equivalent variables for ",(0,s.jsx)(t.code,{children:"description"})," or ",(0,s.jsx)(t.code,{children:"anotherProp"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Let's say we want to take this one step further and create a variable for a property, but the variable should have a ",(0,s.jsx)(t.em,{children:"different"})," name from the original property. We can do this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const { color1: red, color3: yellow } = obj;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Now we have variables for ",(0,s.jsx)(t.code,{children:"red"})," (which corresponds to the value of the ",(0,s.jsx)(t.code,{children:"color1"})," property) and ",(0,s.jsx)(t.code,{children:"yellow"})," (which corresponds to the value of the ",(0,s.jsx)(t.code,{children:"color3"})," property). This syntax is a little tricky, so let's look at another example."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'const hero = {\n  name: "Spider-Man",\n  realName: "Peter Parker"\n};\n\nconst { realName: secretName } = hero;\n\nsecretName; // => "Peter Parker"\n'})}),"\n",(0,s.jsxs)(t.p,{children:["In this example, we created a new variable called ",(0,s.jsx)(t.code,{children:"secretName"})," and we set its value to the value of the ",(0,s.jsx)(t.code,{children:"realName"})," property. So, ",(0,s.jsx)(t.code,{children:"secretName"})," is equal to ",(0,s.jsx)(t.code,{children:'"Peter Parker"'}),". The syntax that we're following in pseudocode looks like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"// this is pseudocode!\nconst { objectProperty: newIdentifier } = object;\n"})}),"\n",(0,s.jsx)(t.p,{children:"There's a few things to note about this pseudocode syntax:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"object"})," represents the object we're destructuring."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"objectProperty"})," is the value we want to destructure from the object."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"newIdentifier"})," is the new variable we're creating to hold the value of the ",(0,s.jsx)(t.code,{children:"objectProperty"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"If this syntax is confusing, or you are worried about being able to remember it, don't worry about either of those. Practice with it a bit, and reference MDN when you find yourself in need of object destructuring to review usage options and syntax."}),"\n",(0,s.jsxs)(t.p,{children:["By the way, the syntax for object destructuring should already look familiar from the import statements we've used with named exports. For instance, as we discussed in the ",(0,s.jsx)(t.a,{href:"../../intermediate-javascript/test-driven-development-and-environments-with-javascript/2-2-0-11-es6-imports-and-exports",children:"ES6 Imports and Exports"})," lesson, we can do the following:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"import { Triangle, Rectangle, Circle } from './shapes.js';\n"})}),"\n",(0,s.jsx)(t.p,{children:"As we can see, import statements that are used with named exports use object destructuring syntax as well."}),"\n",(0,s.jsxs)(t.p,{children:["This lesson covers the basics of array and object destructuring, but there are plenty of other things we can do with destructuring, too! Check out the Mozilla documentation on ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment",children:"Destructuring Assignment"})," to learn more."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var r=n(96540);const s={},o=r.createContext(s);function a(e){const t=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);