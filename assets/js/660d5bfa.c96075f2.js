"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[88309],{28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var t=s(96540);const i={},a=t.createContext(i);function r(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(a.Provider,{value:n},e.children)}},30229:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"c-and-net/lessons-19-31-basic-console-apps/3-0-0-23-class-fields-and-constructors","title":"\ud83d\udcd3 3.0.0.23 Class Fields and Constructors","description":"We know a lot about classes and namespaces at this point, but our Shape Tracker application doesn\'t do much at all. Let\'s update our Triangle class to have fields and a constructor.","source":"@site/versioned_docs/version-v1_3/3_c-and-net/0_lessons-19-31-basic-console-apps/3-0-0-23-class-fields-and-constructors.md","sourceDirName":"3_c-and-net/0_lessons-19-31-basic-console-apps","slug":"/c-and-net/lessons-19-31-basic-console-apps/3-0-0-23-class-fields-and-constructors","permalink":"/v1.3/c-and-net/lessons-19-31-basic-console-apps/3-0-0-23-class-fields-and-constructors","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 3.0.0.23 Class Fields and Constructors","day":"weekend","id":"3-0-0-23-class-fields-and-constructors","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.0.0.22 Classes and Namespaces","permalink":"/v1.3/c-and-net/lessons-19-31-basic-console-apps/3-0-0-22-classes-and-namespaces"},"next":{"title":"\ud83d\udcd3 3.0.0.24 Class Methods","permalink":"/v1.3/c-and-net/lessons-19-31-basic-console-apps/3-0-0-24-class-methods"}}');var i=s(74848),a=s(28453);const r={title:"\ud83d\udcd3 3.0.0.23 Class Fields and Constructors",day:"weekend",id:"3-0-0-23-class-fields-and-constructors",hide_table_of_contents:!0},c=void 0,l={},o=[{value:"Adding Fields",id:"adding-fields",level:2},{value:"Accessing Fields",id:"accessing-fields",level:2},{value:"Adding a Constructor",id:"adding-a-constructor",level:2},{value:"Using the Constructor",id:"using-the-constructor",level:2}];function d(e){const n={code:"code",div:"div",h2:"h2",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["We know a lot about classes and namespaces at this point, but our Shape Tracker application doesn't do much at all. Let's update our ",(0,i.jsx)(n.code,{children:"Triangle"})," class to have ",(0,i.jsx)(n.strong,{children:"fields"})," and a ",(0,i.jsx)(n.strong,{children:"constructor"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"adding-fields",children:"Adding Fields"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["In JavaScript we often added properties to the objects we created. Well in C#, we add ",(0,i.jsx)(n.strong,{children:"fields"}),". In very simple terms, a C# field is exactly what a JavaScript property is. In more technical terms, a C# field is a variable of any type that is declared directly in a class."]}),"\n",(0,i.jsx)(n.p,{children:"Let's see what these look like."}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"Models/Triangle.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"namespace ShapeTracker.Models \n{\n  public class Triangle \n  {\n    public int Side1;\n    public int Side2 = 4;\n    public int Side3;\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We've created three fields: ",(0,i.jsx)(n.code,{children:"Side1"}),", ",(0,i.jsx)(n.code,{children:"Side2"}),", and ",(0,i.jsx)(n.code,{children:"Side3"}),". These are meant to hold the three integer values that we'll use to determine the type of a triangle."]}),"\n",(0,i.jsxs)(n.p,{children:["As we can see, ",(0,i.jsx)(n.code,{children:"Side1"}),", ",(0,i.jsx)(n.code,{children:"Side2"}),", and ",(0,i.jsx)(n.code,{children:"Side3"})," look like variables declared within a C# class. Well that's what a ",(0,i.jsx)(n.strong,{children:"field"})," is in C#."]}),"\n",(0,i.jsxs)(n.p,{children:["We can also describe these fields as ",(0,i.jsx)(n.strong,{children:"members"})," of the ",(0,i.jsx)(n.code,{children:"Triangle"})," class, since they belong to the ",(0,i.jsx)(n.code,{children:"Triangle"})," class."]}),"\n",(0,i.jsxs)(n.p,{children:["Notice that ",(0,i.jsx)(n.code,{children:"Side2"})," looks different from the other fields. That's because we've assigned ",(0,i.jsx)(n.code,{children:"Side2"})," an ",(0,i.jsx)(n.strong,{children:"initial value"})," of ",(0,i.jsx)(n.code,{children:"4"}),". We can give initial values to any class field we create."]}),"\n",(0,i.jsxs)(n.p,{children:["Also notice the keyword ",(0,i.jsx)(n.code,{children:"public"}),". This is one of many ",(0,i.jsx)(n.strong,{children:"access level modifiers"}),". As modifiers, keywords like ",(0,i.jsx)(n.code,{children:"public"})," specify the level of protection this data has in our application. As ",(0,i.jsx)(n.code,{children:"public"}),", our three fields can be accessed from anywhere in our application."]}),"\n",(0,i.jsxs)(n.p,{children:["As far as naming conventions, ",(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"public"})," fields should be in Pascal case"]}),', or "UpperCamelCase". We are using ',(0,i.jsx)(n.code,{children:"Side1"}),", but we could also use ",(0,i.jsx)(n.code,{children:"SideOne"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Let's look at that next \u2014 how to access these fields."}),"\n",(0,i.jsx)(n.h2,{id:"accessing-fields",children:"Accessing Fields"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["Let's update our code in ",(0,i.jsx)(n.code,{children:"Program.cs"})," to access one of these fields to get a sense of how that works. Update your code as follows:"]}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"Program.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'using System;\nusing ShapeTracker.Models;\n\nnamespace ShapeTracker\n{\n  public class Program\n  {\n    static void Main()\n    {\n      Triangle testTriangle = new Triangle();\n      Console.WriteLine(testTriangle.GetType());\n      // new code below\n      testTriangle.Side1 = 65;\n      testTriangle.Side3 = 88;\n      Console.WriteLine($"Side one of the triangle: {testTriangle.Side1}");\n      Console.WriteLine($"Side two of the triangle: {testTriangle.Side2}");\n      Console.WriteLine($"Side three of the triangle: {testTriangle.Side3}");\n    }\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The first two lines of the ",(0,i.jsx)(n.code,{children:"Main()"})," method are the same. Below that is new code."]}),"\n",(0,i.jsxs)(n.p,{children:["Similar to JavaScript, we use ",(0,i.jsx)(n.strong,{children:"dot notation"})," to access fields, like ",(0,i.jsx)(n.code,{children:"testTriangle.Side1"}),". Note that we cannot use brackets ",(0,i.jsx)(n.code,{children:"[]"})," to access fields like we were able to with JavaScript properties. In C# brackets are used to apply indexing, like accessing an array element by its index location."]}),"\n",(0,i.jsxs)(n.p,{children:["Take note that all of the fields we created are ",(0,i.jsx)(n.strong,{children:"instance fields"}),", which means that we access them on an instance of the ",(0,i.jsx)(n.code,{children:"Triangle"})," class, specifically ",(0,i.jsx)(n.code,{children:"testTriangle"}),", and not the class itself."]}),"\n",(0,i.jsxs)(n.p,{children:["Within the new ",(0,i.jsx)(n.code,{children:"Console.WriteLine()"})," statements, notice that we're using string interpolation to combine strings with variables."]}),"\n",(0,i.jsxs)(n.p,{children:["We can now run our program with ",(0,i.jsx)(n.code,{children:"dotnet run"})," in the ",(0,i.jsx)(n.code,{children:"ShapeTracker"})," project directory and we'll get the following output:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"ShapeTracker.Models.Triangle\nSide one of the triangle: 65\nSide two of the triangle: 4\nSide three of the triangle: 88\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We now have a ",(0,i.jsx)(n.code,{children:"Triangle"})," with three sides."]}),"\n",(0,i.jsx)(n.h2,{id:"adding-a-constructor",children:"Adding a Constructor"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"Let's improve our lives as developers and add a custom constructor that sets the values of the three sides when the triangle is created."}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"constructor"})," is a method that is called when a new instance of a class is created. Any information regarding the initial setup of a new object can be included in a constructor."]}),"\n",(0,i.jsxs)(n.p,{children:["Here's how we'll update ",(0,i.jsx)(n.code,{children:"Triangle.cs"}),":"]}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"Models/Triangle.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"namespace ShapeTracker.Models \n{\n  public class Triangle \n  {\n    public int Side1;\n    public int Side2; // no longer setting a default value\n    public int Side3;\n\n    public Triangle(int length1, int length2, int length3) \n    {\n      Side1 = length1;\n      Side2 = length2;\n      Side3 = length3;\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"To create a class constructor, we simply need to define a method of the same name as the class."}),"\n",(0,i.jsxs)(n.p,{children:["The access modifier ",(0,i.jsx)(n.code,{children:"public"})," means this method is available anywhere in our application."]}),"\n",(0,i.jsxs)(n.p,{children:["Our constructor can take none or multiple parameters. Each of these parameters (",(0,i.jsx)(n.code,{children:"length1"}),", ",(0,i.jsx)(n.code,{children:"length2"}),", and ",(0,i.jsx)(n.code,{children:"length3"}),") correspond to the fields a ",(0,i.jsx)(n.code,{children:"Triangle"})," object should have (",(0,i.jsx)(n.code,{children:"Side1"}),", ",(0,i.jsx)(n.code,{children:"Side2"}),", ",(0,i.jsx)(n.code,{children:"Side3"}),"). We can see within the curly braces of the constructor method that we assign each parameter as the value of a field."]}),"\n",(0,i.jsxs)(n.p,{children:["Between the two curly braces ",(0,i.jsx)(n.code,{children:"{ }"})," is the body of our constructor method \u2014 any code that we want the constructor to execute. Here, we're setting the values of our three fields, but we could perform other actions as well."]}),"\n",(0,i.jsxs)(n.p,{children:["Note that ",(0,i.jsx)(n.strong,{children:"the class's fields are in Pascal case while the constructor's parameters are lowerCamelCase."})," That's because the parameters are variables."]}),"\n",(0,i.jsx)(n.h2,{id:"using-the-constructor",children:"Using the Constructor"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["Constructors create new instances of a class when the ",(0,i.jsx)(n.code,{children:"new"})," keyword is used. ",(0,i.jsx)(n.code,{children:"new"})," denotes that we're creating a new instance of this class:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"Triangle coolTriangle = new Triangle(100, 010, 001);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When we call our constructor, we need to pass in an argument for each parameter, or else we'll get a compiler error. For example, if we put no arguments into our ",(0,i.jsx)(n.code,{children:"Triangle()"})," constructor call, we'll get this error:"]}),"\n",(0,i.jsxs)(n.pre,{children:[(0,i.jsx)(n.code,{style:{color:"red"},children:"\n/Users/staff/Desktop/ShapeTracker.Solution/ShapeTracker/Program.cs(10,35): error CS7036: There is no argument given that corresponds to the required formal parameter 'length1' of 'Triangle.Triangle(int, int, int)' [/Users/staff/Desktop/ShapeTracker.Solution/ShapeTracker/ShapeTracker.csproj]\n\nThe build failed. Fix the build errors and run again.\n"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Let's update the user interface code in ",(0,i.jsx)(n.code,{children:"Program.cs"})," to use the constructor we created:"]}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"Program.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'using System;\nusing ShapeTracker.Models;\n\nnamespace ShapeTracker\n{\n  class Program\n  {\n    static void Main()\n    {\n      Triangle testTriangle = new Triangle(3,4,5);\n      Console.WriteLine($"Side one of the triangle: {testTriangle.Side1}");\n      Console.WriteLine($"Side two of the triangle: {testTriangle.Side2}");\n      Console.WriteLine($"Side three of the triangle: {testTriangle.Side3}");\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Now when we run our console app, we'll get this output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Side one of the triangle: 3\nSide two of the triangle: 4\nSide three of the triangle: 5\n"})}),"\n",(0,i.jsx)(n.p,{children:"Up next, we'll add a method that determines what type of triangle we have: isosceles, equilateral, scalene, or not a triangle."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);