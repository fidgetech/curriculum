"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[59422],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var r=n(96540);const a={},o=r.createContext(a);function i(e){const t=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(o.Provider,{value:t},e.children)}},52738:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>l,frontMatter:()=>i,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"capstone/capstone-week-1/introduction-to-ascii","title":"\ud83d\udcd3 Introduction to ASCII","description":"There are some situations where we might need to convert a letter or a string into a number. For example, when we work with binary numbers, we might need to turn a letter to its binary representation. Some algorithms also require converting letters to numbers. A key example is a hashing algorithm, which requires the ability to convert a string into an index in an array.","source":"@site/versioned_docs/version-v1_3/capstone/1_capstone-week-1/introduction-to-ascii.md","sourceDirName":"capstone/1_capstone-week-1","slug":"/capstone/capstone-week-1/introduction-to-ascii","permalink":"/v1.3/capstone/capstone-week-1/introduction-to-ascii","draft":false,"unlisted":false,"tags":[],"version":"v1_3","sidebarPosition":26,"frontMatter":{"title":"\ud83d\udcd3 Introduction to ASCII","id":"introduction-to-ascii","slug":"introduction-to-ascii","hide_table_of_contents":true,"sidebar_position":26,"day":"wednesday","type":"lesson","url":"https://github.com/epicodus-curriculum/capstone/blob/main/1_ascii_code.md"},"sidebar":"capstone","previous":{"title":"\u270f\ufe0f Graph Theory Practice","permalink":"/v1.3/capstone/capstone-week-1/graph-theory-practice"},"next":{"title":"\ud83d\udcd3 Bits, Bytes, and Binary Numbers","permalink":"/v1.3/capstone/capstone-week-1/bits-bytes-and-binary-numbers"}}');var a=n(74848),o=n(28453);const i={title:"\ud83d\udcd3 Introduction to ASCII",id:"introduction-to-ascii",slug:"introduction-to-ascii",hide_table_of_contents:!0,sidebar_position:26,day:"wednesday",type:"lesson",url:"https://github.com/epicodus-curriculum/capstone/blob/main/1_ascii_code.md"},s=void 0,c={},h=[{value:"JavaScript Methods for ASCII Encoding",id:"javascript-methods-for-ascii-encoding",level:2},{value:"Turning a Letter into ASCII Code",id:"turning-a-letter-into-ascii-code",level:3},{value:"Turning an ASCII Code Into A Character",id:"turning-an-ascii-code-into-a-character",level:3},{value:"Other Notes About ASCII",id:"other-notes-about-ascii",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"There are some situations where we might need to convert a letter or a string into a number. For example, when we work with binary numbers, we might need to turn a letter to its binary representation. Some algorithms also require converting letters to numbers. A key example is a hashing algorithm, which requires the ability to convert a string into an index in an array."}),"\n",(0,a.jsxs)(t.p,{children:["Fortunately, all characters \u2014 including letters, numbers and punctuation \u2014 can be translated into an ASCII character code, which is the standard for encoding characters on a keyboard as a number. You can see a complete ",(0,a.jsx)(t.a,{href:"https://www.ascii-code.com/",children:"ASCII chart here"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["ASCII specifications serve a very specific purpose. ASCII is a universal language that computers can use to communicate and share files. Without standards like ASCII, one machine might send a message that reads ",(0,a.jsx)(t.code,{children:'"hello"'})," \u2014 but a second machine wouldn't be able to translate it for a user because there'd be no standard by which to decode the message from the first machine."]}),"\n",(0,a.jsx)(t.p,{children:"Generally, we will not need to worry about how various machines communicate with each other \u2014 that's something that other developers have taken care of for us. However, as mentioned before, there are situations where we might need to turn letters into numbers. Instead of just creating our own converter, we'd be better off using a universal standard that all machines understand."}),"\n",(0,a.jsx)(t.h2,{id:"javascript-methods-for-ascii-encoding",children:"JavaScript Methods for ASCII Encoding"}),"\n",(0,a.jsx)(t.p,{children:"There are two important methods related to ASCII encoding. One is to turn a letter into its ASCII equivalent. The other is to turn an ASCII code back into its letter equivalent."}),"\n",(0,a.jsx)(t.h3,{id:"turning-a-letter-into-ascii-code",children:"Turning a Letter into ASCII Code"}),"\n",(0,a.jsxs)(t.p,{children:["To turn a letter into its equivalent ASCII code, we can use the ",(0,a.jsx)(t.code,{children:"String.prototype.charCodeAt()"})," method. This method takes a position in a string as an argument."]}),"\n",(0,a.jsx)(t.p,{children:"If we want to encode the first character in a string, we'd do the following:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'> "cat".charCodeAt(0);\n99\n'})}),"\n",(0,a.jsxs)(t.p,{children:["If we try to get the character code of a position that doesn't exist, the method will return ",(0,a.jsx)(t.code,{children:"NaN"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'> "cat".charCodeAt(3);\nNaN\n'})}),"\n",(0,a.jsx)(t.p,{children:"If we want to return the codes for each character, we need to loop through the string. For example, we could do something like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'function asciiConverter(string) {\n  return string.split("").map(function(letter) {\n    return letter.charCodeAt(0);\n  });\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["This splits the string and then uses ",(0,a.jsx)(t.code,{children:"Array.prototype.map()"})," to return the ASCII code for each letter. As we can see from the example above, we use ",(0,a.jsx)(t.code,{children:"String.prototype.charCodeAt(0)"})," because we are looking at one letter at a time. It's common to just use ",(0,a.jsx)(t.code,{children:"String.prototype.charCodeAt(0)"})," in this kind of loop because we are evaluating each letter individually \u2014 and the first position of a single letter is always going to be itself."]}),"\n",(0,a.jsx)(t.h3,{id:"turning-an-ascii-code-into-a-character",children:"Turning an ASCII Code Into A Character"}),"\n",(0,a.jsxs)(t.p,{children:["To go in the other direction, we can turn an ASCII code into a character with ",(0,a.jsx)(t.code,{children:"String.fromCharCode()"}),". Note that this is a static method, not a prototype method."]}),"\n",(0,a.jsx)(t.p,{children:"We can call it like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'> String.fromCharCode(97);\n"a"\n'})}),"\n",(0,a.jsx)(t.p,{children:"Or we can pass in multiple arguments:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'> String.fromCharCode(99, 97, 116);\n"cat"\n'})}),"\n",(0,a.jsxs)(t.p,{children:["This method won't just translate ASCII characters, by the way \u2014 it's for translating all UTF-16 characters. That means Unicode \u2014 which has a ",(0,a.jsx)(t.em,{children:"lot"})," more characters than ASCII. For instance:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'> String.fromCharCode(6543210);\n"\ud76a"\n'})}),"\n",(0,a.jsx)(t.h2,{id:"other-notes-about-ascii",children:"Other Notes About ASCII"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["The ASCII chart isn't just for numbers and letters. It's for encoding ",(0,a.jsx)(t.em,{children:"all"})," characters on a keyboard. The first 32 characters in the ASCII chart are characters that can't be printed. This includes everything from the backspace to the ",(0,a.jsx)(t.code,{children:"esc"})," key."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["Lower-cased letters are encoded differently than upper-cased letters. For instance, the ASCII code for ",(0,a.jsx)(t.code,{children:"A"})," is 65 while the character code for ",(0,a.jsx)(t.code,{children:"a"})," is 97. The letters are sequential so ",(0,a.jsx)(t.code,{children:"B"})," is 66, ",(0,a.jsx)(t.code,{children:"C"})," is 67, and so on. Because lower-case letters are also sequential, the lower-cased version of a letter will always have an ASCII code that's the sum of the ASCII code for the upper-cased version plus 32. Not that you need to know this fact \u2014 but it could help solve a problem some day if, for instance, you wanted to uppercase or lowercase letters based on their ASCII codes."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["There are also extended ASCII character codes for special characters such as characters used in other languages like ",(0,a.jsx)(t.code,{children:"\xeb"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"ASCII is based on a limited set of Latin character. This means many characters from other languages (such as Arabic) are not included. Unicode is much more extensive for character encoding."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"In general, you will probably not need to think about ASCII too much. However, the topic will come up in several future lessons \u2014 including when we learn about bitwise manipulation and hashing algorithms. It's not anything you need to memorize \u2014 rather, it's important to be aware of ASCII as there are many problems where we might need to convert letters into numbers."})]})}function l(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);