"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[45850],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var i=n(96540);const s={},o=i.createContext(s);function a(e){const t=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:t},e.children)}},39699:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"react/react-fundamentals/4-2-2-4-passing-data-via-callbacks","title":"\ud83d\udcd3 4.2.2.4 Passing Data Via Callbacks","description":"In the last lesson, we covered the concept of unidirectional data flow. In this lesson, we\'ll apply what we\'ve learned. To recap, we\'ll need to do the following:","source":"@site/versioned_docs/version-v1_3/4_react/2_react-fundamentals/4-2-2-04-passing-data-via-callbacks.md","sourceDirName":"4_react/2_react-fundamentals","slug":"/react/react-fundamentals/4-2-2-4-passing-data-via-callbacks","permalink":"/v1.3/react/react-fundamentals/4-2-2-4-passing-data-via-callbacks","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 4.2.2.4 Passing Data Via Callbacks","day":"tuesday","id":"4-2-2-4-passing-data-via-callbacks","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 4.2.2.3 Unidirectional Data Flow","permalink":"/v1.3/react/react-fundamentals/4-2-2-3-unidirectional-data-flow"},"next":{"title":"\ud83d\udcd3 4.2.2.5 Styling React: CSS Objects","permalink":"/v1.3/react/react-fundamentals/4-2-2-5-styling-react-css-objects"}}');var s=n(74848),o=n(28453);const a={title:"\ud83d\udcd3 4.2.2.4 Passing Data Via Callbacks",day:"tuesday",id:"4-2-2-4-passing-data-via-callbacks",hide_table_of_contents:!0},c=void 0,r={},l=[{value:"Step 1: Add mainTicketList to State",id:"step-1-add-mainticketlist-to-state",level:2},{value:"Step 2: Update TicketList to Use Props",id:"step-2-update-ticketlist-to-use-props",level:2},{value:"Step 3: Create a Function to Handle Adding Tickets",id:"step-3-create-a-function-to-handle-adding-tickets",level:2},{value:"Step 4: Pass the Function Down as a Prop",id:"step-4-pass-the-function-down-as-a-prop",level:2},{value:"Step 5: Use the Callback and Add a Unique ID",id:"step-5-use-the-callback-and-add-a-unique-id",level:2},{value:"How It All Connects",id:"how-it-all-connects",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const t={admonition:"admonition",code:"code",em:"em",h2:"h2",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"In the last lesson, we covered the concept of unidirectional data flow. In this lesson, we'll apply what we've learned. To recap, we'll need to do the following:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Add ",(0,s.jsx)(t.code,{children:"mainTicketList"})," to state in our ",(0,s.jsx)(t.code,{children:"TicketControl"})," component."]}),"\n",(0,s.jsxs)(t.li,{children:["Create a function in ",(0,s.jsx)(t.code,{children:"TicketControl"})," that will take form data and add it to our ticket list."]}),"\n",(0,s.jsxs)(t.li,{children:["Pass this function down to the child ",(0,s.jsx)(t.code,{children:"NewTicketForm"})," component as a prop."]}),"\n",(0,s.jsx)(t.li,{children:"Call this function in our child component when the form is submitted."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Despite the relatively small amount of code being added, we are working with challenging new concepts. Be patient with yourself and follow along slowly. If it doesn't all click immediately (and it probably won't), trust the process and keep practicing these concepts in class and on your own."}),"\n",(0,s.jsx)(t.h2,{id:"step-1-add-mainticketlist-to-state",children:"Step 1: Add mainTicketList to State"}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsxs)(t.p,{children:["Let's start by adding a ",(0,s.jsx)(t.code,{children:"mainTicketList"})," state variable and passing it down as a prop to ",(0,s.jsx)(t.code,{children:"TicketList"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",metastring:'title="src/components/TicketControl.js"',children:"import React, { useState } from 'react';\nimport NewTicketForm from './NewTicketForm';\nimport TicketList from './TicketList';\n\nfunction TicketControl() {\n  const [formVisibleOnPage, setFormVisibleOnPage] = useState(false);\n  const [mainTicketList, setMainTicketList] = useState([]); // new code\n\n  const handleClick = () => {\n    setFormVisibleOnPage(!formVisibleOnPage);\n  }\n\n  let currentlyVisibleState = null;\n  let buttonText = null;\n\n  if (formVisibleOnPage) {\n    currentlyVisibleState = <NewTicketForm />;\n    buttonText = \"Return to Ticket List\";\n  } else {\n    currentlyVisibleState = <TicketList ticketList={mainTicketList} />; // updated\n    buttonText = \"Add Ticket\";\n  }\n\n  return (\n    <React.Fragment>\n      {currentlyVisibleState}\n      <button onClick={handleClick}>{buttonText}</button>\n    </React.Fragment>\n  );\n}\n\nexport default TicketControl;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Notice we're initializing ",(0,s.jsx)(t.code,{children:"mainTicketList"})," as an empty array. We're doing this because we don't want this application to start with fake tickets. The queue should be empty until we start adding tickets via our form. (We'll be removing our array of dummy tickets from ",(0,s.jsx)(t.code,{children:"TicketList"})," in just a moment.)"]}),"\n",(0,s.jsxs)(t.p,{children:["Also, notice how we're passing ",(0,s.jsx)(t.code,{children:"mainTicketList"})," down to ",(0,s.jsx)(t.code,{children:"TicketList"})," as a prop called ",(0,s.jsx)(t.code,{children:"ticketList"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"step-2-update-ticketlist-to-use-props",children:"Step 2: Update TicketList to Use Props"}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsxs)(t.p,{children:["In step 1, we passed ",(0,s.jsx)(t.code,{children:"mainTicketList"})," state from ",(0,s.jsx)(t.code,{children:"TicketControl"})," down to our ",(0,s.jsx)(t.code,{children:"TicketList"})," component. Now we need to update ",(0,s.jsx)(t.code,{children:"TicketList.js"})," to use this prop. We'll also remove the old ",(0,s.jsx)(t.code,{children:"mainTicketList"})," constant that held our dummy tickets."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",metastring:'title="src/components/TicketList.js"',children:'import React from "react";\nimport Ticket from "./Ticket";\nimport PropTypes from "prop-types";\n\n// Remove const mainTicketList = [ ... ]. We no longer need these dummy tickets.\n\nfunction TicketList(props) {\n  return (\n    <React.Fragment>\n      <hr />\n      {props.ticketList.map((ticket, index) =>\n        <Ticket \n          names={ticket.names}\n          location={ticket.location}\n          issue={ticket.issue}\n          key={index} />\n      )}\n    </React.Fragment>\n  );\n}\n\nTicketList.propTypes = {\n  ticketList: PropTypes.array\n};\n\nexport default TicketList;\n'})}),"\n",(0,s.jsx)(t.p,{children:"We've made several changes here:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Now that we are passing ",(0,s.jsx)(t.code,{children:"ticketList"})," down through ",(0,s.jsx)(t.code,{children:"props"}),", we need to import ",(0,s.jsx)(t.code,{children:"prop-types"})," and add a prop type of ",(0,s.jsx)(t.code,{children:"array"})," for our ",(0,s.jsx)(t.code,{children:"ticketList"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["We removed our ",(0,s.jsx)(t.code,{children:"mainTicketList"})," constant which stored the dummy tickets \u2014 we won't need these anymore!"]}),"\n",(0,s.jsxs)(t.li,{children:["We loop through ",(0,s.jsx)(t.code,{children:"props.ticketList"})," instead of the local constant."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Now we'll be able to make changes to our ticket list and display tickets as they're added."}),"\n",(0,s.jsx)(t.h2,{id:"step-3-create-a-function-to-handle-adding-tickets",children:"Step 3: Create a Function to Handle Adding Tickets"}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsxs)(t.p,{children:["Now let's create a function in ",(0,s.jsx)(t.code,{children:"TicketControl"})," that will handle adding new tickets to our list:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",metastring:'title="src/components/TicketControl.js"',children:"import React, { useState } from 'react';\nimport NewTicketForm from './NewTicketForm';\nimport TicketList from './TicketList';\n\nfunction TicketControl() {\n  const [formVisibleOnPage, setFormVisibleOnPage] = useState(false);\n  const [mainTicketList, setMainTicketList] = useState([]);\n\n  const handleClick = () => {\n    setFormVisibleOnPage(!formVisibleOnPage);\n  }\n\n  const handleAddingNewTicketToList = (newTicket) => {\n    const newMainTicketList = mainTicketList.concat(newTicket);\n    setMainTicketList(newMainTicketList);\n    setFormVisibleOnPage(false);\n  }\n\n  // ... rest of component\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Our new function is called ",(0,s.jsx)(t.code,{children:"handleAddingNewTicketToList"})," because it does just that \u2014 handles the process of adding a new ticket to our ",(0,s.jsx)(t.code,{children:"mainTicketList"}),". It takes a ",(0,s.jsx)(t.code,{children:"newTicket"})," as a parameter."]}),"\n",(0,s.jsx)(t.admonition,{title:"naming convention",type:"info",children:(0,s.jsxs)(t.p,{children:["It's common practice to prefix the name of an event handler function with ",(0,s.jsx)(t.code,{children:"handle"}),". Any props containing that function will be prefixed with ",(0,s.jsx)(t.code,{children:"on"}),". This is because the prop will be used ",(0,s.jsx)(t.em,{children:"when"})," the event occurs, but the function itself is what ",(0,s.jsx)(t.em,{children:"actually handles"})," the necessary actions. It also ensures the names are similar enough to easily determine which props and functions correspond, yet different enough to tell them apart."]})}),"\n",(0,s.jsx)(t.p,{children:"Let's break down what this function does:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Create a new array:"})," We call ",(0,s.jsx)(t.code,{children:"mainTicketList.concat(newTicket)"}),". Unlike ",(0,s.jsx)(t.code,{children:"push()"}),", which directly alters the array it's called on, ",(0,s.jsx)(t.code,{children:"concat()"})," returns a ",(0,s.jsx)(t.em,{children:"new"})," array with the item added. This is important because we should ",(0,s.jsx)(t.strong,{children:"never alter state directly"}),". You'll also commonly see the spread operator used for this: ",(0,s.jsx)(t.code,{children:"[...mainTicketList, newTicket]"}),". Both approaches create a new array without mutating state."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Update state:"})," We call ",(0,s.jsx)(t.code,{children:"setMainTicketList(newMainTicketList)"})," to update our state with the new array."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Hide the form:"})," We call ",(0,s.jsx)(t.code,{children:"setFormVisibleOnPage(false)"})," so the user sees the queue (with their new ticket) instead of the form."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"step-4-pass-the-function-down-as-a-prop",children:"Step 4: Pass the Function Down as a Prop"}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsxs)(t.p,{children:["Now we need to pass ",(0,s.jsx)(t.code,{children:"handleAddingNewTicketToList"})," down to our ",(0,s.jsx)(t.code,{children:"NewTicketForm"})," component as a prop:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",metastring:'title="src/components/TicketControl.js"',children:'...\n\nlet currentlyVisibleState = null;\nlet buttonText = null;\n\nif (formVisibleOnPage) {\n  currentlyVisibleState = \n    <NewTicketForm \n      onNewTicketCreation={handleAddingNewTicketToList}\n    />; // updated\n  buttonText = "Return to Ticket List";\n} else {\n  currentlyVisibleState = \n    <TicketList \n      ticketList={mainTicketList}\n    />;\n  buttonText = "Add Ticket";\n}\n\n...\n'})}),"\n",(0,s.jsxs)(t.p,{children:["We pass ",(0,s.jsx)(t.code,{children:"handleAddingNewTicketToList"})," as a prop called ",(0,s.jsx)(t.code,{children:"onNewTicketCreation"}),". Notice the naming convention: ",(0,s.jsx)(t.code,{children:"handle"})," prefix for the function, ",(0,s.jsx)(t.code,{children:"on"})," prefix for the prop."]}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsx)(t.p,{children:"Note that we split the JSX onto multiple lines for readability. This is a common practice when passing multiple props or when the component name and props exceed a certain length."})}),"\n",(0,s.jsxs)(t.p,{children:["Next, we need to update ",(0,s.jsx)(t.code,{children:"NewTicketForm"})," to accept and use this prop:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",metastring:'title="src/components/NewTicketForm.js"',children:"import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nfunction NewTicketForm(props) {\n\n  // We'll update this function in the next step\n  function handleNewTicketFormSubmission(event) {\n    event.preventDefault();\n    console.log(event.target.names.value);\n    console.log(event.target.location.value);\n    console.log(event.target.issue.value);\n  }\n\n  return (\n    <React.Fragment>\n      <form onSubmit={handleNewTicketFormSubmission}>\n        <input\n          type='text'\n          name='names'\n          placeholder='Pair Names' />\n        <input\n          type='text'\n          name='location'\n          placeholder='Location' />\n        <textarea\n          name='issue'\n          placeholder='Describe your issue.' />\n        <button type='submit'>Help!</button>\n      </form>\n    </React.Fragment>\n  );\n}\n\nNewTicketForm.propTypes = {\n  onNewTicketCreation: PropTypes.func\n};\n\nexport default NewTicketForm;\n"})}),"\n",(0,s.jsx)(t.p,{children:"We've added two things:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Made sure ",(0,s.jsx)(t.code,{children:"props"})," is a parameter of our function component."]}),"\n",(0,s.jsxs)(t.li,{children:["Added ",(0,s.jsx)(t.code,{children:"PropTypes"})," for ",(0,s.jsx)(t.code,{children:"onNewTicketCreation"}),", specifying it's a function."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"step-5-use-the-callback-and-add-a-unique-id",children:"Step 5: Use the Callback and Add a Unique ID"}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.p,{children:"We're almost done! We need to:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Import the UUID library to assign unique IDs to new tickets."}),"\n",(0,s.jsxs)(t.li,{children:["Update ",(0,s.jsx)(t.code,{children:"handleNewTicketFormSubmission"})," to create a ticket object and pass it to ",(0,s.jsx)(t.code,{children:"onNewTicketCreation"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Here's the complete updated ",(0,s.jsx)(t.code,{children:"NewTicketForm"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",metastring:'title="src/components/NewTicketForm.js"',children:"import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { v4 } from 'uuid';\n\nfunction NewTicketForm(props) {\n\n  function handleNewTicketFormSubmission(event) {\n    event.preventDefault();\n    props.onNewTicketCreation({\n      names: event.target.names.value,\n      location: event.target.location.value,\n      issue: event.target.issue.value,\n      id: v4()\n    });\n  }\n\n  return (\n    <React.Fragment>\n      <form onSubmit={handleNewTicketFormSubmission}>\n        <input\n          type='text'\n          name='names'\n          placeholder='Pair Names' />\n        <input\n          type='text'\n          name='location'\n          placeholder='Location' />\n        <textarea\n          name='issue'\n          placeholder='Describe your issue.' />\n        <button type='submit'>Help!</button>\n      </form>\n    </React.Fragment>\n  );\n}\n\nNewTicketForm.propTypes = {\n  onNewTicketCreation: PropTypes.func\n};\n\nexport default NewTicketForm;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We call ",(0,s.jsx)(t.code,{children:"props.onNewTicketCreation()"})," and pass in an object with all of the ticket properties, including a unique ID generated by the UUID library."]}),"\n",(0,s.jsxs)(t.admonition,{type:"tip",children:[(0,s.jsx)(t.p,{children:"If you need to get a number from a form, remember to parse the value. For example:"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"props.onNewTicketCreation({\n  // ...other properties\n  numberOfStudents: parseInt(event.target.numberOfStudents.value)\n});\n"})})]}),"\n",(0,s.jsxs)(t.p,{children:["One last thing. Now that we're assigning a unique ID to each ticket, we should update our ",(0,s.jsx)(t.code,{children:"TicketList"})," component to use this ID as the ",(0,s.jsx)(t.code,{children:"key"})," prop instead of the array index. Using a stable unique identifier as the key is a React best practice - it helps React efficiently track which items have changed, been added, or removed, avoiding potential rendering bugs."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",metastring:'title="src/components/TicketList.js"',children:"...\n\n{props.ticketList.map((ticket) =>\n  <Ticket \n    names={ticket.names}\n    location={ticket.location}\n    issue={ticket.issue}\n    key={ticket.id} />\n)}\n\n...\n"})}),"\n",(0,s.jsx)(t.h2,{id:"how-it-all-connects",children:"How It All Connects"}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.p,{children:"Let's trace the data flow:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:'User fills out the form and clicks "Help!"'}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"handleNewTicketFormSubmission"})," in ",(0,s.jsx)(t.code,{children:"NewTicketForm"})," is called"]}),"\n",(0,s.jsxs)(t.li,{children:["This function calls ",(0,s.jsx)(t.code,{children:"props.onNewTicketCreation()"})," with the ticket data"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"onNewTicketCreation"})," is actually ",(0,s.jsx)(t.code,{children:"handleAddingNewTicketToList"})," from ",(0,s.jsx)(t.code,{children:"TicketControl"})]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"handleAddingNewTicketToList"})," adds the ticket to state and hides the form"]}),"\n",(0,s.jsxs)(t.li,{children:["React re-renders ",(0,s.jsx)(t.code,{children:"TicketControl"}),", which now passes the updated list to ",(0,s.jsx)(t.code,{children:"TicketList"})]}),"\n",(0,s.jsx)(t.li,{children:"The new ticket appears in the queue!"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Try it out in the browser. Now when we add a ticket via the form, it will be added to the queue!"}),"\n",(0,s.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.p,{children:"In this lesson, we learned how to pass data from a child component up to a parent component using callbacks. This is a fundamental pattern in React:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"State lives in the parent"})," component that needs to share it."]}),"\n",(0,s.jsxs)(t.li,{children:["We ",(0,s.jsx)(t.strong,{children:"pass a callback function down"})," to child components as a prop."]}),"\n",(0,s.jsxs)(t.li,{children:["The child ",(0,s.jsx)(t.strong,{children:"calls this function"})," (usually in response to an event) and passes data as an argument."]}),"\n",(0,s.jsxs)(t.li,{children:["The parent's function ",(0,s.jsx)(t.strong,{children:"receives the data"})," and updates state."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Naming convention:"})," ",(0,s.jsx)(t.code,{children:"handleX"})," for the function, ",(0,s.jsx)(t.code,{children:"onX"})," for the prop."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"This pattern maintains unidirectional data flow while still allowing child components to communicate with their parents."})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);