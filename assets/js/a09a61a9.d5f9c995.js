"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[98435],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>c});var o=n(96540);const a={},i=o.createContext(a);function s(e){const t=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),o.createElement(i.Provider,{value:t},e.children)}},30955:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"react/react-fundamentals/4-2-1-6-updating-state-with-events","title":"\ud83d\udcd3 4.2.1.6 Updating State with Events","description":"In this lesson, we\'ll handle our first event in a React application. We\'ve handled many events before \u2014 every time we use functions to respond to a click or a submit button, we are handling an event. There are some fundamental differences to handling events in React, but for the most part, the process is very similar:","source":"@site/docs/4_react/2_react-fundamentals/4-2-1-06-updating-state-with-events.md","sourceDirName":"4_react/2_react-fundamentals","slug":"/react/react-fundamentals/4-2-1-6-updating-state-with-events","permalink":"/v1.2/react/react-fundamentals/4-2-1-6-updating-state-with-events","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 4.2.1.6 Updating State with Events","day":"monday","id":"4-2-1-6-updating-state-with-events","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 4.2.1.5 Conditional Rendering","permalink":"/v1.2/react/react-fundamentals/4-2-1-5-conditional-rendering"},"next":{"title":"\ud83d\udcd3 4.2.1.7 Binding Functions in React","permalink":"/v1.2/react/react-fundamentals/4-2-1-7-binding-functions-in-react"}}');var a=n(74848),i=n(28453);const s={title:"\ud83d\udcd3 4.2.1.6 Updating State with Events",day:"monday",id:"4-2-1-6-updating-state-with-events",hide_table_of_contents:!0},c=void 0,r={},l=[{value:"Adding a Click Handler to JSX",id:"adding-a-click-handler-to-jsx",level:2},{value:"Calling a Function in a State Component",id:"calling-a-function-in-a-state-component",level:2},{value:"Toggling a Boolean When Updating State",id:"toggling-a-boolean-when-updating-state",level:2},{value:"Refactoring Our Button to Toggle Between Components",id:"refactoring-our-button-to-toggle-between-components",level:3}];function d(e){const t={a:"a",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"In this lesson, we'll handle our first event in a React application. We've handled many events before \u2014 every time we use functions to respond to a click or a submit button, we are handling an event. There are some fundamental differences to handling events in React, but for the most part, the process is very similar:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"First, we add a click handler to an element (such as a button)."}),"\n",(0,a.jsx)(t.li,{children:"Next, that click handler will trigger some code, often a function. We need to write that function as well."}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"adding-a-click-handler-to-jsx",children:"Adding a Click Handler to JSX"}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.p,{children:"Here's how our click handler will look:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:"<button onClick={this.handleClick}>Add ticket</button>\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Here, we take a ",(0,a.jsx)(t.code,{children:"button"})," element and add an ",(0,a.jsx)(t.code,{children:"onClick"})," handler to it. We need to specify the function ",(0,a.jsx)(t.code,{children:"onClick"})," will trigger. As always, we need to use curly braces to make sure that JSX properly evaluates any JS code to the right of our ",(0,a.jsx)(t.code,{children:"onClick"})," handler."]}),"\n",(0,a.jsxs)(t.p,{children:["In the example above, our ",(0,a.jsx)(t.code,{children:"onClick"})," handler will trigger ",(0,a.jsx)(t.code,{children:"this.handleClick"}),". As you can probably guess ",(0,a.jsx)(t.code,{children:"handleClick()"})," is the function that will be called when the handler is triggered. But what is ",(0,a.jsx)(t.code,{children:"this"}),"? In this case, we are going to be rendering an object that's an instance of the ",(0,a.jsx)(t.code,{children:"TicketControl"})," component. ",(0,a.jsx)(t.code,{children:"this"})," refers to the specific instance that is being rendered."]}),"\n",(0,a.jsxs)(t.p,{children:["Note that we don't use ",(0,a.jsx)(t.code,{children:"this"})," with function components \u2014 just class components. But we won't worry about that right now. We will get a chance to add functions to function components soon enough."]}),"\n",(0,a.jsxs)(t.p,{children:["Note that there are a few syntactical differences between how we do this in React as opposed to how we'd accomplish the same thing with JavaScript. Instead of ",(0,a.jsx)(t.code,{children:"onclick"}),", we use ",(0,a.jsx)(t.code,{children:"onClick"})," (as always, case is important). In plain old JavaScript, we'd wrap the function being called in a string. For instance, we might do this: ",(0,a.jsx)(t.code,{children:'<button onclick="doSomething()">'}),". In JSX, we use curly braces. Other than these syntactical differences, attaching click handlers in React is very similar to how we might attach a click handler in a vanilla JavaScript application."]}),"\n",(0,a.jsxs)(t.p,{children:["Now let's actually add our event handler to our component. Our event handler will go in the ",(0,a.jsx)(t.code,{children:"render()"})," method of ",(0,a.jsx)(t.code,{children:"TicketControl.js"}),":"]}),"\n",(0,a.jsx)(t.div,{className:"filename",children:"src/components/TicketControl.js"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"...\n\n  render(){\n    let currentlyVisibleState = null;\n    let addTicketButton = null; // new code\n    if (this.state.formVisibleOnPage) {\n      currentlyVisibleState = <NewTicketForm />\n    } else {\n      currentlyVisibleState = <TicketList />\n      addTicketButton = <button onClick={this.handleClick}>Add ticket</button> // new code\n    }\n    return (\n      <React.Fragment>\n        {currentlyVisibleState}\n        {addTicketButton} { /* new code */}\n      </ React.Fragment>\n    );\n  }\n\n...\n"})}),"\n",(0,a.jsx)(t.p,{children:"Before we continue, note that there are two different kinds of comments above \u2014 this is expected. Comments in JSX syntax need to be wrapped in curly braces, unlike the other comments, which are standard JS comments."}),"\n",(0,a.jsx)(t.p,{children:"We've added three lines of code:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["First, we create a new variable called ",(0,a.jsx)(t.code,{children:"addTicketButton"})," and set its value to ",(0,a.jsx)(t.code,{children:"null"}),"."]}),"\n",(0,a.jsxs)(t.li,{children:["Next, if ",(0,a.jsx)(t.code,{children:"this.state.formVisibleOnPage"})," is set to ",(0,a.jsx)(t.code,{children:"false"}),", we will set the value of our ",(0,a.jsx)(t.code,{children:"addTicketButton"})," variable to our button with its click handler."]}),"\n",(0,a.jsxs)(t.li,{children:["Finally, we make sure that ",(0,a.jsx)(t.code,{children:"{addTicketButton}"})," will be returned from our function. If its value is still ",(0,a.jsx)(t.code,{children:"null"}),", there's nothing to add to the DOM. However, if it has a value, the button will be added to the DOM."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["You may wonder why we have this button here instead of in the ",(0,a.jsx)(t.code,{children:"TicketList"})," component. Well, this button has nothing to do with our ",(0,a.jsx)(t.code,{children:"TicketList"})," component so it shouldn't be there. However, it ",(0,a.jsx)(t.em,{children:"does"})," have a lot to do with ",(0,a.jsx)(t.code,{children:"TicketControl"})," \u2014 it's a large part of determining which component should be showing!"]}),"\n",(0,a.jsxs)(t.p,{children:["There's one other reason the button isn't in another component. If it were in a child component, we'd have to pass our ",(0,a.jsx)(t.code,{children:"this.handleClick"})," function to the child component using something called ",(0,a.jsx)(t.strong,{children:"unidirectional data flow"}),". That makes things a bit more complicated and we aren't quite there yet."]}),"\n",(0,a.jsx)(t.h2,{id:"calling-a-function-in-a-state-component",children:"Calling a Function in a State Component"}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsxs)(t.p,{children:["Next, we need to write the function that we've associated with our event handler. That way, when an event actually triggers the handler, the function is called. Any functions we write will go after the constructor and before the ",(0,a.jsx)(t.code,{children:"render()"})," method. Let's write a ",(0,a.jsx)(t.code,{children:"handleClick()"}),' method now. Note that we are using the term "method" here. Remember that a method is a function that\'s called on an object. ',(0,a.jsx)(t.code,{children:"handleClick()"})," is a method that has to be called on an instance of the ",(0,a.jsx)(t.code,{children:"TicketControl"})," class \u2014 it can't be called elsewhere."]}),"\n",(0,a.jsx)(t.div,{className:"filename",children:"src/components/TicketControl.js"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"...\n\nclass TicketControl extends React.Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      formVisibleOnPage: false\n    };\n  }\n\n  handleClick = () => {\n    this.setState({formVisibleOnPage: true});\n  }\n\n...\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Our new ",(0,a.jsx)(t.code,{children:"handleClick()"})," method uses arrow notation. This is very important. We will go over why in the next lesson when we discuss binding functions."]}),"\n",(0,a.jsx)(t.p,{children:"Let's take a look at the code in our new method. There's only a single line of code:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:"this.setState({formVisibleOnPage: true});\n"})}),"\n",(0,a.jsxs)(t.p,{children:["As we discussed in ",(0,a.jsx)(t.a,{href:"../../react/react-fundamentals/4-2-1-2-introduction-to-state",children:"Introduction to State"}),", we should only ever modify state in a pure React application with the ",(0,a.jsx)(t.code,{children:"setState()"})," method. In its simplest form, ",(0,a.jsx)(t.code,{children:"setState()"})," takes an object as an argument. The object contains any key-value pairs that our application should update."]}),"\n",(0,a.jsx)(t.p,{children:'Now if we run our application, we can successfully click on "Add Ticket" and our form will show.'}),"\n",(0,a.jsx)(t.h2,{id:"toggling-a-boolean-when-updating-state",children:"Toggling a Boolean When Updating State"}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.p,{children:"When we add a working form to our application, our submit button will return users to the list of tickets. However, what if a user changes their mind and wants to return to the queue, anyway? Let's add a button that users can click to return to the queue from the form page without submitting a ticket. That way, we can learn about efficiently toggling a boolean in React state."}),"\n",(0,a.jsxs)(t.p,{children:["First, we'll update our ",(0,a.jsx)(t.code,{children:"handleClick()"})," method:"]}),"\n",(0,a.jsx)(t.div,{className:"filename",children:"src/components/TicketControl.js"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"...\n  handleClick = () => {\n    this.setState(prevState => ({\n      formVisibleOnPage: !prevState.formVisibleOnPage\n    }));\n  }\n...\n"})}),"\n",(0,a.jsxs)(t.p,{children:["As we can see, ",(0,a.jsx)(t.code,{children:"setState()"})," just got more complex. This method can just take an object \u2014 and more often than not, just passing in an object will suit our needs."]}),"\n",(0,a.jsxs)(t.p,{children:["However, if we want to refer to the previous state (such as with toggling a boolean or incrementing a counter), we need to know a little more about ",(0,a.jsx)(t.code,{children:"setState()"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"setState()"})," can optionally take two arguments (we will only discuss the first here). This is the actual first argument that ",(0,a.jsx)(t.code,{children:"setState()"})," can take:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"(state, props) => stateChange\n"})}),"\n",(0,a.jsxs)(t.p,{children:["We can choose to just pass in an object (the ",(0,a.jsx)(t.code,{children:"stateChange"}),"), but we can also pass in an arrow function that takes the current ",(0,a.jsx)(t.code,{children:"state"})," and ",(0,a.jsx)(t.code,{children:"props"})," as arguments. As we just mentioned, there are plenty of use cases where we need to know about the current state. Here are some examples:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"We want to toggle a boolean."})," That means we need to know the current state of the boolean so we can toggle it to its opposite state."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"We want to increment or decrement a value."})," A prime example is a counter that we need to increment by one or some other value each time a button is clicked."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"We want to update the state of a game."})," Let's say we are making a game where the location of pieces is constantly changing. We need to know the previous state to determine where pieces can move next."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Now let's return to the ",(0,a.jsx)(t.code,{children:"setState()"})," method in ",(0,a.jsx)(t.code,{children:"handleClick()"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"this.setState(prevState => ({\n  formVisibleOnPage: !prevState.formVisibleOnPage\n}));\n"})}),"\n",(0,a.jsxs)(t.p,{children:["We pass in the current state of the ",(0,a.jsx)(t.code,{children:"formVisibleOnPage"})," boolean to ",(0,a.jsx)(t.code,{children:"prevState"}),". Now that we know this value, we can say the new state should be ",(0,a.jsx)(t.code,{children:"!prevState.formVisibleOnPage"})," (the opposite of the old state)."]}),"\n",(0,a.jsxs)(t.p,{children:["We recommend experimenting with adding counters, booleans, and other states that need updating to your applications to get more practice with this slightly more complex implementation of ",(0,a.jsx)(t.code,{children:"setState()"}),"."]}),"\n",(0,a.jsx)(t.h3,{id:"refactoring-our-button-to-toggle-between-components",children:"Refactoring Our Button to Toggle Between Components"}),"\n",(0,a.jsxs)(t.p,{children:["Now that we've updated our ",(0,a.jsx)(t.code,{children:"handleClick()"})," method, we just need to update our ",(0,a.jsx)(t.code,{children:"render()"})," method so that we have a button to toggle back to the Help Queue with our form. Let's do this with the minimum amount of code possible. We'll need to refactor just a little."]}),"\n",(0,a.jsx)(t.div,{className:"filename",children:"src/components/TicketControl.js"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:'  render(){\n    let currentlyVisibleState = null;\n    let buttonText = null; // new code\n    if (this.state.formVisibleOnPage) {\n      currentlyVisibleState = <NewTicketForm />;\n      buttonText = "Return to Ticket List"; // new code\n    } else {\n      currentlyVisibleState = <TicketList />;\n      buttonText = "Add Ticket"; // new code\n    }\n    return (\n      <React.Fragment>\n        {currentlyVisibleState}\n        <button onClick={this.handleClick}>{buttonText}</button> { /* new code */ }\n      </React.Fragment>\n    );\n  }\n'})}),"\n",(0,a.jsxs)(t.p,{children:["Now that we know we need our button in both components, we can move it out of the conditional and into our ",(0,a.jsx)(t.code,{children:"return()"})," statement. We only need to change the text on the button so we create a new variable called ",(0,a.jsx)(t.code,{children:"buttonText"}),". It's the same button regardless of which component the user is looking at \u2014 but the text will make it seem like it's a different button."]}),"\n",(0,a.jsxs)(t.p,{children:["At this point, we've successfully added local state and we can use a button to toggle back and forth between two components. In the process, we've also learned more about how ",(0,a.jsx)(t.code,{children:"setState()"})," works. Make sure to take the time to practice working with local state and getting to learn the ins and outs of ",(0,a.jsx)(t.code,{children:"setState()"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);