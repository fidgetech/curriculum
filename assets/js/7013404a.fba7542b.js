"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[81539],{14224:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/trie_1-2c762ebdd8c22e73b84f4ac312a825ec.png"},28453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>a});var n=s(96540);const o={},i=n.createContext(o);function r(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),n.createElement(i.Provider,{value:t},e.children)}},39368:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/trie2-c6106e78ebb265dcb89f92a296f42386.png"},65442:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"capstone/capstone-week-1/tries","title":"\ud83d\udcd3 Tries","description":"In this lesson, we will introduce the trie (pronounced \\"try\\"), which is a kind of tree that\'s often used for storing and retrieving strings. In fact, the word trie is associated with the \\"trie\\" in retrieval. We\'ll focus on the basics of what a trie is in this lesson. Then, if you like, you can do further research on your own to learn about how to add, remove, and find values in a trie.","source":"@site/versioned_docs/version-WIP/capstone/1_capstone-week-1/tries.md","sourceDirName":"capstone/1_capstone-week-1","slug":"/capstone/capstone-week-1/tries","permalink":"/WIP/capstone/capstone-week-1/tries","draft":false,"unlisted":false,"tags":[],"version":"WIP","sidebarPosition":43,"frontMatter":{"title":"\ud83d\udcd3 Tries","id":"tries","slug":"tries","hide_table_of_contents":true,"sidebar_position":43,"day":"thursday","type":"lesson","url":"https://github.com/epicodus-curriculum/capstone/blob/main/tries.md"},"sidebar":"capstone","previous":{"title":"\ud83d\udcd3 Heaps","permalink":"/WIP/capstone/capstone-week-1/heaps"},"next":{"title":"\ud83d\udcd3 Memory Basics","permalink":"/WIP/capstone/capstone-week-1/memory-basics"}}');var o=s(74848),i=s(28453);const r={title:"\ud83d\udcd3 Tries",id:"tries",slug:"tries",hide_table_of_contents:!0,sidebar_position:43,day:"thursday",type:"lesson",url:"https://github.com/epicodus-curriculum/capstone/blob/main/tries.md"},a=void 0,c={},d=[];function h(e){const t={a:"a",em:"em",img:"img",p:"p",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["In this lesson, we will introduce the ",(0,o.jsx)(t.strong,{children:"trie"}),' (pronounced "try"), which is a kind of tree that\'s often used for storing and retrieving strings. In fact, the word ',(0,o.jsx)(t.strong,{children:"trie"}),' is associated with the "trie" in re',(0,o.jsx)(t.strong,{children:"trie"}),"val. We'll focus on the basics of what a trie is in this lesson. Then, if you like, you can do further research on your own to learn about how to add, remove, and find values in a trie."]}),"\n",(0,o.jsx)(t.p,{children:"A trie always has an \"empty\" root node with references to other nodes. Because of the references, it's not really empty \u2014 but the root node doesn't have a value on its own. It's common to use tries to store words, so if we were going to use a trie to store English words, we'd have a root node with 26 child nodes. Each child node would represent a letter of the alphabet."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"This trie shows an empty root node plus the first three letters of the alphabet.",src:s(14224).A+"",width:"371",height:"201"})}),"\n",(0,o.jsx)(t.p,{children:"To simplify things, the trie above just shows the first three letters of the alphabet."}),"\n",(0,o.jsx)(t.p,{children:"So what happens once we want to add actual words to a trie?"}),"\n",(0,o.jsx)(t.p,{children:"Each child node has a reference to each letter of the alphabet \u2014 just like the root node. So we'd construct words by adding more child nodes to the trie."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"This trie includes the words &quot;cat&quot;, &quot;call&quot;, and &quot;cot&quot;.",src:s(39368).A+"",width:"541",height:"501"})}),"\n",(0,o.jsxs)(t.p,{children:["This trie now includes three words: ",(0,o.jsx)(t.em,{children:"cat"}),", ",(0,o.jsx)(t.em,{children:"call"}),", and ",(0,o.jsx)(t.em,{children:"cot"}),". Each use the ",(0,o.jsx)(t.em,{children:"C"})," node, which now has two child nodes to represent the three words we've added: an ",(0,o.jsx)(t.em,{children:"A"})," node and an ",(0,o.jsx)(t.em,{children:"O"})," node. Cat and call both use the ",(0,o.jsx)(t.em,{children:"C"})," and its child ",(0,o.jsx)(t.em,{children:"A"})," node. If we were going to add the word ",(0,o.jsx)(t.em,{children:"can"}),", it would also use these two nodes before diverging."]}),"\n",(0,o.jsxs)(t.p,{children:["The main advantage of tries is that they can retrieve strings very quickly. However, a significant disadvantage of tries is that they take a large amount of memory. Despite the memory issue, there are many important use cases for quick string retrieval. For instance, consider the autofill feature on search engines. A trie can be used to quickly determine possible substrings if a user has typed in the letters ",(0,o.jsx)(t.em,{children:"c"})," and ",(0,o.jsx)(t.em,{children:"a"}),". You can likely imagine many other use cases where quickly retrieving strings is important \u2014 ranging from the fields of genomics to data analytics."]}),"\n",(0,o.jsxs)(t.p,{children:["If you'd like to learn how to create and search a trie yourself, check out the following article: ",(0,o.jsx)(t.a,{href:"https://medium.com/@alexanderv/tries-javascript-simple-implementation-e2a4e54e4330",children:"Tries \u2014 JavaScript Simple Implementation"}),"."]})]})}function l(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}}}]);