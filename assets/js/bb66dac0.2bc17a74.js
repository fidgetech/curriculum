"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[7263],{28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>c});var o=s(96540);const i={},r=o.createContext(i);function t(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),o.createElement(r.Provider,{value:n},e.children)}},68676:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"c-and-net/lessons-19-31-basic-console-apps/3-0-0-31-configuration-reference-and-review-of-c-conventions","title":"\ud83d\udcd3 3.0.0.31 Configuration Reference and Review of C# Conventions","description":"In this lesson, we\'re going to review the C# style conventions that we\'ve learned about so far. This lesson also includes a configuration and project structure reference that you can use in all of your future console app projects.","source":"@site/versioned_docs/version-v1_3/3_c-and-net/0_lessons-19-31-basic-console-apps/3-0-0-31-configuration-reference-and-review-of-c-conventions.md","sourceDirName":"3_c-and-net/0_lessons-19-31-basic-console-apps","slug":"/c-and-net/lessons-19-31-basic-console-apps/3-0-0-31-configuration-reference-and-review-of-c-conventions","permalink":"/v1.3/c-and-net/lessons-19-31-basic-console-apps/3-0-0-31-configuration-reference-and-review-of-c-conventions","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 3.0.0.31 Configuration Reference and Review of C# Conventions","day":"weekend","id":"3-0-0-31-configuration-reference-and-review-of-c-conventions","hide_table_of_contents":true,"pagination_next":null},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.0.0.30 Console App Project Structure: How to Add More Code Files","permalink":"/v1.3/c-and-net/lessons-19-31-basic-console-apps/3-0-0-30-console-app-project-structure-how-to-add-more-code-files"}}');var i=s(74848),r=s(28453);const t={title:"\ud83d\udcd3 3.0.0.31 Configuration Reference and Review of C# Conventions",day:"weekend",id:"3-0-0-31-configuration-reference-and-review-of-c-conventions",hide_table_of_contents:!0,pagination_next:null},c=void 0,l={},a=[{value:"Style Conventions",id:"style-conventions",level:2},{value:"Indentation and Spacing",id:"indentation-and-spacing",level:3},{value:"Capitalization and Naming",id:"capitalization-and-naming",level:3},{value:"Other Conventions",id:"other-conventions",level:3},{value:"Configuration and File Structure Reference",id:"configuration-and-file-structure-reference",level:2},{value:"Reminder: Commit Your <code>.gitignore</code> First!",id:"reminder-commit-your-gitignore-first",level:3},{value:"<code>.csproj</code> Files",id:"csproj-files",level:3},{value:"Build Folders",id:"build-folders",level:3},{value:"Code Files: User Interface Logic in <code>Program.cs</code>",id:"code-files-user-interface-logic-in-programcs",level:3},{value:"Code Files: Business Logic in the <code>Models</code> subdirectory",id:"code-files-business-logic-in-the-models-subdirectory",level:3},{value:"Organizing More Code Files",id:"organizing-more-code-files",level:3}];function d(e){const n={a:"a",code:"code",div:"div",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"In this lesson, we're going to review the C# style conventions that we've learned about so far. This lesson also includes a configuration and project structure reference that you can use in all of your future console app projects."}),"\n",(0,i.jsx)(n.h2,{id:"style-conventions",children:"Style Conventions"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"In order to become good programmers, we need to use a consistent coding style. When our code is consistent, we can focus on what the code does instead of how it's written. Errors are more apparent when debugging and it's easier to collaborate with other developers."}),"\n",(0,i.jsx)(n.p,{children:"Here are some general C# coding guidelines to follow from the .NET docs:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/identifier-names",children:"C# Naming Conventions"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions",children:"C# Coding Conventions"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"indentation-and-spacing",children:"Indentation and Spacing"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Each brace should begin on a new line. This is called ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Indent_style#Allman_style",children:"Allman Style"}),". A single line statement block can go without braces but the block must be properly indented on its own line and must not be nested in other statement blocks that use braces."]}),"\n",(0,i.jsx)(n.li,{children:"Avoid more than one empty line at any time. For example, do not have two blank lines between members of a type."}),"\n",(0,i.jsxs)(n.li,{children:["Avoid free spaces. For example, avoid ",(0,i.jsx)(n.code,{children:"if (someVar == 0) . . ."}),", where the dots mark the extra free spaces."]}),"\n",(0,i.jsx)(n.li,{children:"Be consistent in your use of indentation. At Epicodus, we use two spaces of indentation while the .NET documentation recommends four spaces of indentation. There are advantages to both approaches. One advantage of two spaces is that a line of code is less likely to run past the width of a text editor. An advantage of four spaces is that some developers believe it's easier to read. Ultimately, it's a matter of preference \u2014 and being consistent with the standards of your workplace. At Epicodus, use two spaces unless you and your pair agree to use four. (You may use either two or four on independent projects.)"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"capitalization-and-naming",children:"Capitalization and Naming"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Use PascalCase for:\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"public field names"}),"\n",(0,i.jsx)(n.li,{children:"public property names"}),"\n",(0,i.jsx)(n.li,{children:"class names"}),"\n",(0,i.jsx)(n.li,{children:"method names"}),"\n",(0,i.jsx)(n.li,{children:"namespaces"}),"\n",(0,i.jsx)(n.li,{children:"file names"}),"\n",(0,i.jsx)(n.li,{children:"directory names"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Use lowerCamelCase for all method parameters and local variables."}),"\n",(0,i.jsxs)(n.li,{children:["Prepend an underscore ",(0,i.jsx)(n.code,{children:"_"})," and use lowerCamelCase for all private field names."]}),"\n",(0,i.jsxs)(n.li,{children:["Namespace names should be separated by a period, as in ",(0,i.jsx)(n.code,{children:"ShapeTracker.Models"})," or ",(0,i.jsx)(n.code,{children:"ShapeTracker.UserInterfaceModels"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"other-conventions",children:"Other Conventions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Always specify the visibility, even if it is the default. For example, we should say ",(0,i.jsx)(n.code,{children:"private string Description"}),", not ",(0,i.jsx)(n.code,{children:"string Description"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Always declare the variable type, including if that type is a class. For example, we should use the code ",(0,i.jsx)(n.code,{children:"Item newItem = new Item(...)"}),", since the type of ",(0,i.jsx)(n.code,{children:"newItem"})," is ",(0,i.jsx)(n.code,{children:"Item"}),". We should not use the code ",(0,i.jsx)(n.code,{children:"var newItem = new Item(...)"})," since the type of ",(0,i.jsx)(n.code,{children:"newItem"})," is ",(0,i.jsx)(n.code,{children:"Item"}),". In general, ",(0,i.jsx)(n.code,{children:"var"})," is too vague and shouldn't be used."]}),"\n",(0,i.jsx)(n.li,{children:"Namespace imports should be specified at the top of the file, outside of namespace declarations, and should be sorted alphabetically."}),"\n",(0,i.jsx)(n.li,{children:"Semicolons are required after all statements."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"configuration-and-file-structure-reference",children:"Configuration and File Structure Reference"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"C# console apps should follow certain naming conventions and file structure:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["There should be a parent directory named ",(0,i.jsx)(n.code,{children:"ProjectName.Solution"}),". Our solution directory will contain our project's production directory, as well as a testing directory that we'll add in the next pre-work section.\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["While we don't have to use ",(0,i.jsx)(n.code,{children:"ProjectName.Solution"}),", it's still common to have a parent directory named at least ",(0,i.jsx)(n.code,{children:"ProjectName"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Within the parent directory we should include a ",(0,i.jsx)(n.code,{children:"README.md"})," and ",(0,i.jsx)(n.code,{children:".gitignore"}),". The ",(0,i.jsx)(n.code,{children:".gitignore"})," should include ",(0,i.jsx)(n.code,{children:"obj"})," and ",(0,i.jsx)(n.code,{children:"bin"}),", which are auto-generated files from the compilation process."]}),"\n",(0,i.jsxs)(n.li,{children:["Within the parent directory, we'll add a subdirectory for the production code:\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"ProjectName"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Within the ",(0,i.jsx)(n.code,{children:"ProjectName"})," subdirectory, we'll add the following files and folders:\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Create a ",(0,i.jsx)(n.code,{children:"ProjectName.csproj"})," file, which will contain our project's configurations and required resources."]}),"\n",(0,i.jsxs)(n.li,{children:["Create a ",(0,i.jsx)(n.code,{children:"Program.cs"})," file, which will contain our project's user interface logic as well as the entry point to our application."]}),"\n",(0,i.jsxs)(n.li,{children:["Create a ",(0,i.jsx)(n.code,{children:"Models"})," subdirectory, which will contain any business logic files."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["When you are ready to create business logic files, they should be added to the ",(0,i.jsx)(n.code,{children:"Models"})," subdirectory, and named in one of two ways:\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["After the class it contains, as in ",(0,i.jsx)(n.code,{children:"Triangle.cs"})," contains a ",(0,i.jsx)(n.code,{children:"Triangle"})," class."]}),"\n",(0,i.jsxs)(n.li,{children:["A plural name that generally represents the multiple classes that the file contains, as in ",(0,i.jsx)(n.code,{children:"Helpers.cs"})," or ",(0,i.jsx)(n.code,{children:"Banners.cs"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Include a ",(0,i.jsx)(n.code,{children:"public"})," access modifier so the business logic file can be accessible to tests, which will live in a separate assembly. (We'll learn about testing in the next pre-work section.)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"This is standard naming convention and should be followed in all projects."})}),"\n",(0,i.jsx)(n.p,{children:"After following these steps, the directory should look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"ProjectName.Solution/\n  \u251c\u2500\u2500 ProjectName/\n  \u2502     \u251c\u2500\u2500 Models/\n  \u2502     \u2502     \u2514\u2500\u2500 ClassName.cs\n  \u2502     \u251c\u2500\u2500 ProjectName.csproj\n  \u2502     \u2514\u2500\u2500 Program.cs\n  \u251c\u2500\u2500 .gitignore\n  \u2514\u2500\u2500 README.md\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"reminder-commit-your-gitignore-first",children:["Reminder: Commit Your ",(0,i.jsx)(n.code,{children:".gitignore"})," First!"]}),"\n",(0,i.jsxs)(n.p,{children:["This is a friendly reminder to make sure that you set up and commit your ",(0,i.jsx)(n.code,{children:".gitignore"})," first after you initialize Git in your projects. Doing so ensures that you are ignoring the files you don't want saved to your remote GitHub repo first."]}),"\n",(0,i.jsxs)(n.p,{children:["Your ",(0,i.jsx)(n.code,{children:".gitignore"})," should look like this:"]}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"ProjectName.Solution/.gitignore"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"obj\nbin\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"csproj-files",children:[(0,i.jsx)(n.code,{children:".csproj"})," Files"]}),"\n",(0,i.jsxs)(n.p,{children:["Our ",(0,i.jsx)(n.code,{children:".csproj"}),' file is the "project file" and it lists project-wide configurations as well as all outside packages or dependencies our project requires. In this course section, our ',(0,i.jsx)(n.code,{children:".csproj"})," files will contain the following boilerplate code:"]}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"ProjectName.Solution/ProjectName/ProjectName.csproj"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'<Project Sdk="Microsoft.NET.Sdk">\n\n  <PropertyGroup>\n    <TargetFramework>net6.0</TargetFramework>\n    <OutputType>Exe</OutputType>\n  </PropertyGroup>\n\n</Project>\n'})}),"\n",(0,i.jsx)(n.h3,{id:"build-folders",children:"Build Folders"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"obj"})," and ",(0,i.jsx)(n.code,{children:"bin"})," folders are generated automatically when you run the command ",(0,i.jsx)(n.code,{children:"dotnet build"}),". The ",(0,i.jsx)(n.code,{children:"bin"})," directory contains our compiled output code. The ",(0,i.jsx)(n.code,{children:"obj"})," directory contains the resources our code needs."]}),"\n",(0,i.jsxs)(n.p,{children:["These folders are always located in the same folder as your project (",(0,i.jsx)(n.code,{children:".csproj"}),") file."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"ProjectName.Solution/\n  \u251c\u2500\u2500 ProjectName/\n  \u2502     \u251c\u2500\u2500 bin/\n  \u2502     \u251c\u2500\u2500 Models/\n  \u2502     \u2502     \u2514\u2500\u2500 ClassName.cs\n  \u2502     \u251c\u2500\u2500 obj/\n  \u2502     \u251c\u2500\u2500 ProjectName.csproj\n  \u2502     \u2514\u2500\u2500 Program.cs\n  \u251c\u2500\u2500 .gitignore\n  \u2514\u2500\u2500 README.md\n"})}),"\n",(0,i.jsx)(n.p,{children:"We won't spend much time learning about these folders or look at their contents. Since these folders are auto-generated, we won't include them in project file/folder structure examples."}),"\n",(0,i.jsxs)(n.h3,{id:"code-files-user-interface-logic-in-programcs",children:["Code Files: User Interface Logic in ",(0,i.jsx)(n.code,{children:"Program.cs"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Program.cs"})," contains our user interface logic as well as the entry point to our application, the ",(0,i.jsx)(n.code,{children:"static void Main()"})," method. Here's the boilerplate for ",(0,i.jsx)(n.code,{children:"Program.cs"}),":"]}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"ProjectName.Solution/ProjectName/Program.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"namespace ProjectName\n{\n  class Program\n  {\n    static void Main()\n    {\n      // UI code goes here.\n    }\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["The standard namespace name for our program's entry point is ",(0,i.jsx)(n.code,{children:"ProjectName"}),"."]})," However, we can give it a more specific namespace like ",(0,i.jsx)(n.code,{children:"ProjectName.UserInterface"})," or something else."]}),"\n",(0,i.jsxs)(n.p,{children:["Note that ",(0,i.jsx)(n.code,{children:"Program.cs"})," does not need to be called ",(0,i.jsx)(n.code,{children:"Program.cs"}),", nor does the class name need to be ",(0,i.jsx)(n.code,{children:"Program"}),", however this is a very standard practice."]}),"\n",(0,i.jsxs)(n.h3,{id:"code-files-business-logic-in-the-models-subdirectory",children:["Code Files: Business Logic in the ",(0,i.jsx)(n.code,{children:"Models"})," subdirectory"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Models"})," directory should contain all of our business logic files. We'll follow the practice of having one business logic class per file, but it's totally okay to include multiple classes within a single file."]}),"\n",(0,i.jsxs)(n.p,{children:["The naming convention for business logic files and classes is for the name of the class to match the name of the file, as in ",(0,i.jsx)(n.code,{children:"Triangle.cs"})," contains the ",(0,i.jsx)(n.code,{children:"Triangle"})," class. We also need to include the ",(0,i.jsx)(n.code,{children:"public"})," access modifier for all classes that we want accessible to tests we write (which we'll learn about in the next pre-work section.)"]}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"ProjectName.Solution/ProjectName/Models/ClassName.cs"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"namespace ProjectName.Models\n{\n  public class ClassName\n  {\n    // Business Logic goes here.\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["The standard namespace name for all of our business logic files is ",(0,i.jsx)(n.code,{children:"ProjectName.Models"}),"."]})}),"\n",(0,i.jsx)(n.h3,{id:"organizing-more-code-files",children:"Organizing More Code Files"}),"\n",(0,i.jsx)(n.p,{children:"If we want to organize more code files (UI and business logic), this is a good way to go:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["All business logic files go in the ",(0,i.jsx)(n.code,{children:"Models/"})," directory."]}),"\n",(0,i.jsxs)(n.li,{children:["Create a new subdirectory within the ",(0,i.jsx)(n.code,{children:"ProjectName"})," directory called ",(0,i.jsx)(n.code,{children:"UserInterfaceModels"})," (or something similar) and add all additional user interface files within that subdirectory."]}),"\n",(0,i.jsxs)(n.li,{children:["It's convention for ",(0,i.jsx)(n.code,{children:"Program.cs"}),", the entry point to our application, to remain in the root of the production directory ",(0,i.jsx)(n.code,{children:"ProjectName"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Here's what the resulting file structure should look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"ProjectName.Solution/\n  \u251c\u2500\u2500 ProjectName/\n  \u2502     \u251c\u2500\u2500 Models/\n  |     |     \u251c\u2500\u2500 ClassName.cs\n  |     |     \u251c\u2500\u2500 ClassName.cs\n  \u2502     \u2502     \u2514\u2500\u2500 ClassName.cs\n  |     \u251c\u2500\u2500 UserInterfaceModels/\n  |     |     \u2514\u2500\u2500 ClassName.cs\n  \u2502     \u251c\u2500\u2500 ProjectName.csproj\n  \u2502     \u2514\u2500\u2500 Program.cs\n  \u251c\u2500\u2500 .gitignore\n  \u2514\u2500\u2500 README.md\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);