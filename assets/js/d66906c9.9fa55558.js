"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[58708],{10864:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>i,default:()=>l,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"capstone/capstone-week-1/introduction-to-graphs","title":"\ud83d\udcd3 Introduction to Graphs","description":"In computer science, a graph (also known as a network) is a collection of nodes (also known as vertices) and edges (also known as links or relations). We can think of nodes as things while the edges describe the relationships between those things. The study of graphs is known as graph theory and it fits into the larger field of network theory, which is useful for understanding everything from social networks to databases.","source":"@site/versioned_docs/version-v1_3/capstone/1_capstone-week-1/introduction-to-graphs.md","sourceDirName":"capstone/1_capstone-week-1","slug":"/capstone/capstone-week-1/introduction-to-graphs","permalink":"/v1.3/capstone/capstone-week-1/introduction-to-graphs","draft":false,"unlisted":false,"tags":[],"version":"v1_3","sidebarPosition":17,"frontMatter":{"title":"\ud83d\udcd3 Introduction to Graphs","id":"introduction-to-graphs","slug":"introduction-to-graphs","hide_table_of_contents":true,"sidebar_position":17,"day":"tuesday","type":"lesson","url":"https://github.com/epicodus-curriculum/capstone/blob/main/1_graphs.md"},"sidebar":"capstone","previous":{"title":"\u270f\ufe0f Binary Search Trees Practice","permalink":"/v1.3/capstone/capstone-week-1/binary-search-trees-practice"},"next":{"title":"\ud83d\udcd3 Representing Graph Structures with Code","permalink":"/v1.3/capstone/capstone-week-1/representing-graph-structures-with-code"}}');var a=n(74848),s=n(28453);const r={title:"\ud83d\udcd3 Introduction to Graphs",id:"introduction-to-graphs",slug:"introduction-to-graphs",hide_table_of_contents:!0,sidebar_position:17,day:"tuesday",type:"lesson",url:"https://github.com/epicodus-curriculum/capstone/blob/main/1_graphs.md"},i=void 0,h={},c=[];function d(e){const t={a:"a",code:"code",em:"em",img:"img",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["In computer science, a ",(0,a.jsx)(t.strong,{children:"graph"})," (also known as a network) is a collection of ",(0,a.jsx)(t.strong,{children:"nodes"})," (also known as vertices) and ",(0,a.jsx)(t.strong,{children:"edges"})," (also known as links or relations). We can think of nodes as ",(0,a.jsx)(t.em,{children:"things"})," while the edges describe the ",(0,a.jsx)(t.em,{children:"relationships"})," between those things. The study of graphs is known as graph theory and it fits into the larger field of network theory, which is useful for understanding everything from social networks to databases."]}),"\n",(0,a.jsx)(t.p,{children:"We've have actually been working with graphs a lot already. That's because the tree data structures we learned in the last section are graphs with additional rules. We'll talk about this more soon."}),"\n",(0,a.jsx)(t.p,{children:"First, let's take a look at a hypothetical example of a graph:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Graph shows interstellar routes between planets.",src:n(81368).A+"",width:"371",height:"361"})}),"\n",(0,a.jsxs)(t.p,{children:["An advanced interstellar civilization has set up travel routes between five planets. In this graph, the planets represent ",(0,a.jsx)(t.strong,{children:"nodes"}),". The travel routes between each planet represent ",(0,a.jsx)(t.strong,{children:"edges"}),". Edges can be ",(0,a.jsx)(t.strong,{children:"directed"})," (pointing in one direction) or ",(0,a.jsx)(t.strong,{children:"undirected"})," (pointing in both directions). If this terminology mostly sounds familiar already, it's because the tree structures we've been working with already are directed graphs!"]}),"\n",(0,a.jsx)(t.p,{children:"In the solar system above, it's possible to travel roundtrip between Lub and Nu because they are connected by an undirected edge. However, it's only possible to fly one way from Nu to Cyra because they are connected by a directed edge and the edge is pointing from Nu to Cyra. As the chart shows, the only way to fly from Zygob to Cyra would be:"}),"\n",(0,a.jsx)(t.p,{children:"Zygob -> Lub -> Nu -> Cyra"}),"\n",(0,a.jsxs)(t.p,{children:["Also, notice that the edge between Nu and Wobox points in only one direction \u2014 towards Wobox. This illustrates another key concept of graphs known as ",(0,a.jsx)(t.strong,{children:"reachability"}),". Once you go to Wobox, there is no way to get to any other planet. As a result, the rest of the graph is unreachable from this node."]}),"\n",(0,a.jsx)(t.p,{children:"Similarly, as we demonstrated above, the reachability of Cyra from Zygob is:"}),"\n",(0,a.jsx)(t.p,{children:"Zygob -> Lub -> Nu -> Cyra"}),"\n",(0,a.jsx)(t.p,{children:"If the graph above were completely undirected, we'd be able to travel round-trip to Nu without any backtracking:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"We can make a round trip between Lub, Nu, Zygob, and Cyra without backtracking.",src:n(13042).A+"",width:"371",height:"291"})}),"\n",(0,a.jsx)(t.p,{children:"In the image above, we could make a round trip to Nu without backtracking by doing either of the following:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"Nu -> Cyra -> Zygob -> Lub -> Nu\n"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"Nu -> Lub -> Zygob -> Cyra -> Nu\n"})}),"\n",(0,a.jsx)(t.p,{children:"There's no backtracking needed. For instance, if there were no edge between Zygob and Cyra, the only round trip to Nu would involve going to another node and then going back over the same edge again."}),"\n",(0,a.jsxs)(t.p,{children:["When we can loop to a node without backtracking, the loop is known as a ",(0,a.jsx)(t.strong,{children:"circuit"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["A graph can also be ",(0,a.jsx)(t.strong,{children:"weighted"})," or ",(0,a.jsx)(t.strong,{children:"unweighted"}),". If a graph is weighted, its edges have numerical values associated with them. If it's unweighted, its edges do not have numerical values."]}),"\n",(0,a.jsx)(t.p,{children:"We could make the graph above weighted by adding a numerical value to each edge. That numerical value could represent the distance between each planet, the cost to travel between planets, or even something like the number of aliens traveling between each planet."}),"\n",(0,a.jsxs)(t.p,{children:["Meanwhile, each node (such as Lub) can also contain information as well. As we mentioned at the beginning of the lesson, nodes are ",(0,a.jsx)(t.em,{children:"things"})," while edges depict ",(0,a.jsx)(t.em,{children:"relationships"}),". So a node could be an object with many properties. For instance, each planet might have ",(0,a.jsx)(t.code,{children:"name"}),", ",(0,a.jsx)(t.code,{children:"mass"}),", ",(0,a.jsx)(t.code,{children:"population"})," and ",(0,a.jsx)(t.code,{children:"atmosphericComposition"})," properties."]}),"\n",(0,a.jsx)(t.p,{children:"As we've already mentioned, trees are a special kind of graph. For instance, let's take another look at a binary search tree."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Image of binary search tree with directed edges.",src:n(26952).A+"",width:"481",height:"281"})}),"\n",(0,a.jsx)(t.p,{children:"We've made an update to this image of a binary search tree \u2014 now we depict it with directed edges. That's because in a tree data structure, parent nodes have knowledge of their children but child nodes don't know about their parents. To traverse a binary search tree (or other tree data structures), we need to start at the root node and work our way down. We can't start at a child node and work our way up because the edges of tree structures aren't undirected."}),"\n",(0,a.jsx)(t.p,{children:"At this point, it should be clear that a binary search tree (and other trees) are just graphs with special rules. In addition to having directed edges, they have other special rules as well. For instance, a node in a tree structure can only have one parent but many children. And binary search trees are even more specific \u2014 a node can have at most two child nodes. This is in contrast to graphs in general, where nodes don't have these specific rules."}),"\n",(0,a.jsx)(t.p,{children:"We take advantage of graph theory a lot in our daily lives, even if we aren't always applying the concepts personally."}),"\n",(0,a.jsx)(t.p,{children:"For instance, every day at Epicodus we use git regularly. Here's a graph showing the commit history of a project:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"A project with three branches.",src:n(56947).A+"",width:"761",height:"301"})}),"\n",(0,a.jsx)(t.p,{children:"Here, we see a project with a main branch plus two other branches (perhaps a feature and a dev branch). As we can see, all edges eventually lead back to the initial commit. From commit D, the history looks like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"First Commit, A, D\n"})}),"\n",(0,a.jsx)(t.p,{children:"However, from commit G the history looks like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"First Commit, A, B, E, F, G\n"})}),"\n",(0,a.jsx)(t.p,{children:"As we can see, we can't access commit G from commit D \u2014 they have alternate histories. We can depict a git commit history as a directed graph where all nodes eventually lead back to the initial commit."}),"\n",(0,a.jsx)(t.p,{children:"We also take advantage of graph theory every time we use a mapping application like Googlemaps."}),"\n",(0,a.jsx)(t.p,{children:"For instance, if we wanted to go from Powell's Books to Revolution Hall in Portland, we might look up directions to see which way is fastest."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Image shows series of nodes connected with directed edges.",src:n(79377).A+"",width:"2866",height:"1294"})}),"\n",(0,a.jsx)(t.p,{children:"In order to find the fastest route, Google will calculate the shortest distance between the first node (Powell's Books) and the last node (Revolution Hall). As you might guess, the edges need to be weighted so that the actual distance between each node can be determined."}),"\n",(0,a.jsx)(t.p,{children:"It's common to use algorithms to determine the shortest path between two nodes. It's also common to use algorithms to determine the reachability of a node. For instance, in our graph of planets from the beginning of the lesson, planet Zygob is not reachable from planet Wobox."}),"\n",(0,a.jsxs)(t.p,{children:["Before continuing to the next lesson, read ",(0,a.jsx)(t.a,{href:"http://think-like-a-git.net/sections/graph-theory.html",children:"Think Like A Git's section on Graph Theory"}),". Read from the page on ",(0,a.jsx)(t.em,{children:"Graph Theory"})," to the page on ",(0,a.jsx)(t.em,{children:"Reachability"}),". Don't worry \u2014 each page is a quick read and Portland developer Sam Livingston-Gray does an excellent job explaining the basics of graph theory with visuals."]}),"\n",(0,a.jsxs)(t.p,{children:["You may have read through Think Like a Git during ",(0,a.jsx)(t.a,{href:"/react/team-week/learning-more-about-git",children:"Intermediate JavaScript Team Week"}),". Even if you have, we still recommend reading this resource again."]}),"\n",(0,a.jsxs)(t.p,{children:["We also recommend this ",(0,a.jsx)(t.a,{href:"https://www.youtube.com/watch?v=82zlRaRUsaY&ab_channel=SystemsInnovation",children:"short video"})," on graph theory which provides a nice overview."]}),"\n",(0,a.jsxs)(t.p,{children:["Graph theory can get ",(0,a.jsx)(t.em,{children:"much"})," more complex than the basics we cover here. However, we now know enough to move onto the next step: representing graphs with code."]})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},13042:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/graph_circuit-bfc7247cdd6cabf812d8fd270a5de618.png"},26952:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/directed_binary_search_tree-d8b5918ced0f23e5f609811f255c63d9.png"},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>i});var o=n(96540);const a={},s=o.createContext(a);function r(e){const t=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),o.createElement(s.Provider,{value:t},e.children)}},56947:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/git_graph-d3997f3610feb972505ce176b1bea84c.png"},79377:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/google_maps_directed_graph-8470d492968db23f0f2a6a6f07657176.png"},81368:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/graph_theory_planets-a6a6267feb6d5b0c87b6349eab622034.png"}}]);