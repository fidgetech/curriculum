"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[70228],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var i=t(96540);const s={},a=i.createContext(s);function o(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:n},e.children)}},59457:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"react/react-fundamentals/3-2-3-4-using-jsx-expressions-with-arguments","title":"\ud83d\udcd3 3.2.3.4 Using JSX Expressions with Arguments","description":"Before we continue, let\'s discuss an important gotcha related to evaluating JavaScript functions in JSX curly braces.","source":"@site/versioned_docs/version-WIP/3_react/2_react-fundamentals/3-2-3-04-using-jsx-expressions-with-arguments.md","sourceDirName":"3_react/2_react-fundamentals","slug":"/react/react-fundamentals/3-2-3-4-using-jsx-expressions-with-arguments","permalink":"/WIP/react/react-fundamentals/3-2-3-4-using-jsx-expressions-with-arguments","draft":false,"unlisted":false,"tags":[],"version":"WIP","frontMatter":{"title":"\ud83d\udcd3 3.2.3.4 Using JSX Expressions with Arguments","day":"wednesday","id":"3-2-3-4-using-jsx-expressions-with-arguments","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 3.2.3.3 Planning Our Application: Part 3","permalink":"/WIP/react/react-fundamentals/3-2-3-3-planning-our-application-part-3"},"next":{"title":"\ud83d\udcd3 3.2.3.5 Showing Ticket Detail","permalink":"/WIP/react/react-fundamentals/3-2-3-5-showing-ticket-detail"}}');var s=t(74848),a=t(28453);const o={title:"\ud83d\udcd3 3.2.3.4 Using JSX Expressions with Arguments",day:"wednesday",id:"3-2-3-4-using-jsx-expressions-with-arguments",hide_table_of_contents:!0},r=void 0,c={},l=[];function d(e){const n={code:"code",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Before we continue, let's discuss an important gotcha related to evaluating JavaScript functions in JSX curly braces."}),"\n",(0,s.jsxs)(n.p,{children:["Let's look at an example. If we were to attach an ",(0,s.jsx)(n.code,{children:"onClick"})," handler to a JSX div, it might look something like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<div onClick={ doAThing }>Click This Button To Do A Thing</div>\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"doAThing"})," is a callback so it doesn't have parens. Let's say we were to add parens:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<div onClick={ doAThing() }>Click This Button To Do A Thing</div>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This will not have the intended effect. Now ",(0,s.jsx)(n.code,{children:"doAThing"})," will be invoked immediately when the DOM is updated \u2014 instead of waiting for a click event as it should."]}),"\n",(0,s.jsx)(n.p,{children:"We've seen this kind of behavior before. Here's an example of a function where we might want to pass another function in as a callback:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function thisTakesACallbackAsAnArgument(thisIsAFunction) {\n  const argumentToFunction = // some computed value\n  return thisIsAFunction(argumentToFunction);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the example above, ",(0,s.jsx)(n.code,{children:"thisIsAFunction"})," should take an argument \u2014 but we don't know what that argument should be until we calculate the variable ",(0,s.jsx)(n.code,{children:"argumentToFunction"}),". We can't pass in ",(0,s.jsx)(n.code,{children:"thisIsAFunction()"})," as an argument to the outer function because it will be invoked immediately. Instead, because ",(0,s.jsx)(n.code,{children:"thisIsAFunction"})," is a first-class citizen, we can pass it around like a variable until we are ready to invoke it by adding parens (in this case, parens that include the argument ",(0,s.jsx)(n.code,{children:"argumentToFunction"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"The example above is contrived \u2014 but it's similar to what's going on when we evaluate functions and methods inside JSX curly braces. Since these functions are usually connected to an event handler, we don't want them to be invoked immediately. We want them to wait until a user does something."}),"\n",(0,s.jsxs)(n.p,{children:["However, what if we need to pass an argument to a JavaScript function in curly braces? Let's say that ",(0,s.jsx)(n.code,{children:"doAThing"})," needs to take ",(0,s.jsx)(n.code,{children:"someOtherThing"})," as an argument. We can't do the following because it will be invoked immediately:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<div onClick={ doAThing(someOtherThing) }>Click This Button To Do A Thing</div>\n"})}),"\n",(0,s.jsx)(n.p,{children:"We only want this function to be invoked on a click event so we need to do the following:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<div onClick={ () => doAThing(someOtherThing) }>Click This Button To Do A Thing</div>\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"() => "})," is an anonymous arrow function with no parameters. You may wonder how in the world this will solve our problem. Well, let's take a look at a simpler example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const hey = () => "Hey there!"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If we check the value of ",(0,s.jsx)(n.code,{children:"hey"})," in the console, it's ",(0,s.jsx)(n.code,{children:'() => "hey there"'}),". The ",(0,s.jsx)(n.code,{children:"hey"})," variable is storing our anonymous function."]}),"\n",(0,s.jsx)(n.p,{children:"To invoke it, we need to do the following:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'hey()\n"Hey there!"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In other words, the ",(0,s.jsx)(n.code,{children:"() =>"})," syntax is just another way of creating a function literal."]}),"\n",(0,s.jsx)(n.p,{children:"Let's look at another example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'function heyThere(name) {\n  return `Hey ${name}!`\n}\n\nconst dontInvokeYet = () => heyThere("Jasmine")\nconst invokeNow = heyThere("Jasmine")\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Try this out in the console. Our ",(0,s.jsx)(n.code,{children:"heyThere"})," function needs to take a ",(0,s.jsx)(n.code,{children:"name"})," as an argument now \u2014 so we have to add parens to the function."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"dontInvokeYet"})," stores the function (because we use ",(0,s.jsx)(n.code,{children:"() => "}),"). We can invoke it later by calling ",(0,s.jsx)(n.code,{children:"dontInvokeYet()"}),". The value of the ",(0,s.jsx)(n.code,{children:"dontInvokeYet"})," variable is ",(0,s.jsx)(n.code,{children:'() => heyThere("Jasmine")'})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"invokeNow"})," will call the function immediately and store it in the ",(0,s.jsx)(n.code,{children:"invokeNow"})," variable. The value of the ",(0,s.jsx)(n.code,{children:"invokeNow"})," variable is ",(0,s.jsx)(n.code,{children:'"Hey Jasmine!"'})]}),"\n",(0,s.jsxs)(n.p,{children:["Applying this to our JSX example, we want the value of ",(0,s.jsx)(n.code,{children:"onClick"})," to be set to a function that should be evoked later, not now."]}),"\n",(0,s.jsx)(n.p,{children:"So while the syntax may look a little strange at first, remember that it's just JavaScript, not React. We always need to make sure that any event handlers being evaluated with JSX are invoked later (when an event is triggered), not immediately (when the component is rendered). React can only do this because JavaScript functions are first-class citizens. It's another way in which React leverages the functional programming power of JavaScript."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);