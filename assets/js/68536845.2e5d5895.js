"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[48518],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var o=t(96540);const i={},s=o.createContext(i);function r(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:n},e.children)}},87573:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"introduction-to-programming/arrays-looping/1-3-3-7-for-loops-with-text-analyzer","title":"\ud83d\udcd3 1.3.3.7 for Loops with Text Analyzer","description":"Over the last few lessons, we\'ve learned how and when to use a for loop. Now let\'s look at a couple of situations where a for loop would be better than Array.prototype.forEach() in our text analyzer application.","source":"@site/docs/1_introduction-to-programming/3_arrays-looping/1-3-3-07-for-loops-with-text-analyzer.md","sourceDirName":"1_introduction-to-programming/3_arrays-looping","slug":"/introduction-to-programming/arrays-looping/1-3-3-7-for-loops-with-text-analyzer","permalink":"/v1.2/introduction-to-programming/arrays-looping/1-3-3-7-for-loops-with-text-analyzer","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 1.3.3.7 for Loops with Text Analyzer","day":"wednesday","id":"1-3-3-7-for-loops-with-text-analyzer","hide_table_of_contents":true},"sidebar":"introduction-to-programming","previous":{"title":"\ud83d\udcd3 1.3.3.6 When to use for","permalink":"/v1.2/introduction-to-programming/arrays-looping/1-3-3-6-when-to-use-for"},"next":{"title":"\u270f\ufe0f 1.3.3.8 Practice: Pig Latin","permalink":"/v1.2/introduction-to-programming/arrays-looping/1-3-3-8-practice-pig-latin"}}');var i=t(74848),s=t(28453);const r={title:"\ud83d\udcd3 1.3.3.7 for Loops with Text Analyzer",day:"wednesday",id:"1-3-3-7-for-loops-with-text-analyzer",hide_table_of_contents:!0},a=void 0,c={},l=[{value:"Updating Text Analyzer To Use <code>for</code> Loops",id:"updating-text-analyzer-to-use-for-loops",level:2},{value:"Adding <code>firstInstanceOfWord()</code>",id:"adding-firstinstanceofword",level:3},{value:"Updating <code>isEmpty()</code> To Use Built-In JS <code>arguments</code> Object",id:"updating-isempty-to-use-built-in-js-arguments-object",level:3}];function d(e){const n={a:"a",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Over the last few lessons, we've learned how and when to use a ",(0,i.jsx)(n.code,{children:"for"})," loop. Now let's look at a couple of situations where a ",(0,i.jsx)(n.code,{children:"for"})," loop would be better than ",(0,i.jsx)(n.code,{children:"Array.prototype.forEach()"})," in our text analyzer application."]}),"\n",(0,i.jsxs)(n.p,{children:["We will not use TDD for these examples. That's because we've already covered TDD in depth and the goal here is to focus on ",(0,i.jsx)(n.code,{children:"for"})," loops. However, you are expected to continue using TDD in your own projects as well as on this section's independent project. We also won't incorporate the function into the UI. You can do that on your own."]}),"\n",(0,i.jsxs)(n.h2,{id:"updating-text-analyzer-to-use-for-loops",children:["Updating Text Analyzer To Use ",(0,i.jsx)(n.code,{children:"for"})," Loops"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.h3,{id:"adding-firstinstanceofword",children:["Adding ",(0,i.jsx)(n.code,{children:"firstInstanceOfWord()"})]}),"\n",(0,i.jsxs)(n.p,{children:["We'll start with adding new functionality to our application. Specifically, we'll add a function that finds the position of the ",(0,i.jsx)(n.strong,{children:"first"})," instance of a word in a passage of text. This is a good use case for a ",(0,i.jsx)(n.code,{children:"for"})," loop because we can break out of the loop as soon as we find the first instance of the word."]}),"\n",(0,i.jsx)(n.p,{children:"Here's how we might write this function:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'> function firstInstanceOfWord(word, text) {\n  const textArray = text.split(" ");\n  for (let i = 0; i < textArray.length; i++) {\n    console.log(i);\n    if (word === textArray[i]) {\n      return i;\n    }\n  }\n  return -1;\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Add this code to the DevTools console and then call it with the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'> firstInstanceOfWord("hi", "hey hi hey hey hey hey hey hey what");\n0\n\u200b1\n1\n'})}),"\n",(0,i.jsxs)(n.p,{children:["You'll see that the ",(0,i.jsx)(n.code,{children:"console.log()"})," only logs 0 and 1 before breaking out of the loop and returning ",(0,i.jsx)(n.code,{children:"1"}),", the index location of ",(0,i.jsx)(n.code,{children:'"hi"'}),". This is in contrast to how we'd have to solve this same problem with ",(0,i.jsx)(n.code,{children:"Array.prototype.forEach()"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'> function firstInstanceOfWord(word, text) {\n  const textArray = text.split(" ");\n  let position = -1;\n  textArray.forEach(function(element, index) {\n    console.log(index);\n    if ((word === element) && (position === -1)) {\n      position = index;\n    }\n  });\n  return position;\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"If we put this version of the function in the DevTools console, it will return the correct answer as well but the function will loop through every element in the array even though it finds what it's looking for in the second element."}),"\n",(0,i.jsxs)(n.p,{children:["Also, there are some slightly wonky things we have to do. ",(0,i.jsx)(n.code,{children:"let position = -1"})," is like a flag that's set to ",(0,i.jsx)(n.code,{children:"false"}),". You might wonder why both functions return ",(0,i.jsx)(n.code,{children:"-1"})," if they don't return a matching word. Why not just return ",(0,i.jsx)(n.code,{children:"false"}),"? Well, it's common for JavaScript methods to return ",(0,i.jsx)(n.code,{children:"-1"})," when there's not a match. We should be returning a number or a boolean, not a number sometimes and a boolean other times. This makes our function more consistent."]}),"\n",(0,i.jsxs)(n.p,{children:["Note our conditional, too: ",(0,i.jsx)(n.code,{children:"if ((word === element) && (position === -1))"}),". This is because we only want ",(0,i.jsx)(n.code,{children:"position"})," to be updated ",(0,i.jsx)(n.em,{children:"once"}),": the first time we find a match. When that happens, ",(0,i.jsx)(n.code,{children:"position"})," will no longer be ",(0,i.jsx)(n.code,{children:"-1"}),". If we didn't do this, the function would always return the ",(0,i.jsx)(n.em,{children:"last"})," match, not the first."]}),"\n",(0,i.jsxs)(n.p,{children:["So in addition to needing to continuing looping even after finding a match, there is some other code we have to add to solve this problem with ",(0,i.jsx)(n.code,{children:"Array.prototype.forEach()"}),". That is not ideal. A ",(0,i.jsx)(n.code,{children:"for"})," loop does a better job in this situation."]}),"\n",(0,i.jsx)(n.p,{children:"Of course, the function above doesn't account for case sensitivity, punctuation, and so on. You can add all of this functionality in your own application \u2014 and include tests as well."}),"\n",(0,i.jsxs)(n.h3,{id:"updating-isempty-to-use-built-in-js-arguments-object",children:["Updating ",(0,i.jsx)(n.code,{children:"isEmpty()"})," To Use Built-In JS ",(0,i.jsx)(n.code,{children:"arguments"})," Object"]}),"\n",(0,i.jsxs)(n.p,{children:["Now let's look at one other use case for a ",(0,i.jsx)(n.code,{children:"for"})," loop in our application. This is not something you are required to know for the independent project but it's a cool little thing we can use to expand the capacity of our ",(0,i.jsx)(n.code,{children:"isEmpty()"})," function."]}),"\n",(0,i.jsx)(n.p,{children:"Remember our little utility method?"}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"scripts.js"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// Utility Logic\n\nfunction isEmpty(testString) {\n  return (testString.trim().length === 0);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Well, currently it only checks one input. This means anytime we need to check two separate strings, we need to call ",(0,i.jsx)(n.code,{children:"isEmpty()"})," twice, like in the ",(0,i.jsx)(n.code,{children:"boldPassage()"})," function:"]}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"scripts.js"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function boldPassage(word, text) {\n  if (isEmpty(word) || isEmpty(text)) {\n    return null;\n  }\n  ...\n  return p;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["While this is a good and working solution, we can improve our ",(0,i.jsx)(n.code,{children:"isEmpty()"})," function by making it work with ",(0,i.jsx)(n.strong,{children:"any"})," number of arguments. We'll do this by using JavaScript's ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments",children:"arguments object"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Check this out:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"> function isEmpty() {\n  for (let i=0; i < arguments.length; i++) {\n    console.log(arguments[i]);\n    if (arguments[i].trim().length === 0) {\n      return true;\n    }\n  }\n  return false;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["So what exactly is happening here? This function has ",(0,i.jsx)(n.em,{children:"no"})," parameters. So where is ",(0,i.jsx)(n.code,{children:"arguments"})," coming from? Well, JavaScript makes an ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments",children:"arguments object"})," available inside functions that includes the values of ",(0,i.jsx)(n.em,{children:"all"})," arguments that are passed into the function. ",(0,i.jsxs)(n.strong,{children:["You are ",(0,i.jsx)(n.em,{children:"not"})," expected to ever use this on an independent project but it's a handy thing to know about."]})]}),"\n",(0,i.jsxs)(n.p,{children:["Also, it illustrates another great use for ",(0,i.jsx)(n.code,{children:"for"})," loops. That's because ",(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"arguments"}),' is an "array-like" object, just like the ',(0,i.jsx)(n.code,{children:"NodeList"})," and ",(0,i.jsx)(n.code,{children:"HTMLCollection"})," objects we learned about at the start of this section."]})," We can access each individual argument inside the ",(0,i.jsx)(n.code,{children:"arguments"})," object with bracket notation. However, it's not actually an array so we can't use ",(0,i.jsx)(n.code,{children:"Array.prototype.forEach()"})," to loop over the ",(0,i.jsx)(n.code,{children:"arguments"})," object, unless we convert it into an array."]}),"\n",(0,i.jsxs)(n.p,{children:["So in the ",(0,i.jsx)(n.code,{children:"isEmpty()"})," function, we use a ",(0,i.jsx)(n.code,{children:"for"})," loop. In each iteration through the loop, we check the value of ",(0,i.jsx)(n.code,{children:"arguments[i]"}),". In this way, we can check out ",(0,i.jsx)(n.code,{children:"arguments[0]"}),", ",(0,i.jsx)(n.code,{children:"arguments[1]"}),", and so on for as many arguments as we pass into ",(0,i.jsx)(n.code,{children:"isEmpty()"})," when we call it."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's try it out in the console. Copy the update ",(0,i.jsx)(n.code,{children:"isEmpty()"})," function into the console and then input the following:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'> isEmpty("hi", "bye", "", "bonjour!");\nhi\nbye\n\ntrue\n'})}),"\n",(0,i.jsxs)(n.p,{children:["As we can see from the return values, each argument is being logged, including the empty string, and then the function returns ",(0,i.jsx)(n.code,{children:"true"}),". It never logs ",(0,i.jsx)(n.code,{children:"bonjour"})," because the function detects an empty string as a parameter, which means not all of the parameters qualify as inputted words."]}),"\n",(0,i.jsxs)(n.p,{children:["With this update to ",(0,i.jsx)(n.code,{children:"isEmpty()"}),", we can use this utility function ",(0,i.jsx)(n.em,{children:"regardless of the number of arguments"})," passed into it. Our utility function just got more useful. Now we can update how we call ",(0,i.jsx)(n.code,{children:"isEmpty()"})," in our ",(0,i.jsx)(n.code,{children:"boldPassage()"})," function:"]}),"\n",(0,i.jsx)(n.div,{className:"filename",children:"scripts.js"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"\n// Utility Logic\n\nfunction isEmpty() {\n  for (let i=0; i < arguments.length; i++) {\n    if (arguments[i].trim().length === 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Business Logic\n\n...\n\n// UI Logic\n\nfunction boldPassage(word, text) {\n  if (isEmpty(word, text)) {\n    return null;\n  }\n  ...\n  return p;\n}\n\n...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["While ",(0,i.jsx)(n.code,{children:"Array.prototype.forEach()"})," will usually get the job done \u2014 and should generally be favored whenever we need to loop through each item in an array \u2014 there are plenty of use cases where ",(0,i.jsx)(n.code,{children:"for"})," loops are the right tool, including both of the use cases above in our text analyzer application."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);