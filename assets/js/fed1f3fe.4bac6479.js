"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[6267],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>c});var s=n(96540);const o={},i=s.createContext(o);function r(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:t},e.children)}},62402:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"c-and-net/basic-web-applications/3-2-1-4-to-do-list-with-mvc-forms","title":"\ud83d\udcd3 3.2.1.4 To Do List with MVC Forms","description":"In the last lesson, we successfully set up an ASP.NET Core MVC framework into a new To Do List application, and we added a basic home page. In this lesson, we\'ll update our application so users can create their own custom items through a form. In the next lesson, we\'ll explore what\'s happening in the HTTP request-response cycle when we use forms in our MVC applications.","source":"@site/docs/3_c-and-net/2_basic-web-applications/3-2-1-04-to-do-list-with-mvc-forms.md","sourceDirName":"3_c-and-net/2_basic-web-applications","slug":"/c-and-net/basic-web-applications/3-2-1-4-to-do-list-with-mvc-forms","permalink":"/v1.2/c-and-net/basic-web-applications/3-2-1-4-to-do-list-with-mvc-forms","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 3.2.1.4 To Do List with MVC Forms","day":"monday","id":"3-2-1-4-to-do-list-with-mvc-forms","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.2.1.3 To Do List MVC Setup","permalink":"/v1.2/c-and-net/basic-web-applications/3-2-1-3-to-do-list-mvc-setup"},"next":{"title":"\ud83d\udcd3 3.2.1.5 Request-Response Loop and HTTP Methods with ASP.NET Core MVC","permalink":"/v1.2/c-and-net/basic-web-applications/3-2-1-5-request-response-loop-and-http-methods-with-asp-net-core-mvc"}}');var o=n(74848),i=n(28453);const r={title:"\ud83d\udcd3 3.2.1.4 To Do List with MVC Forms",day:"monday",id:"3-2-1-4-to-do-list-with-mvc-forms",hide_table_of_contents:!0},c=void 0,l={},d=[{value:"Creating New <code>Item</code>s",id:"creating-new-items",level:2},{value:"New Item Form",id:"new-item-form",level:3},{value:"New Item Route",id:"new-item-route",level:3},{value:"Create New <code>Item</code> Route",id:"create-new-item-route",level:3}];function a(e){const t={code:"code",div:"div",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"In the last lesson, we successfully set up an ASP.NET Core MVC framework into a new To Do List application, and we added a basic home page. In this lesson, we'll update our application so users can create their own custom items through a form. In the next lesson, we'll explore what's happening in the HTTP request-response cycle when we use forms in our MVC applications."}),"\n",(0,o.jsxs)(t.h2,{id:"creating-new-items",children:["Creating New ",(0,o.jsx)(t.code,{children:"Item"}),"s"]}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsxs)(t.p,{children:["First, we'll offer users an option to create new list ",(0,o.jsx)(t.code,{children:"Item"}),"s. We'll add a link to the bottom of our existing ",(0,o.jsx)(t.code,{children:"Index.cshtml"})," homepage:"]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"ToDoList/Views/Home/Index.cshtml"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-html",children:'...\n<a href="/items/new">Add a new item.</a>\n'})}),"\n",(0,o.jsxs)(t.p,{children:["This link will navigate to a ",(0,o.jsx)(t.code,{children:"/items/new"})," route where users can create new ",(0,o.jsx)(t.code,{children:"Item"}),"s using a form."]}),"\n",(0,o.jsx)(t.h3,{id:"new-item-form",children:"New Item Form"}),"\n",(0,o.jsxs)(t.p,{children:["Next, we'll create a view for our form. Create a ",(0,o.jsx)(t.code,{children:"CreateForm.cshtml"})," file in the existing ",(0,o.jsx)(t.code,{children:"Views/Home"})," directory."]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"Views/Home/CreateForm.cshtml"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-html",children:'<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="utf-8">\n    <title>My To-Do List!</title>\n    <link \n      href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" \n      rel="stylesheet" \n      integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" \n      crossorigin="anonymous">\n  </head>\n  <body>\n    <form action="/items" method="post">\n      <label for="description">Add a new item</label>\n      <input id="description" name="description" type="text">\n      <button type="submit">Submit</button>\n    </form>\n  </body>\n</html>\n'})}),"\n",(0,o.jsx)(t.p,{children:"A few important things to note:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"<form>"})," tag includes an ",(0,o.jsx)(t.code,{children:"action='/items'"})," attribute. This means our form will route to ",(0,o.jsx)(t.code,{children:"'/items'"})," in our controller."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["The form also includes a ",(0,o.jsx)(t.code,{children:'method="post"'})," attribute. ",(0,o.jsx)(t.strong,{children:"When a form is being used to create a new object, it must have a post method"}),". This creates a special type of HTTP request called a ",(0,o.jsx)(t.strong,{children:"POST request"}),". We'll discuss this more in the next lesson."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["We also have a field of type ",(0,o.jsx)(t.code,{children:"text"})," so users can add a new ",(0,o.jsx)(t.code,{children:"Item"}),". Remember that ",(0,o.jsxs)(t.strong,{children:[(0,o.jsx)(t.code,{children:"name"})," is required"]})," and should accurately describe the input we're retrieving from users. Here we set it to ",(0,o.jsx)(t.code,{children:"description"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["Remember that the ",(0,o.jsx)(t.code,{children:"<button>"})," element's ",(0,o.jsx)(t.code,{children:"type"})," attribute must be set to ",(0,o.jsx)(t.code,{children:"'submit'"}),". If it isn't, the form won't trigger the correct route in the controller."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"new-item-route",children:"New Item Route"}),"\n",(0,o.jsx)(t.p,{children:"Next, let's create the corresponding route to render our new form:"}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"ToDoList/Controllers/HomeController.cs"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:'using Microsoft.AspNetCore.Mvc;\nusing ToDoList.Models;\n\nnamespace ToDoList.Controllers\n{\n  public class HomeController : Controller\n  {\n\n    [Route("/")]\n    public ActionResult Index()\n    {\n      Item starterItem = new Item("Add first item to To Do List");\n      return View(starterItem);\n    }\n\n    [Route("/items/new")]\n    public ActionResult CreateForm()\n    {\n      return View();\n    }\n\n  }\n}\n'})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["We create a new route at the path ",(0,o.jsx)(t.code,{children:"/items/new"}),". Users clicking on the link from ",(0,o.jsx)(t.code,{children:"Index.cshtml"})," will invoke this route."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["The route simply returns ",(0,o.jsx)(t.code,{children:"View()"}),". Because our form resides in a file called ",(0,o.jsx)(t.code,{children:"CreateForm.cshtml"}),", the ",(0,o.jsx)(t.code,{children:"CreateForm()"})," route method will automatically render this view."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.h3,{id:"create-new-item-route",children:["Create New ",(0,o.jsx)(t.code,{children:"Item"})," Route"]}),"\n",(0,o.jsxs)(t.p,{children:["Now we must tell our controller what to do when the user submits our form. Let's create a new ",(0,o.jsx)(t.code,{children:"Create()"}),"route method and use a route decorator to set its path to ",(0,o.jsx)(t.code,{children:"/items"}),":"]}),"\n",(0,o.jsx)(t.div,{className:"filename",children:"ToDoList/Controllers/HomeController.cs"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:'using Microsoft.AspNetCore.Mvc;\nusing ToDoList.Models;\n\nnamespace ToDoList.Controllers\n{\n  public class HomeController : Controller\n  {\n\n    [Route("/")]\n    public ActionResult Index()\n    {\n      Item starterItem = new Item("Add first item to To Do List");\n      return View(starterItem);\n    }\n\n    [Route("/items/new")]\n    public ActionResult CreateForm()\n    {\n      return View();\n    }\n\n    [Route("/items")]\n    public ActionResult Create(string description)\n    {\n      Item myItem = new Item(description);\n      return View("Index", myItem);\n    }\n\n  }\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["The route decorator ",(0,o.jsx)(t.code,{children:'"/items"'})," matches our form's action. When a form is submitted, this route will be invoked. The route method takes a single ",(0,o.jsx)(t.code,{children:"string"})," parameter named ",(0,o.jsx)(t.code,{children:"description"}),". This matches the ",(0,o.jsx)(t.code,{children:"name"})," attribute of our form's single field."]}),"\n",(0,o.jsxs)(t.p,{children:["Next, we create a new ",(0,o.jsx)(t.code,{children:"Item"})," with the ",(0,o.jsx)(t.code,{children:"description"})," from the form. And finally, we specify that the ",(0,o.jsx)(t.code,{children:"View()"})," method should take two arguments. This is a bit different from how we've used the ",(0,o.jsx)(t.code,{children:"View()"})," method before. The ",(0,o.jsx)(t.code,{children:"View()"})," method is using overloaded constructors under the hood, which means we can pass in varying numbers of arguments depending on the needs of our application."]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["The first argument specifies the view that should be returned. This is new functionality we haven't covered before. In this case, we tell the ",(0,o.jsx)(t.code,{children:"View()"})," method to return the ",(0,o.jsx)(t.code,{children:'"Index"'})," view. We have to do this because we are no longer routing to a view with the same exact name as our route method."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["The second argument specifies what the ",(0,o.jsx)(t.code,{children:"Model"})," property on the view should be."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["We don't need to add a ",(0,o.jsx)(t.code,{children:"Create.cshtml"})," view to correspond with our ",(0,o.jsx)(t.code,{children:"Create()"})," route because we are reusing ",(0,o.jsx)(t.code,{children:"Index.cshtml"}),". This helps keep our code DRY and allows us to be very specific when we build our routes. This route is only concerned with creating new items. There's no need to have another route as well."]}),"\n",(0,o.jsxs)(t.p,{children:["If we build and run our application, we can now add a custom ",(0,o.jsx)(t.code,{children:"Item"})," to our To Do List."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}}}]);