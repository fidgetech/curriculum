"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[28026],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var o=t(96540);const s={},i=o.createContext(s);function a(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(i.Provider,{value:n},e.children)}},56950:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"react/react-with-redux/4-3-2-3-action-constants","title":"\ud83d\udcd3 4.3.2.3 Action Constants","description":"In the last lesson, we learned how to use action creators to clean up our code. In this lesson, we\'ll make another small refactor to use action constants.","source":"@site/versioned_docs/version-v1_3/4_react/3_react-with-redux/4-3-2-03-action-constants.md","sourceDirName":"4_react/3_react-with-redux","slug":"/react/react-with-redux/4-3-2-3-action-constants","permalink":"/v1.3/react/react-with-redux/4-3-2-3-action-constants","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 4.3.2.3 Action Constants","day":"tuesday","id":"4-3-2-3-action-constants","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 4.3.2.2 Action Creators","permalink":"/v1.3/react/react-with-redux/4-3-2-2-action-creators"},"next":{"title":"\ud83d\udcd3 4.3.2.4 Hosting a React Project with GH-Pages","permalink":"/v1.3/react/react-with-redux/4-3-2-4-hosting-a-react-project-with-gh-pages"}}');var s=t(74848),i=t(28453);const a={title:"\ud83d\udcd3 4.3.2.3 Action Constants",day:"tuesday",id:"4-3-2-3-action-constants",hide_table_of_contents:!0},r=void 0,c={},l=[{value:"Organizing Constants in a React Application",id:"organizing-constants-in-a-react-application",level:3},{value:"Importing Constant Files",id:"importing-constant-files",level:3}];function d(e){const n={code:"code",div:"div",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"In the last lesson, we learned how to use action creators to clean up our code. In this lesson, we'll make another small refactor to use action constants."}),"\n",(0,s.jsxs)(n.p,{children:["So far, all of our action types have been strings. For instance, we have an action type of ",(0,s.jsx)(n.code,{children:"'TOGGLE_FORM'"})," that determines whether a form should be toggled in our application."]}),"\n",(0,s.jsx)(n.p,{children:"However, in larger applications (or even smaller ones), using strings for action types can make it harder to track bugs."}),"\n",(0,s.jsx)(n.p,{children:"Try copying the following code in the browser or running it in VS Code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const actionConditional = (condition) => {\n  if (condition === 'TOGGLE_FORM') {\n    return \"Form toggled!\"\n  } else {\n    return \"Nothing happened :(\"\n  }\n}\n\nactionConditional('TOGLE_FORM')\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Our function will work properly but it won't return the result we expect. That's because there's an error in our code. We've passed the string ",(0,s.jsx)(n.code,{children:"'TOGLE_FORM'"})," into our function instead of ",(0,s.jsx)(n.code,{children:"'TOGGLE_FORM'"}),". Because of this misspelling, our function will run correctly but the correct conditional will not be triggered."]}),"\n",(0,s.jsx)(n.p,{children:"We've all introduced typos in our code \u2014 and sometimes they can be difficult to spot, especially when they don't throw an error."}),"\n",(0,s.jsx)(n.p,{children:"Wouldn't it be nice if the typo above did throw an error?"}),"\n",(0,s.jsx)(n.p,{children:"Well, we can avoid these kinds of typos (or at least use JavaScript's error handling to avoid them) by saving our strings in constants."}),"\n",(0,s.jsx)(n.p,{children:"Now try the following code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const TOGGLE_FORM = \'TOGGLE_FORM\';\n\nconst actionConditional = (condition) => {\n  if (condition === TOGGLE_FORM) {\n    return "Form toggled!"\n  } else {\n    return "Nothing happened :("\n  }\n}\n\nactionConditional(TOGLE_FORM);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In the example above, we have the exact same typo. The difference, however, is that we've saved the ",(0,s.jsx)(n.code,{children:"'TOGGLE_FORM"})," string in a constant. Now, if we misspell the constant, we'll get the following error along with the line number where the error occurred:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"Uncaught ReferenceError: TOGLE_FORM is not defined\n"})}),"\n",(0,s.jsx)(n.p,{children:"This could save us a lot of trouble going forward. It's better for our code to fail and throw us a specific error than to have a silent bug that breaks everything for a seemingly inexplicable reason \u2014 at least until we hunt the error down."}),"\n",(0,s.jsx)(n.h3,{id:"organizing-constants-in-a-react-application",children:"Organizing Constants in a React Application"}),"\n",(0,s.jsx)(n.p,{children:"It's typical to save constants in a separate file, especially in a larger application that has many constants. We'll do the same in our application."}),"\n",(0,s.jsxs)(n.p,{children:["React and Redux aren't opinionated about where we store these constants. Since we'll only be using them in our action creators \u2014 and because these specific constants will define action types \u2014 we will store them in our ",(0,s.jsx)(n.code,{children:"actions"})," directory in a file called ",(0,s.jsx)(n.code,{children:"ActionTypes.js"}),". If we were to create other constants in our application that aren't related to action types, they wouldn't belong here."]}),"\n",(0,s.jsx)(n.div,{className:"filename",children:"src/actions/ActionTypes.js"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export const ADD_TICKET = 'ADD_TICKET';\nexport const DELETE_TICKET = 'DELETE_TICKET';\nexport const TOGGLE_FORM = 'TOGGLE_FORM';\n"})}),"\n",(0,s.jsx)(n.p,{children:"We will export these all individually. Going forward, any time you add an action type to your applications, make sure to use constants."}),"\n",(0,s.jsx)(n.h3,{id:"importing-constant-files",children:"Importing Constant Files"}),"\n",(0,s.jsx)(n.p,{children:"Finally, we need to update our tests, reducers and action creators to use our constants instead of strings for action types."}),"\n",(0,s.jsxs)(n.p,{children:["We'll demonstrate how this looks in one file \u2014 our ",(0,s.jsx)(n.code,{children:"form-visible-reducer.js"})," \u2014 because this file will have the fewest changes. The process will be exactly the same for all other files \u2014 and you can do a find and replace to ensure all action types have been updated correctly."]}),"\n",(0,s.jsx)(n.div,{className:"filename",children:"reducers/form-visible-reducer.js"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import * as c from './../actions/ActionTypes';\n\nconst reducer = (state = false, action) => {\n  switch (action.type) {\n  case c.TOGGLE_FORM:\n    return !state;\n  default:\n    return state;\n  }\n};\n\nexport default reducer;\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["First, we store our constants in the ",(0,s.jsx)(n.code,{children:"c"})," variable. We could call this anything but ",(0,s.jsx)(n.code,{children:"c"})," or ",(0,s.jsx)(n.code,{children:"constants"})," is standard convention. We are using ",(0,s.jsx)(n.code,{children:"c"})," for brevity."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Next, we need to update the action type itself. Our action type will now be written as ",(0,s.jsx)(n.code,{children:"c.TOGGLE_FORM"})," instead of ",(0,s.jsx)(n.code,{children:"'TOGGLE_FORM'"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"As expected, this will cause all tests related to toggling a form to fail."}),"\n",(0,s.jsx)(n.p,{children:"Go ahead and follow the steps above for all files that include the following:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reducers;"}),"\n",(0,s.jsx)(n.li,{children:"Tests for reducers;"}),"\n",(0,s.jsx)(n.li,{children:"Action creators;"}),"\n",(0,s.jsx)(n.li,{children:"Tests for action creators."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Note that the relative path to the ",(0,s.jsx)(n.code,{children:"constants"})," directory will vary depending on the file where you are adding an import statement. At this point, you should have a clear sense of how relative paths work and should be able to do this on your own."]}),"\n",(0,s.jsx)(n.p,{children:"Finally, run your tests and make sure they work, check that your project still compiles, and run the application and verify all functionality is working correctly."}),"\n",(0,s.jsx)(n.p,{children:'This is the kind of refactor that you might be asked to do as a junior developer. Often, new developers take on "code janitor" roles as they learn a codebase. This means cleaning up code that more experienced developers might not have the time to deal with. This kind of code cleanup is absolutely essential and can be a great way to learn a codebase and start making contributions to a team immediately.'}),"\n",(0,s.jsx)(n.p,{children:"In this lesson, we learned how to use constants for our action types. There are multiple benefits of this \u2014 the biggest benefit is making our application more robust and easier to debug. Using constants can also help us make our intentions clearer to other developers \u2014 and make our code easier to read."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);