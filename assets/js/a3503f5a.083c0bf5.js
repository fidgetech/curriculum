"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[76489],{4504:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"c-and-net/building-an-api/3-6-0-08-adding-parameters-to-a-get-request-to-support-query-strings","title":"\ud83d\udcd3 3.6.0.08 Adding Parameters to a Get Request to Support Query Strings","description":"In the last lesson, we completed CRUD functionality in our Cretaceous Park API. In this lesson, we\'ll learn how to add search parameters to our Get() controller action so that we can request and retrieve filtered data.","source":"@site/versioned_docs/version-v1_3/3_c-and-net/6_building-an-api/3-6-0-08-adding-parameters-to-a-get-request-to-support-query-strings.md","sourceDirName":"3_c-and-net/6_building-an-api","slug":"/c-and-net/building-an-api/3-6-0-08-adding-parameters-to-a-get-request-to-support-query-strings","permalink":"/v1.3/c-and-net/building-an-api/3-6-0-08-adding-parameters-to-a-get-request-to-support-query-strings","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 3.6.0.08 Adding Parameters to a Get Request to Support Query Strings","day":"weekend","id":"3-6-0-08-adding-parameters-to-a-get-request-to-support-query-strings","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.6.0.06 API: Update and Delete","permalink":"/v1.3/c-and-net/building-an-api/3-6-0-06-api-update-and-delete"},"next":{"title":"\ud83d\udcd3 3.6.0.09 Adding API Model Validation","permalink":"/v1.3/c-and-net/building-an-api/3-6-0-09-adding-api-model-validation"}}');var r=t(74848),s=t(28453);const i={title:"\ud83d\udcd3 3.6.0.08 Adding Parameters to a Get Request to Support Query Strings",day:"weekend",id:"3-6-0-08-adding-parameters-to-a-get-request-to-support-query-strings",hide_table_of_contents:!0},l=void 0,o={},c=[{value:"Query Strings",id:"query-strings",level:2},{value:"Handling Search Parameters",id:"handling-search-parameters",level:2},{value:"Test it Out!",id:"test-it-out",level:3},{value:"Handling Multiple Parameters",id:"handling-multiple-parameters",level:2},{value:"Non-string Parameters",id:"non-string-parameters",level:3},{value:"Test it Out!",id:"test-it-out-1",level:3},{value:"Repository Reference",id:"repository-reference",level:3}];function d(e){const n={a:"a",code:"code",div:"div",h2:"h2",h3:"h3",hr:"hr",i:"i",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["In the last lesson, we completed CRUD functionality in our Cretaceous Park API. In this lesson, we'll learn how to add search parameters to our ",(0,r.jsx)(n.code,{children:"Get()"})," controller action so that we can request and retrieve filtered data."]}),"\n",(0,r.jsx)(n.h2,{id:"query-strings",children:"Query Strings"}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["Right now, when a GET request is sent to ",(0,r.jsx)(n.code,{children:"http://localhost:5000/api/animals"}),", all animals in the database are returned in JSON format. Our ",(0,r.jsx)(n.code,{children:"Get"})," method currently looks like this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"// GET: api/Animals\n[HttpGet]\npublic async Task<ActionResult<IEnumerable<Animal>>> Get()\n{\n  return await _db.Animals.ToListAsync();\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"What if we wanted the animals endpoint of our API to have the ability to return results that are filtered by certain search criteria? For example, say a user wanted to get all animals that are dinosaurs? The API GET request in those cases would look something like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"http://localhost:5000/api/animals?species=dinosaur\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We've seen this syntax for API calls before. As a reminder, the ",(0,r.jsx)(n.code,{children:"?"})," here represents the beginning of a ",(0,r.jsx)(n.strong,{children:"query string"}),". What follows are key value pairs that represent the search parameter (like ",(0,r.jsx)(n.code,{children:"species"}),") and its value (like ",(0,r.jsx)(n.code,{children:"dinosaur"}),")."]}),"\n",(0,r.jsx)(n.h2,{id:"handling-search-parameters",children:"Handling Search Parameters"}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["Let's change the logic in our ",(0,r.jsx)(n.code,{children:"Get()"})," action to handle query strings so that we can return a filtered set of results based on species."]}),"\n",(0,r.jsxs)(n.p,{children:["Here's how we'll update our ",(0,r.jsx)(n.code,{children:"Get()"})," method in our controller:"]}),"\n",(0,r.jsx)(n.div,{className:"filename",children:"Controllers/AnimalsController.cs"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"...\n    // GET: api/Animals\n    [HttpGet]\n    public async Task<ActionResult<IEnumerable<Animal>>> Get(string species)\n    {\n      IQueryable<Animal> query = _db.Animals.AsQueryable();\n\n      if (species != null)\n      {\n        query = query.Where(entry => entry.Species == species);\n      }\n\n      return await query.ToListAsync();\n    }\n...\n"})}),"\n",(0,r.jsx)(n.p,{children:"Let's work through all of the changes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["We've added a parameter to the method of type ",(0,r.jsx)(n.code,{children:"string"})," that we've called ",(0,r.jsx)(n.code,{children:"species"}),". The naming here is important as .NET will automatically bind parameter values based on the query string. A call to ",(0,r.jsx)(n.code,{children:"http://localhost:5000/api/animals?species=dinosaur"})," will now trigger our ",(0,r.jsx)(n.code,{children:"Get()"}),' method and automatically bind the value "dinosaur" to the variable ',(0,r.jsx)(n.code,{children:"species"}),". The framework does this by utilizing ",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-6.0#binding-source-parameter-inference",children:"parameter source binding"}),", where it infers the source of the parameter's value. To be more explicit, we could optionally include the attribute ",(0,r.jsx)(n.code,{children:"[FromQuery]"})," to specify that the ",(0,r.jsx)(n.code,{children:"species"})," parameter comes from the query string in the request URL:"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public async Task<ActionResult<IEnumerable<Animal>>> Get([FromQuery] string species)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["In the body of the method we create a variable called ",(0,r.jsx)(n.code,{children:"query"})," and then collect the list of all animals from our database and return it as ",(0,r.jsxs)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.linq.iqueryable-1?view=net-6.0",children:["a ",(0,r.jsx)(n.code,{children:"IQueryable"})," LINQ object"]}),". When we use an ",(0,r.jsx)(n.code,{children:"IQueryable"})," object, we can use LINQ methods to build on to a database query before actually executing it. In this case, we're going to determine which query strings in our request, if any, we need to include in our database query."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The next thing we do is check to see if there is a value for the ",(0,r.jsx)(n.code,{children:"species"})," parameter, and if there is, we build on to our database query by calling the ",(0,r.jsx)(n.code,{children:"Where()"})," method."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"Where"})," method accepts ",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions",children:"a lambda expression"})," that will check whether each animal entry passes the condition and filters out those that do not meet the condition. In our case, we pass in ",(0,r.jsx)(n.code,{children:"entry => entry.Species == species"})," to specify that we only want a database entry if its species property value matches the query parameter value from our route."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Finally, we call ",(0,r.jsx)(n.code,{children:"ToListAsync()"})," on the final query to turn our new results into a list."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"test-it-out",children:"Test it Out!"}),"\n",(0,r.jsxs)(n.p,{children:["Let's test out our new species search functionality in Postman. Notice the query string ",(0,r.jsx)(n.code,{children:"?species=dinosaur"}),' in the request URL (highlighted by the red box). We can also see the query string listed as a key-value pair within the "Params" tab.']}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Result of API call with search parameter in Postman",src:t(46047).A+"",width:"698",height:"553"})}),"\n",(0,r.jsx)(n.h2,{id:"handling-multiple-parameters",children:"Handling Multiple Parameters"}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:"We can now retrieve entries from the database that match a given species, but what if we wanted to drill down further and find dinosaurs by their name? In order to do this, we can build on the query we created and add new parameters, like so:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"...\n    // GET api/animals\n    [HttpGet]\n    public async Task<ActionResult<IEnumerable<Animal>>> Get(string species, string name)\n    {\n      IQueryable<Animal> query = _db.Animals.AsQueryable();\n\n      if (species != null)\n      {\n        query = query.Where(entry => entry.Species == species);\n      }\n\n      if (name != null)\n      {\n        query = query.Where(entry => entry.Name == name);\n      }\n\n      return await query.ToListAsync();\n    }\n...\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now we are able to search for a dinosaur named Matilda and our API will successfully return that specific entry:"}),"\n",(0,r.jsxs)(n.p,{children:["Requesting ",(0,r.jsx)(n.code,{children:"http://localhost:5000/api/animals?species=dinosaur&name=matilda"})," will yield:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'[\n  {\n    "animalId": 3,\n    "name": "Matilda",\n    "species": "Dinosaur",\n    "age": 2\n  }\n]\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Notice that we chain new parameters to our query by using the ",(0,r.jsx)(n.code,{children:"&"})," symbol between each key-value pair."]}),"\n",(0,r.jsx)(n.p,{children:"We've successfully filtered the results with multiple parameters, but we can add as many parameters as we want with this pattern. Furthermore, this method allows for any combination of parameters to be used in the request."}),"\n",(0,r.jsx)(n.h3,{id:"non-string-parameters",children:"Non-string Parameters"}),"\n",(0,r.jsx)(n.p,{children:"We don't always have to filter content based on whether it matches the value in the search parameter directly. For example, if we wanted to get all dinosaurs that were older than 5 years old, it would be necessary for us to update this API endpoint to allow a request with a parameter that specifies a minimum age."}),"\n",(0,r.jsxs)(n.p,{children:["Because ",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-6.0#binding-source-parameter-inference",children:"parameter source binding inference"})," in our web API works for any primitive, we can then add another parameter of ",(0,r.jsx)(n.code,{children:"int"})," type called ",(0,r.jsx)(n.code,{children:"minimumAge"})," and handle the logic in a similar fashion:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"...\n    // GET api/animals\n    [HttpGet]\n    public async Task<List<Animal>> Get(string species, string name, int minimumAge)\n    {\n      IQueryable<Animal> query = _db.Animals.AsQueryable();\n\n      if (species != null)\n      {\n        query = query.Where(entry => entry.Species == species);\n      }\n\n      if (name != null)\n      {\n        query = query.Where(entry => entry.Name == name);\n      }\n\n      if (minimumAge > 0)\n      {\n        query = query.Where(entry => entry.Age >= minimumAge);\n      }\n\n      return await query.ToListAsync();\n    }\n...\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["The default value for an integer parameter will be ",(0,r.jsx)(n.code,{children:"0"})," when no value for the ",(0,r.jsx)(n.code,{children:"minimumAge"})," parameter is received."]})," Because of this we check ",(0,r.jsx)(n.code,{children:"minimumAge > 0"})," in our if statement to check whether there's been a value submitted for the ",(0,r.jsx)(n.code,{children:"minimumAge"})," parameter."]}),"\n",(0,r.jsxs)(n.p,{children:["Here's another example. If we simply wanted to create a query so that users can query animals by their age, an integer, we would check to see if a value for our age parameter has been added by checking if ",(0,r.jsx)(n.code,{children:"age != 0"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"if (age != 0)\n{\n  query = query.Where(entry => entry.Age == age);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"test-it-out-1",children:"Test it Out!"}),"\n",(0,r.jsxs)(n.p,{children:["Now if we request ",(0,r.jsx)(n.code,{children:"http://localhost:5000/api/animals?minimumAge=5"})," in postman we should get:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'[\n  {\n    "animalId": 1,\n    "name": "Matilda",\n    "species": "Woolly Mammoth",\n    "age": 7\n  },\n  {\n    "animalId": 2,\n    "name": "Rexie",\n    "species": "Dinosaur",\n    "age": 10\n  },\n  {\n    "animalId": 5,\n    "name": "Bartholomew",\n    "species": "Dinosaur",\n    "age": 22\n  }\n]\n'})}),"\n",(0,r.jsx)(n.h3,{id:"repository-reference",children:"Repository Reference"}),"\n",(0,r.jsx)(n.p,{children:"Follow the link below to view how a sample version of the project should look at this point. Note that this is a link to a specific branch in the repository."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:(0,r.jsxs)(n.a,{href:"https://github.com/epicodus-lessons/section-6-cretaceous-park-api-csharp-net6/tree/3_query_strings",children:[(0,r.jsx)(n.i,{className:"glyphicon glyphicon-folder-open"})," Example GitHub Repo for Cretaceous Park API: ",(0,r.jsx)(n.code,{children:"3_query_strings"})]})})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var a=t(96540);const r={},s=a.createContext(r);function i(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(s.Provider,{value:n},e.children)}},46047:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/0g_adding_parameters_to_get_request-946e3f24578a1cf8aac2e83fce1c2c1b.png"}}]);