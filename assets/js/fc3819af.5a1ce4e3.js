"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[67284],{362:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"introduction-to-programming/javascript-and-web-browsers/1-2-1-10-a-common-data-type-error-and-data-type-coercion","title":"\ud83d\udcd3 1.2.1.10 A Common Data Type Error and Data Type Coercion","description":"The most common error beginning JavaScript students experience is attempting to call methods or functions meant for numbers on strings. This happens especially frequently because all values returned from window.prompt() are saved as strings. Even if the user enters a number into a prompt without quotation marks! This may be confusing, but this is simply how JavaScript works.","source":"@site/docs/1_introduction-to-programming/2_javascript-and-web-browsers/1-2-1-10-a-common-data-type-error-and-data-type-coercion.md","sourceDirName":"1_introduction-to-programming/2_javascript-and-web-browsers","slug":"/introduction-to-programming/javascript-and-web-browsers/1-2-1-10-a-common-data-type-error-and-data-type-coercion","permalink":"/v1.2/introduction-to-programming/javascript-and-web-browsers/1-2-1-10-a-common-data-type-error-and-data-type-coercion","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 1.2.1.10 A Common Data Type Error and Data Type Coercion","day":"monday","id":"1-2-1-10-a-common-data-type-error-and-data-type-coercion","hide_table_of_contents":true},"sidebar":"introduction-to-programming","previous":{"title":"\ud83d\udcd3 1.2.1.9 Interactivity with Window Methods","permalink":"/v1.2/introduction-to-programming/javascript-and-web-browsers/1-2-1-9-interactivity-with-window-methods"},"next":{"title":"\u270f\ufe0f 1.2.1.11 Practice: Interactivity with Window Methods","permalink":"/v1.2/introduction-to-programming/javascript-and-web-browsers/1-2-1-11-practice-interactivity-with-window-methods"}}');var o=t(74848),a=t(28453);const s={title:"\ud83d\udcd3 1.2.1.10 A Common Data Type Error and Data Type Coercion",day:"monday",id:"1-2-1-10-a-common-data-type-error-and-data-type-coercion",hide_table_of_contents:!0},i=void 0,c={},d=[{value:"A Common Data Type Error",id:"a-common-data-type-error",level:2},{value:"Using parseInt() to Avoid Data Type Errors",id:"using-parseint-to-avoid-data-type-errors",level:2},{value:"Use <code>parseFloat()</code> for Decimals",id:"use-parsefloat-for-decimals",level:2},{value:"Data Type Coercion",id:"data-type-coercion",level:2},{value:"Examples of Data Type Coercion",id:"examples-of-data-type-coercion",level:3}];function l(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["The most common error beginning JavaScript students experience is attempting to call methods or functions meant for numbers on strings. This happens especially frequently because ",(0,o.jsxs)(n.strong,{children:["all values returned from ",(0,o.jsx)(n.code,{children:"window.prompt()"})," are saved as strings"]}),". Even if the user enters a number into a prompt without quotation marks! This may be confusing, but this is simply how JavaScript works."]}),"\n",(0,o.jsxs)(n.p,{children:["If we want to collect a value from a user with ",(0,o.jsx)(n.code,{children:"window.prompt()"}),", and perform arithmetic with this value, we will need to convert it into a number with JavaScript's ",(0,o.jsxs)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt",children:[(0,o.jsx)(n.code,{children:"parseInt()"})," function"]}),". If not, we will receive some very unexpected output."]}),"\n",(0,o.jsxs)(n.p,{children:["In this lesson, we'll review this common data type error, and then we'll learn about the ",(0,o.jsx)(n.strong,{children:"data type coercion"})," that JavaScript automatically performs in certain situations."]}),"\n",(0,o.jsx)(n.h2,{id:"a-common-data-type-error",children:"A Common Data Type Error"}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.p,{children:["Here's what can happen if you ",(0,o.jsx)(n.em,{children:"don't"})," parse integers (whole numbers) correctly. In the example below, we use ",(0,o.jsx)(n.code,{children:"window.prompt()"})," to ask the user how old they are. The user enters 35. We then attempt to perform some arithmetic on ",(0,o.jsx)(n.code,{children:"age"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'> const age = window.prompt("Enter your age: ");\n> age + age;\n"3535"\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Remember, ",(0,o.jsxs)(n.strong,{children:["all values returned from ",(0,o.jsx)(n.code,{children:"window.prompt()"})," are strings!"]})," So, even though the user entered a ",(0,o.jsx)(n.em,{children:"number"}),", ",(0,o.jsx)(n.code,{children:"age"})," is actually equal to the ",(0,o.jsx)(n.em,{children:"string"})," ",(0,o.jsx)(n.code,{children:'"35"'}),".  Since the ",(0,o.jsx)(n.code,{children:"+"})," operator can be used to concatenate strings  ",(0,o.jsx)(n.code,{children:"age + age"})," actually returns",(0,o.jsx)(n.code,{children:'"3535"'}),", instead of ",(0,o.jsx)(n.code,{children:"70"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"using-parseint-to-avoid-data-type-errors",children:"Using parseInt() to Avoid Data Type Errors"}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.p,{children:["To convert a string into a number, we parse it using the ",(0,o.jsx)(n.code,{children:"parseInt()"})," function like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'> const number = parseInt("5");\n> number;\n5\n'})}),"\n",(0,o.jsxs)(n.p,{children:["So, to change our ",(0,o.jsx)(n.code,{children:"age"})," from the example above into an integer, we do the following:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'> const inputtedAge = window.prompt("Enter your age: ");\n> const age = parseInt(inputtedAge);\n> age + age;\n70\n'})}),"\n",(0,o.jsx)(n.p,{children:"Alternatively, we can write our code on a single line:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'> const age = parseInt(window.prompt("Enter your age: "));\n> age + age;\n70\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Here we're immediately passing the string returned by the ",(0,o.jsx)(n.code,{children:"window.prompt()"})," method as the argument to the ",(0,o.jsx)(n.code,{children:"parseInt()"})," function."]}),"\n",(0,o.jsxs)(n.h2,{id:"use-parsefloat-for-decimals",children:["Use ",(0,o.jsx)(n.code,{children:"parseFloat()"})," for Decimals"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.em,{children:"Int"})," part of ",(0,o.jsx)(n.code,{children:"parseInt()"})," is short for integer, which means \"whole number\". If we wanted to convert a string into a number with a decimal, we'd use JavaScript's ",(0,o.jsx)(n.code,{children:"parseFloat()"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'> const pi = "3.14";\n> parseFloat(pi);\n3.14\n'})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Floating point"})," numbers are simply numbers with decimals. If you're parsing a whole number, use ",(0,o.jsx)(n.code,{children:"parseInt()"}),", if you're parsing a number containing a decimal point, use ",(0,o.jsx)(n.code,{children:"parseFloat()"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Visit the MDN documentation to learn more about ",(0,o.jsx)(n.code,{children:"parseFloat()"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsxs)(n.strong,{children:[(0,o.jsx)(n.span,{className:"glyphicon glyphicon-link"})," ",(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseFloat",children:(0,o.jsx)(n.code,{children:"parseFloat"})})]})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"data-type-coercion",children:"Data Type Coercion"}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.p,{children:"So far, we've discussed data type conversion with handy JS functions and methods:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"parseInt()"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"Number.prototype.toString()"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"Boolean.prototype.toString()"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"parseFloat()"})}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["When we use these methods we are ",(0,o.jsx)(n.strong,{children:"explicitly"})," converting the data type we have. This process is also called ",(0,o.jsx)(n.strong,{children:"typecasting"}),". At this point, we should be familiar with when and why we convert from one data type to another."]}),"\n",(0,o.jsxs)(n.p,{children:["However, JavaScript also performs ",(0,o.jsx)(n.strong,{children:"implicit"})," data type conversion. This is usually called ",(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Glossary/Type_coercion",children:(0,o.jsx)(n.strong,{children:"coercion"})}),", which is when JavaScript automatically decides on its own to force a piece of data to change into another type. Let's see what this looks like (try this in the DevTools console if you like):"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'> 54 + 3 + "45";\n"5745"\n'})}),"\n",(0,o.jsxs)(n.p,{children:["When JavaScript reads this code from left to right, it first performs the addition of ",(0,o.jsx)(n.code,{children:"54"})," + ",(0,o.jsx)(n.code,{children:"3"}),", and then it turns the result ",(0,o.jsx)(n.code,{children:"57"})," into a string that it then concatenates with ",(0,o.jsx)(n.code,{children:'"45"'}),", returning the string ",(0,o.jsx)(n.code,{children:'"5745"'}),". Yikes! That's unexpected!"]}),"\n",(0,o.jsx)(n.p,{children:'So why doesn\'t JavaScript return an error instead? Well, JavaScript is just not set up that way. Indeed, implicit data type coercion can lead to weird bugs and frustration. This is why some developers prefer "strongly typed" languages (like Typescript, a strongly typed version of JavaScript), where all variables need to be labeled with their data type, and any data type conversion only happens explicitly by the choice of the developer writing the code.'}),"\n",(0,o.jsx)(n.p,{children:"However, JavaScript's data type coercion can also be harnessed to write less code that's (arguably) more readable. We'll see more cases of this as we move through this section's material and get to branching. As a developer, your job is simply to be aware that JavaScript performs implicit data type coercion and of some of the cases in which it can pop up and cause issues."}),"\n",(0,o.jsx)(n.h3,{id:"examples-of-data-type-coercion",children:"Examples of Data Type Coercion"}),"\n",(0,o.jsx)(n.p,{children:"We see data type coercion come up when we use JavaScript arithmetic, comparison, and equality operators on incompatible data types:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"+"}),", ",(0,o.jsx)(n.code,{children:"-"}),", ",(0,o.jsx)(n.code,{children:"*"}),", ",(0,o.jsx)(n.code,{children:"/"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:">"}),", ",(0,o.jsx)(n.code,{children:"<"}),", ",(0,o.jsx)(n.code,{children:"=="})," (the loose equality operator, which we don't use)"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Let's see how this works with booleans:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'> true + true;\n2;\n> true + false;\n1;\n> false - false;\n0;\n> true * false;\n0\n> true * 6;\n6\n> true + " or false: do you like data type coercion?"; \n"true or false: do you like data type coercion?"\n> true * "false";\nNaN\n'})}),"\n",(0,o.jsxs)(n.p,{children:["With arithmetic operators applied to booleans, ",(0,o.jsx)(n.code,{children:"true"})," is converted to the number ",(0,o.jsx)(n.code,{children:"1"})," and ",(0,o.jsx)(n.code,{children:"false"})," is converted to the number ",(0,o.jsx)(n.code,{children:"0"}),". In that way, we can use any arithmetic operator between a boolean and a number, and JavaScript will implicitly convert the boolean into the number."]}),"\n",(0,o.jsxs)(n.p,{children:["When we use the addition ",(0,o.jsx)(n.code,{children:"+"})," operator between a boolean and a string, JavaScript implicitly converts the boolean into a string. If we use any other arithmetic operator between a boolean and a string, we'll get ",(0,o.jsx)(n.code,{children:"NaN"})," returned to us, which is ",(0,o.jsxs)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN#description",children:["one of the 5 different types of operations that return ",(0,o.jsx)(n.code,{children:"NaN"})]}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Let's see how numbers and strings interact:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'> "I am " + 54 + " years old.";\n"I am 54 years old."\n> 54 + " years old am I.";\n"54 years old am I."\n> 6 + 2 + 1 + 1 + "45";\n"1045"\n> "45" + 54 + 3;\n"45543"\n> "45" - 54 + 3;\n-6\n> "55" * 2;\n110\n> 10 / "2";\n5\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Because the addition ",(0,o.jsx)(n.code,{children:"+"})," operator is used for concatenation of strings, no matter how many numbers are added together, once JavaScript hits a string, it implicitly converts the resulting value or subsequent operations into a string. However, the operators ",(0,o.jsx)(n.code,{children:"-"}),", ",(0,o.jsx)(n.code,{children:"/"}),", and ",(0,o.jsx)(n.code,{children:"*"})," are never used with strings, so any string with a number in it is implicitly converted to a number."]}),"\n",(0,o.jsx)(n.p,{children:"We also see data type coercion come up when we mix up data types when working with (some) methods and properties. Let's see some examples:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"> window.alert(window.innerHeight);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"window.alert()"})," method takes a string as an argument, but we're passing in ",(0,o.jsx)(n.code,{children:"window.innerHeight"}),", which is a number! What do you think happens when we input the above code? Well, it works! This is a case where we can harness JavaScript's data type coercion to our benefit, because it allows us to write less code. It's debatable whether this code is easier to read than the longer form ",(0,o.jsx)(n.code,{children:"window.alert(window.innerHeight.toString());"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["We'll see more examples of when data type coercion can be helpful throughout this section and beyond. Remember, as a developer, your job is simply to be aware that JavaScript performs implicit data type coercion and of some of the cases in which it can pop up and cause issues. Don't feel like you need to remember all of the examples that we've covered in this lesson. If you are ever unsure about what data type you are working with, use the ",(0,o.jsx)(n.code,{children:"typeof"})," operator to check."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>i});var r=t(96540);const o={},a=r.createContext(o);function s(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);