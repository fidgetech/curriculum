"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[71016],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var i=n(96540);const o={},s=i.createContext(o);function a(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:t},e.children)}},66629:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>r});const i=JSON.parse('{"id":"react/react-fundamentals/4-2-1-6-updating-state-with-events","title":"\ud83d\udcd3 4.2.1.6 Updating State with Events","description":"In this lesson, we\'ll handle our first event in a React application. We\'ve handled many events before \u2014 every time we use functions to respond to a click or a submit button, we are handling an event. The process in React is very similar:","source":"@site/versioned_docs/version-v1_3/4_react/2_react-fundamentals/4-2-1-06-updating-state-with-events.md","sourceDirName":"4_react/2_react-fundamentals","slug":"/react/react-fundamentals/4-2-1-6-updating-state-with-events","permalink":"/v1.3/react/react-fundamentals/4-2-1-6-updating-state-with-events","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 4.2.1.6 Updating State with Events","day":"monday","id":"4-2-1-6-updating-state-with-events","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\ud83d\udcd3 4.2.1.5 Conditional Rendering","permalink":"/v1.3/react/react-fundamentals/4-2-1-5-conditional-rendering"},"next":{"title":"\ud83d\udcd3 4.2.2.1 UUID Library","permalink":"/v1.3/react/react-fundamentals/4-2-2-1-uuid-library"}}');var o=n(74848),s=n(28453);const a={title:"\ud83d\udcd3 4.2.1.6 Updating State with Events",day:"monday",id:"4-2-1-6-updating-state-with-events",hide_table_of_contents:!0},c=void 0,l={},r=[{value:"Adding a Click Handler to JSX",id:"adding-a-click-handler-to-jsx",level:2},{value:"Writing the Event Handler Function",id:"writing-the-event-handler-function",level:2},{value:"Toggling a Boolean",id:"toggling-a-boolean",level:2},{value:"Updating the Button for Both Views",id:"updating-the-button-for-both-views",level:3},{value:"A Note on Function Definitions",id:"a-note-on-function-definitions",level:2},{value:"What&#39;s Next?",id:"whats-next",level:2}];function d(e){const t={admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"In this lesson, we'll handle our first event in a React application. We've handled many events before \u2014 every time we use functions to respond to a click or a submit button, we are handling an event. The process in React is very similar:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"First, we add a click handler to an element (such as a button)."}),"\n",(0,o.jsx)(t.li,{children:"Next, that click handler will trigger a function. We need to write that function as well."}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"adding-a-click-handler-to-jsx",children:"Adding a Click Handler to JSX"}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsx)(t.p,{children:"Here's how our click handler will look:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:"<button onClick={handleClick}>Add ticket</button>\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Here, we take a ",(0,o.jsx)(t.code,{children:"button"})," element and add an ",(0,o.jsx)(t.code,{children:"onClick"})," handler to it. We need to specify the function ",(0,o.jsx)(t.code,{children:"onClick"})," will trigger. As always, we need to use curly braces to make sure that JSX properly evaluates any JS code."]}),"\n",(0,o.jsx)(t.p,{children:"Note that there are a few syntactical differences between how we do this in React as opposed to how we'd accomplish the same thing with vanilla JavaScript:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Instead of ",(0,o.jsx)(t.code,{children:"onclick"}),", we use ",(0,o.jsx)(t.code,{children:"onClick"})," (camelCase is important in React)."]}),"\n",(0,o.jsxs)(t.li,{children:["In plain old JavaScript, we'd wrap the function being called in a string, like ",(0,o.jsx)(t.code,{children:'<button onclick="doSomething()">'}),". In JSX, we use curly braces."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Other than these syntactical differences, attaching click handlers in React is very similar to how we might attach a click handler in a vanilla JavaScript application."}),"\n",(0,o.jsx)(t.p,{children:"Now let's actually add our event handler to our component:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",metastring:'title="src/components/TicketControl.js"',children:"import React, { useState } from 'react';\nimport NewTicketForm from './NewTicketForm';\nimport TicketList from './TicketList';\n\nfunction TicketControl() {\n  const [formVisibleOnPage, setFormVisibleOnPage] = useState(false);\n\n  let currentlyVisibleState = null;\n  let buttonText = null; // new code\n\n  if (formVisibleOnPage) {\n    currentlyVisibleState = <NewTicketForm />;\n  } else {\n    currentlyVisibleState = <TicketList />;\n    buttonText = \"Add Ticket\"; // new code\n  }\n\n  return (\n    <React.Fragment>\n      {currentlyVisibleState}\n      <button onClick={handleClick}>{buttonText}</button> { /* new code */ }\n    </React.Fragment>\n  );\n}\n\nexport default TicketControl;\n"})}),"\n",(0,o.jsxs)(t.p,{children:["We've added a button to our ",(0,o.jsx)(t.code,{children:"TicketControl"})," component. Notice that we haven't defined the ",(0,o.jsx)(t.code,{children:"handleClick"})," function yet \u2014 we'll do that in the next section."]}),"\n",(0,o.jsx)(t.admonition,{type:"tip",children:(0,o.jsx)(t.p,{children:"There are two different kinds of comments above \u2014 this is expected. Comments in JSX syntax need to be wrapped in curly braces, unlike the other comments, which are standard JS comments."})}),"\n",(0,o.jsx)(t.p,{children:"We've added a few things:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["We create a new variable called ",(0,o.jsx)(t.code,{children:"buttonText"})," and set its value to ",(0,o.jsx)(t.code,{children:"null"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["If ",(0,o.jsx)(t.code,{children:"formVisibleOnPage"})," is ",(0,o.jsx)(t.code,{children:"false"}),", we set the value of ",(0,o.jsx)(t.code,{children:"buttonText"})," to ",(0,o.jsx)(t.code,{children:'"Add Ticket"'}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["In the return statement, we render the button with the text stored in ",(0,o.jsx)(t.code,{children:"buttonText"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["You may wonder why we have this button here instead of in the ",(0,o.jsx)(t.code,{children:"TicketList"})," component. Well, this button has nothing to do with displaying tickets \u2014 it's about controlling which view is shown! It belongs in ",(0,o.jsx)(t.code,{children:"TicketControl"})," because it directly affects this component's state."]}),"\n",(0,o.jsx)(t.h2,{id:"writing-the-event-handler-function",children:"Writing the Event Handler Function"}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsx)(t.p,{children:"Next, we need to write the function that will be called when the button is clicked. In a function component, we simply define a function inside our component:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",metastring:'title="src/components/TicketControl.js"',children:"import React, { useState } from 'react';\nimport NewTicketForm from './NewTicketForm';\nimport TicketList from './TicketList';\n\nfunction TicketControl() {\n  const [formVisibleOnPage, setFormVisibleOnPage] = useState(false);\n\n  // new code\n  const handleClick = () => {\n    setFormVisibleOnPage(true);\n  }\n\n  let currentlyVisibleState = null;\n  let buttonText = null;\n\n  if (formVisibleOnPage) {\n    currentlyVisibleState = <NewTicketForm />;\n  } else {\n    currentlyVisibleState = <TicketList />;\n    buttonText = \"Add Ticket\";\n  }\n\n  return (\n    <React.Fragment>\n      {currentlyVisibleState}\n      <button onClick={handleClick}>{buttonText}</button>\n    </React.Fragment>\n  );\n}\n\nexport default TicketControl;\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Our ",(0,o.jsx)(t.code,{children:"handleClick"})," function is simple \u2014 it just calls ",(0,o.jsx)(t.code,{children:"setFormVisibleOnPage(true)"})," to update our state."]}),"\n",(0,o.jsx)(t.p,{children:'Now if we run our application, we can successfully click on "Add Ticket" and our form will show!'}),"\n",(0,o.jsx)(t.h2,{id:"toggling-a-boolean",children:"Toggling a Boolean"}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsx)(t.p,{children:"When we add a working form to our application, our submit button will return users to the list of tickets. However, what if a user changes their mind and wants to return to the queue without submitting a ticket? Let's update our button so that it can toggle between the two views."}),"\n",(0,o.jsxs)(t.p,{children:["First, let's update our ",(0,o.jsx)(t.code,{children:"handleClick"})," function to toggle the boolean instead of just setting it to ",(0,o.jsx)(t.code,{children:"true"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",metastring:'title="src/components/TicketControl.js"',children:"const handleClick = () => {\n  setFormVisibleOnPage(!formVisibleOnPage);\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:['This line says: "set ',(0,o.jsx)(t.code,{children:"formVisibleOnPage"})," to the opposite of its current value.\" If it's ",(0,o.jsx)(t.code,{children:"true"}),", it becomes ",(0,o.jsx)(t.code,{children:"false"}),". If it's ",(0,o.jsx)(t.code,{children:"false"}),", it becomes ",(0,o.jsx)(t.code,{children:"true"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"For most cases, this approach works perfectly. However, if you're dealing with rapid state updates or updates inside effects, you might want to use the functional form of the state updater:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"const handleClick = () => {\n  setFormVisibleOnPage(prevState => !prevState);\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"This version receives the previous state as an argument and returns the new state. It's more explicit about the fact that the new state depends on the previous state."}),"\n",(0,o.jsx)(t.h3,{id:"updating-the-button-for-both-views",children:"Updating the Button for Both Views"}),"\n",(0,o.jsxs)(t.p,{children:["Now that we've updated our ",(0,o.jsx)(t.code,{children:"handleClick"})," function to toggle, we need to update our conditional logic so that the button text changes depending on which view is currently visible:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",metastring:'title="src/components/TicketControl.js"',children:"import React, { useState } from 'react';\nimport NewTicketForm from './NewTicketForm';\nimport TicketList from './TicketList';\n\nfunction TicketControl() {\n  const [formVisibleOnPage, setFormVisibleOnPage] = useState(false);\n\n  const handleClick = () => {\n    setFormVisibleOnPage(!formVisibleOnPage);\n  }\n\n  let currentlyVisibleState = null;\n  let buttonText = null;\n\n  if (formVisibleOnPage) {\n    currentlyVisibleState = <NewTicketForm />;\n    buttonText = \"Return to Ticket List\";\n  } else {\n    currentlyVisibleState = <TicketList />;\n    buttonText = \"Add Ticket\";\n  }\n\n  return (\n    <React.Fragment>\n      {currentlyVisibleState}\n      <button onClick={handleClick}>{buttonText}</button>\n    </React.Fragment>\n  );\n}\n\nexport default TicketControl;\n"})}),"\n",(0,o.jsx)(t.p,{children:'Now the button shows "Return to Ticket List" or "Add Ticket" depending on the view. It\'s the same button with the same click handler \u2014 we just change the text to make it clear what clicking the button will do.'}),"\n",(0,o.jsx)(t.p,{children:"At this point, we've successfully added local state and we can use a button to toggle back and forth between two components. Make sure to take the time to practice working with local state and event handlers."}),"\n",(0,o.jsx)(t.h2,{id:"a-note-on-function-definitions",children:"A Note on Function Definitions"}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsxs)(t.p,{children:["You might wonder why we define ",(0,o.jsx)(t.code,{children:"handleClick"})," as an arrow function:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"const handleClick = () => {\n  setFormVisibleOnPage(!formVisibleOnPage);\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"In function components, you can also use regular function declarations:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"function handleClick() {\n  setFormVisibleOnPage(!formVisibleOnPage);\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Both work fine in function components! The arrow function syntax is common because it's concise, and some developers prefer the consistency of always using ",(0,o.jsx)(t.code,{children:"const"})," for function definitions. Use whichever style you prefer."]}),"\n",(0,o.jsx)(t.hr,{}),"\n",(0,o.jsx)(t.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,o.jsx)(t.p,{children:"Now that we can toggle between views using local state, we're ready to build a real form that adds tickets to the queue. But first, we'll need a way to give each ticket a unique ID \u2014 which brings us to the UUID library."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);