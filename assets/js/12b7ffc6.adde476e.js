"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[60276],{19425:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/state-diagram-70a9726d3292a8da19257341b1749cf4.jpg"},28453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>r});var n=a(96540);const s={},o=n.createContext(s);function i(e){const t=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),n.createElement(o.Provider,{value:t},e.children)}},85936:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"react/react-fundamentals/4-2-1-2-introduction-to-state","title":"\ud83d\udcd3 4.2.1.2 Introduction to State","description":"In this lesson, we\'ll briefly cover the concept of state. We\'ll discuss shared state versus local state. We\'ll also briefly cover how we define and change state in a pure React application. Then, over the next several lessons, we\'ll add state to our Help Queue application so we can dynamically add new tickets.","source":"@site/docs/4_react/2_react-fundamentals/4-2-1-02-introduction-to-state.md","sourceDirName":"4_react/2_react-fundamentals","slug":"/react/react-fundamentals/4-2-1-2-introduction-to-state","permalink":"/v1.2/react/react-fundamentals/4-2-1-2-introduction-to-state","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 4.2.1.2 Introduction to State","day":"monday","id":"4-2-1-2-introduction-to-state","hide_table_of_contents":true},"sidebar":"react","previous":{"title":"\u270f\ufe0f 4.2.1.1 Help Queue, Social Media, Airbnb Clone","permalink":"/v1.2/react/react-fundamentals/4-2-1-1-help-queue-social-media-airbnb-clone"},"next":{"title":"\ud83d\udcd3 4.2.1.3 Planning Our Application: Part 2","permalink":"/v1.2/react/react-fundamentals/4-2-1-3-planning-our-application-part-2"}}');var s=a(74848),o=a(28453);const i={title:"\ud83d\udcd3 4.2.1.2 Introduction to State",day:"monday",id:"4-2-1-2-introduction-to-state",hide_table_of_contents:!0},r=void 0,c={},l=[{value:"Shared State Versus Local State",id:"shared-state-versus-local-state",level:2},{value:"Local State",id:"local-state",level:3},{value:"Shared State",id:"shared-state",level:3},{value:"Creating and Updating State in a React Application",id:"creating-and-updating-state-in-a-react-application",level:3}];function d(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",img:"img",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"In this lesson, we'll briefly cover the concept of state. We'll discuss shared state versus local state. We'll also briefly cover how we define and change state in a pure React application. Then, over the next several lessons, we'll add state to our Help Queue application so we can dynamically add new tickets."}),"\n",(0,s.jsx)(t.p,{children:"We can use two types of data in a React component: props and state. We've already used props in a React application and we also covered state in the last course section in our introduction to functional programming."}),"\n",(0,s.jsx)(t.p,{children:"As a quick reminder, state is anything in an application that we need to store and change. For instance, in our Help Queue, each time we add a new ticket, we need to update the application's state to hold the new ticket. Likewise, we'd need to update the application's state to edit or delete a ticket."}),"\n",(0,s.jsxs)(t.p,{children:["State is something that can potentially change. In contrast, a component ",(0,s.jsx)(t.em,{children:"cannot"})," change its props. State is fluid and ever-changing while props are not."]}),"\n",(0,s.jsxs)(t.p,{children:["The components we've built so far have all been functional. They cannot handle state. However, as we discussed in our introduction to components, we can use class-based components to handle state. As a rule, we should ",(0,s.jsxs)(t.strong,{children:["only define a component as a class if it ",(0,s.jsx)(t.em,{children:"absolutely requires"})," state."]})," If a component does not require state, it should be a stateless function component. Avoiding unnecessary use of state is an important rule in React. (Note: There's actually more to this rule but we won't go into great detail here. If you're feeling particularly brave, check out ",(0,s.jsx)(t.a,{href:"https://overreacted.io/how-are-function-components-different-from-classes/",children:"this article"})," to learn more about the nuances of why React favors function components.)"]}),"\n",(0,s.jsx)(t.h2,{id:"shared-state-versus-local-state",children:"Shared State Versus Local State"}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsxs)(t.p,{children:["There can be two different types of state in a React application \u2014 ",(0,s.jsx)(t.strong,{children:"shared state"})," and ",(0,s.jsx)(t.strong,{children:"local state"}),". We will be experimenting with both as we add state to our Help Queue application."]}),"\n",(0,s.jsx)(t.h3,{id:"local-state",children:"Local State"}),"\n",(0,s.jsx)(t.p,{children:"Local state lives in a single component and is never used in other components. It is much simpler than shared state because we don't have to worry about sharing data in multiple components. An example of local state is hiding and showing information. We will use local state in our Help Queue project to determine whether a user should see a list of tickets or a form for adding a ticket."}),"\n",(0,s.jsx)(t.p,{children:"It's obvious where local state should live \u2014 in the component that needs it!"}),"\n",(0,s.jsx)(t.h3,{id:"shared-state",children:"Shared State"}),"\n",(0,s.jsx)(t.p,{children:"Shared state is shared by multiple components and can get complicated very quickly. An example of shared state is the main list of all tickets in the Help Queue. Our ticket list component will need access to all the tickets so it can render them. However, our form will also need to be able to pass information about new tickets to the main list of tickets as well."}),"\n",(0,s.jsx)(t.p,{children:"Our application will keep shared state fairly simple \u2014 only two components will need to access this main ticket list."}),"\n",(0,s.jsxs)(t.p,{children:["There are many challenges to working with shared state. For example, where should it live? In order for components to have access to the same state, that shared state should be lifted to ",(0,s.jsx)(t.strong,{children:"the lowest common ancestor for all the components that need that state"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"We'll demonstrate what this means with the following diagram."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"The following diagram demonstrates how to lift state between multiple components",src:a(19425).A+"",width:"491",height:"491"})}),"\n",(0,s.jsx)(t.p,{children:"In this diagram, there are six different components. Let's say that component D and component E need access to shared state. The lowest common ancestor for those components is component B. In this case, we'd only need to lift this shared state to component B."}),"\n",(0,s.jsx)(t.p,{children:"However, let's say that component F also needs access to the same state. That means component B is no longer a common ancestor. At this point, component A is the lowest common ancestor that components D, E, and F share. Now our shared state needs to be lifted all the way to component A."}),"\n",(0,s.jsx)(t.p,{children:"This will become clearer as we refactor our Help Queue application to use both local and shared state."}),"\n",(0,s.jsx)(t.p,{children:"You may be wondering what to do if our application has complex state and many different components have many different kinds of shared state. At that point, it's typical to use a library like Redux that is specifically designed to handle complex state. We will cover Redux in the next course section. For the time being, we will focus on learning the ins and outs of adding state to a basic React application without any external libraries."}),"\n",(0,s.jsx)(t.h3,{id:"creating-and-updating-state-in-a-react-application",children:"Creating and Updating State in a React Application"}),"\n",(0,s.jsxs)(t.p,{children:["As we discussed in the ",(0,s.jsx)(t.a,{href:"../../react/react-fundamentals/4-2-0-5-react-components",children:"React Components"})," lesson, class components have a constructor that looks like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"constructor(props) {\n  super(props);\n  this.state = {};\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We can define any default state a component should have in the constructor. ",(0,s.jsx)(t.strong,{children:"It is the only place we should define default state in a pure React application."})," (An application with Redux or another state management library will have other ways of defining state.)"]}),"\n",(0,s.jsxs)(t.p,{children:["We can add any number of key-value pairs to ",(0,s.jsx)(t.code,{children:"this.state = {}"})," to define the default state."]}),"\n",(0,s.jsx)(t.p,{children:"If we want to update state, we will use the following React method:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"this.setState({property: update})\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In the example above, ",(0,s.jsx)(t.code,{children:"property"})," represents the property that needs to be updated while ",(0,s.jsx)(t.code,{children:"update"})," represents the new value a property should have. This is the simplest way to use ",(0,s.jsx)(t.code,{children:"setState()"}),", though we can also do other things beyond just passing in objects."]}),"\n",(0,s.jsxs)(t.p,{children:["Whenever we want to change state in React, we need to use the ",(0,s.jsx)(t.code,{children:"setState()"})," method. It is a very bad practice to bypass React and try to change state in other ways. The whole point of ",(0,s.jsx)(t.code,{children:"setState()"})," is to allow React to do its job \u2014 which is to be a state management system that efficiently creates a virtual DOM and reconciles it with the actual DOM. So it should go without saying that we should ",(0,s.jsx)(t.strong,{children:"never"})," do something like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"this.state = {property: update}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The main issue with manipulating state directly like this is that it will ",(0,s.jsx)(t.em,{children:"not"})," cause the component to re-render as setState() would. If the component doesn't re-render, our changes to state won't create any change in the DOM. ",(0,s.jsxs)(t.strong,{children:["Always use the ",(0,s.jsx)(t.code,{children:"setState()"})," method to update state in a pure React application."]})]}),"\n",(0,s.jsxs)(t.p,{children:["There's one more very important thing we need to know about the ",(0,s.jsx)(t.code,{children:"setState()"})," method. ",(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(t.code,{children:"setState()"})," is an async method."]})," This makes sense \u2014 async methods can be challenging to work with but they allow JavaScript applications to be more efficient. Because ",(0,s.jsx)(t.code,{children:"setState()"})," is async, there are a lot of potential gotchas. For instance, if you try to ",(0,s.jsx)(t.code,{children:"console.log"})," the value of a component's state directly after calling the ",(0,s.jsx)(t.code,{children:"setState()"})," method, you can't expect it to give you reliable results. There is a way to accurately log the current state of a component, but we will cover that in a future lesson."]}),"\n",(0,s.jsx)(t.p,{children:"In this lesson, we've covered the differences between shared and local state. We also briefly covered how to define and update state in a React application. However, these concepts are probably still fuzzy because we haven't actually applied them yet. Don't worry \u2014 we are about to apply them. We recommend referring back to this lesson if you still have confusion about these concepts after we add local and shared state to our Help Queue application."})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);