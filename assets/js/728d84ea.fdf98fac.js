"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[46570],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var i=t(96540);const a={},o=i.createContext(a);function s(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:n},e.children)}},83693:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"c-and-net/many-to-many-relationships/3-4-0-4-many-to-many-relationships-join-entities","title":"\ud83d\udcd3 3.4.0.4 Many-to-Many Relationships: Join Entities","description":"In this lesson, we\'ll see how we can establish a many-to-many relationship in our database and how we can use C# objects to model this relationship. Instead of changing our one-to-many relationship between Category and Item, we\'ll add a new model called Tag and implement a many-to-many relationship between Item and Tag.","source":"@site/versioned_docs/version-v1_3/3_c-and-net/4_many-to-many-relationships/3-4-0-04-many-to-many-relationships-join-entities.md","sourceDirName":"3_c-and-net/4_many-to-many-relationships","slug":"/c-and-net/many-to-many-relationships/3-4-0-4-many-to-many-relationships-join-entities","permalink":"/v1.3/c-and-net/many-to-many-relationships/3-4-0-4-many-to-many-relationships-join-entities","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 3.4.0.4 Many-to-Many Relationships: Join Entities","day":"weekend","id":"3-4-0-4-many-to-many-relationships-join-entities","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.4.0.3 Code First Development and Migrations","permalink":"/v1.3/c-and-net/many-to-many-relationships/3-4-0-3-code-first-development-and-migrations"},"next":{"title":"\ud83d\udcd3 3.4.0.5 Many-to-Many Read Functionality","permalink":"/v1.3/c-and-net/many-to-many-relationships/3-4-0-5-many-to-many-read-functionality"}}');var a=t(74848),o=t(28453);const s={title:"\ud83d\udcd3 3.4.0.4 Many-to-Many Relationships: Join Entities",day:"weekend",id:"3-4-0-4-many-to-many-relationships-join-entities",hide_table_of_contents:!0},l=void 0,r={},c=[{value:"Updating To Do List Models for Many-to-Many",id:"updating-to-do-list-models-for-many-to-many",level:2},{value:"Creating the <code>Tag</code> Model",id:"creating-the-tag-model",level:3},{value:"Creating the JOIN Entity",id:"creating-the-join-entity",level:3},{value:"Adding Navigation Properties for the Many-To-Many Relationship",id:"adding-navigation-properties-for-the-many-to-many-relationship",level:3},{value:"Repository Reference",id:"repository-reference",level:3}];function d(e){const n={a:"a",code:"code",div:"div",h2:"h2",h3:"h3",hr:"hr",i:"i",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["In this lesson, we'll see how we can establish a many-to-many relationship in our database and how we can use C# objects to model this relationship. Instead of changing our one-to-many relationship between ",(0,a.jsx)(n.code,{children:"Category"})," and ",(0,a.jsx)(n.code,{children:"Item"}),", we'll add a new model called ",(0,a.jsx)(n.code,{children:"Tag"})," and implement a many-to-many relationship between ",(0,a.jsx)(n.code,{children:"Item"})," and ",(0,a.jsx)(n.code,{children:"Tag"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"With this new many-to-many relationship, we'll be able to add tags to each item in our To Do List. A tag could be anything that we want to use to further describe the items we add to our To Do List: 'urgent', '?' (to indicate that follow up is necessary), 'low priority', 'due tomorrow', etc. As a many-to-many relationship, one item can have many tags, and each tag can be added to many items."}),"\n",(0,a.jsx)(n.h2,{id:"updating-to-do-list-models-for-many-to-many",children:"Updating To Do List Models for Many-to-Many"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:"In the last lesson, we configured our project to use EF Core migrations:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["We updated the name of our database to ",(0,a.jsx)(n.code,{children:"to_do_list_with_many_to_many"})," in ",(0,a.jsx)(n.code,{children:"appsettings.json"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["We installed ",(0,a.jsx)(n.code,{children:"dotnet-ef"})," globally."]}),"\n",(0,a.jsxs)(n.li,{children:["We installed ",(0,a.jsx)(n.code,{children:"Microsoft.EntityFrameworkCore.Design"})," within our To Do List app."]}),"\n",(0,a.jsxs)(n.li,{children:["We created our first migration with ",(0,a.jsx)(n.code,{children:"dotnet ef database add Initial"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["We created our ",(0,a.jsx)(n.code,{children:"to_do_list_with_many_to_many"})," database by running ",(0,a.jsx)(n.code,{children:"dotnet ef database update"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Next, we'll focus on creating and updating the models in the ",(0,a.jsx)(n.code,{children:"ToDoList/Models"})," directory."]}),"\n",(0,a.jsxs)(n.h3,{id:"creating-the-tag-model",children:["Creating the ",(0,a.jsx)(n.code,{children:"Tag"})," Model"]}),"\n",(0,a.jsxs)(n.p,{children:["The first thing we'll do is create a new ",(0,a.jsx)(n.code,{children:"Tag"})," class within a new ",(0,a.jsx)(n.code,{children:"Tag.cs"})," file:"]}),"\n",(0,a.jsx)(n.div,{className:"filename",children:"Models/Tag.cs"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"namespace ToDoList.Models\n{\n  public class Tag\n    {\n        public int TagId { get; set; }\n        public string Title { get; set; }\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Then, we'll update our ",(0,a.jsx)(n.code,{children:"ToDoListContext.cs"})," to include a new ",(0,a.jsx)(n.code,{children:"DbSet"})," to represent the ",(0,a.jsx)(n.code,{children:"Tag"})," table in our database:"]}),"\n",(0,a.jsx)(n.div,{className:"filename",children:"Models/ToDoListContext.cs"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"using Microsoft.EntityFrameworkCore;\n\nnamespace ToDoList.Models\n{\n  public class ToDoListContext : DbContext\n  {\n    public DbSet<Category> Categories { get; set; }\n    public DbSet<Item> Items { get; set; }\n    public DbSet<Tag> Tags { get; set; }\n\n    public ToDoListContext(DbContextOptions options) : base(options) { }\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Now EF Core will recognize the ",(0,a.jsx)(n.code,{children:"Tag"})," class as the ",(0,a.jsx)(n.code,{children:"Tag"})," entity. At this point we can create a new migration and update our database:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"$ dotnet ef migrations add AddTagEntity\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"$ dotnet ef database update\n"})}),"\n",(0,a.jsx)(n.h3,{id:"creating-the-join-entity",children:"Creating the JOIN Entity"}),"\n",(0,a.jsxs)(n.p,{children:["Next, we'll create a many-to-many relationship between ",(0,a.jsx)(n.code,{children:"Tag"})," and ",(0,a.jsx)(n.code,{children:"Item"}),". To do this, we need to create a model that will hold information about the relationship between a ",(0,a.jsx)(n.code,{children:"Tag"})," and an ",(0,a.jsx)(n.code,{children:"Item"}),". We'll call the class ",(0,a.jsx)(n.code,{children:"ItemTag"}),", which is an alphabetical combination of the two classes."]}),"\n",(0,a.jsx)(n.div,{className:"filename",children:"Models/ItemTag.cs"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"namespace ToDoList.Models\n{\n  public class ItemTag\n    {       \n        public int ItemTagId { get; set; }\n        public int ItemId { get; set; }\n        public Item Item { get; set; }\n        public int TagId { get; set; }\n        public Tag Tag { get; set; }\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We have three different ",(0,a.jsx)(n.code,{children:"Id"})," properties: one for ",(0,a.jsx)(n.code,{children:"ItemTag"}),", one for ",(0,a.jsx)(n.code,{children:"Item"}),", and one for ",(0,a.jsx)(n.code,{children:"Tag"}),". In addition to that, we also have both ",(0,a.jsx)(n.code,{children:"Item"})," and ",(0,a.jsx)(n.code,{children:"Tag"})," included as navigation properties. Remember that a ",(0,a.jsx)(n.strong,{children:"navigation property"})," is simply a property on one entity that includes a reference to a related entity, and it is what EF Core uses to define relationships between classes. In this case, there will be one ",(0,a.jsx)(n.code,{children:"Item"})," and one ",(0,a.jsx)(n.code,{children:"Tag"})," in each many-to-many relationship we create."]}),"\n",(0,a.jsxs)(n.p,{children:["Because ",(0,a.jsx)(n.code,{children:"Item"})," and ",(0,a.jsx)(n.code,{children:"Tag"})," each contain a reference to just one entity, we can give it a more specific name: ",(0,a.jsx)(n.strong,{children:"reference navigation property"}),". We'll add more navigation properties to ",(0,a.jsx)(n.code,{children:"Tag.cs"})," and ",(0,a.jsx)(n.code,{children:"Item.cs"})," later to complete the many-to-many relationship."]}),"\n",(0,a.jsxs)(n.p,{children:["Finally, keep in mind that navigation properties are not saved to the database; instead, they are used in our project by EF Core to fetch the data of related objects (like a ",(0,a.jsx)(n.code,{children:"Tag"}),") when we fetch an object (like an ",(0,a.jsx)(n.code,{children:"Item"}),")."]}),"\n",(0,a.jsxs)(n.p,{children:["Next, let's update ",(0,a.jsx)(n.code,{children:"ToDoListContext.cs"})," again to list a new ",(0,a.jsx)(n.code,{children:"DbSet"})," for ",(0,a.jsx)(n.code,{children:"ItemTag"}),"."]}),"\n",(0,a.jsx)(n.div,{className:"filename",children:"Models/ToDoListContext.cs"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"using Microsoft.EntityFrameworkCore;\n\nnamespace ToDoList.Models\n{\n  public class ToDoListContext : DbContext\n  {\n    public DbSet<Category> Categories { get; set; }\n    public DbSet<Item> Items { get; set; }\n    public DbSet<Tag> Tags { get; set; }\n    public DbSet<ItemTag> ItemTags { get; set; }\n\n    public ToDoListContext(DbContextOptions options) : base(options) { }\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Once we make the above change, EF Core will recognize ",(0,a.jsx)(n.code,{children:"ItemTag"})," as an entity and create a table for it in our database (after we make a new migration, of course). Because ",(0,a.jsx)(n.code,{children:"ItemTag"})," is joining two separate models into one, we call this a ",(0,a.jsx)(n.strong,{children:"join entity"}),". Similarly, once we update our database to include an ",(0,a.jsx)(n.code,{children:"ItemTag"})," table, we call this table a ",(0,a.jsx)(n.strong,{children:"join table"}),". This is because its only function is to join together two separate models to track a many-to-many relationship between the two. We must include a join entity for every many-to-many relationship that we want to create between two models."]}),"\n",(0,a.jsx)(n.h3,{id:"adding-navigation-properties-for-the-many-to-many-relationship",children:"Adding Navigation Properties for the Many-To-Many Relationship"}),"\n",(0,a.jsxs)(n.p,{children:["Next, it's time to create navigation properties for each side of our many-to-many relationship: ",(0,a.jsx)(n.code,{children:"Item"})," and ",(0,a.jsx)(n.code,{children:"Tag"}),". Since we're dealing with a many-to-many relationship, we're going to add a new collection navigation property to each model."]}),"\n",(0,a.jsxs)(n.p,{children:["Let's look at the update ",(0,a.jsx)(n.code,{children:"Item.cs"})," first:"]}),"\n",(0,a.jsx)(n.div,{className:"filename",children:"Models/Item.cs"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"using System.Collections.Generic;\n\nnamespace ToDoList.Models\n{\n  public class Item\n  {\n    public int ItemId { get; set; }\n    public string Description { get; set; }\n    public int CategoryId { get; set; }\n    public Category Category { get; set; }\n    public List<ItemTag> JoinEntities { get;}\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We've added a single new property: ",(0,a.jsx)(n.code,{children:"public List<ItemTag> JoinEntities { get;}"}),". This property is a navigation property. We've called our navigation property ",(0,a.jsx)(n.code,{children:"JoinEntities"}),", because it contains a collection of ",(0,a.jsx)(n.code,{children:"ItemTag"})," objects, which is our join entity (which itself represents the join table in our database for ",(0,a.jsx)(n.code,{children:"Item"})," and ",(0,a.jsx)(n.code,{children:"Tag"}),"). Because ",(0,a.jsx)(n.code,{children:"JoinEntities"})," is a collection of many related entities, we can give it a more specific name: ",(0,a.jsx)(n.strong,{children:"collection navigation property"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["We'll add the exact same property to ",(0,a.jsx)(n.code,{children:"Tag.cs"}),":"]}),"\n",(0,a.jsx)(n.div,{className:"filename",children:"Models/Tag.cs"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"using System.Collections.Generic;\n\nnamespace ToDoList.Models\n{\n  public class Tag\n  {\n    public int TagId { get; set; }\n    public string Title { get; set; }\n    public List<ItemTag> JoinEntities { get;}\n  }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"At this point we should track our recent changes by creating a new migration and updating our database:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"$ dotnet ef migrations add AddItemTagJoinEntity\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"$ dotnet ef database update\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If we take a look in MySQL Workbench, our ",(0,a.jsx)(n.code,{children:"to_do_list_with_many_to_many"})," database now has four tables:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"categories"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"items"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"tags"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"itemtags"})}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["In the ",(0,a.jsx)(n.code,{children:"itemtags"})," table, there are three columns: ",(0,a.jsx)(n.code,{children:"ItemTagId"}),", ",(0,a.jsx)(n.code,{children:"ItemId"})," and ",(0,a.jsx)(n.code,{children:"TagId"}),". This is exactly what we want."]}),"\n",(0,a.jsxs)(n.p,{children:["And with that, we've completed the first step of establishing a many-to-many relationship between ",(0,a.jsx)(n.code,{children:"Tag"})," and ",(0,a.jsx)(n.code,{children:"Item"}),". Up next, we'll begin updating our controllers and views."]}),"\n",(0,a.jsx)(n.h3,{id:"repository-reference",children:"Repository Reference"}),"\n",(0,a.jsx)(n.p,{children:"Follow the link below to view how a sample version of the project should look at this point. Note that this is a link to a specific branch in the repository."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:(0,a.jsxs)(n.a,{href:"https://github.com/epicodus-lessons/section-4-to-do-list-with-many-to-many-csharp-net6/tree/2_many_to_many_setup",children:[(0,a.jsx)(n.i,{className:"glyphicon glyphicon-folder-open"}),"  GitHub Repo for To Do List with EF Core Migrations and a Many-to-Many Relationship: 2_many_to_many_setup"]})})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);