"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[36686],{22674:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"capstone/capstone-week-1/introduction-to-stacks-and-queues","title":"\ud83d\udcd3 Introduction to Stacks and Queues","description":"In this lesson, we\'re going to learn about stacks and queues. We\'ll start by covering a brief overview of each. Then we\'ll write basic stack and queue functions.","source":"@site/docs/capstone/1_capstone-week-1/introduction-to-stacks-and-queues.md","sourceDirName":"capstone/1_capstone-week-1","slug":"/capstone/capstone-week-1/introduction-to-stacks-and-queues","permalink":"/v1.2/capstone/capstone-week-1/introduction-to-stacks-and-queues","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":21,"frontMatter":{"title":"\ud83d\udcd3 Introduction to Stacks and Queues","id":"introduction-to-stacks-and-queues","slug":"introduction-to-stacks-and-queues","hide_table_of_contents":true,"sidebar_position":21,"day":"tuesday","type":"lesson","url":"https://github.com/epicodus-curriculum/capstone/blob/main/5_stacks_and_queues.md"},"sidebar":"capstone","previous":{"title":"\ud83d\udcd3 Building Graphs Part 2","permalink":"/v1.2/capstone/capstone-week-1/building-graphs-part-2"},"next":{"title":"\ud83d\udcd3 Depth and Breadth Search Algorithms","permalink":"/v1.2/capstone/capstone-week-1/depth-and-breadth-search-algorithms"}}');var o=n(74848),a=n(28453);const i={title:"\ud83d\udcd3 Introduction to Stacks and Queues",id:"introduction-to-stacks-and-queues",slug:"introduction-to-stacks-and-queues",hide_table_of_contents:!0,sidebar_position:21,day:"tuesday",type:"lesson",url:"https://github.com/epicodus-curriculum/capstone/blob/main/5_stacks_and_queues.md"},r=void 0,c={},l=[{value:"Writing Our Own Stack and Queue Functions",id:"writing-our-own-stack-and-queue-functions",level:3},{value:"Exercise",id:"exercise",level:4},{value:"Solution",id:"solution",level:4}];function h(e){const t={code:"code",em:"em",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["In this lesson, we're going to learn about ",(0,o.jsx)(t.strong,{children:"stacks"})," and ",(0,o.jsx)(t.strong,{children:"queues"}),". We'll start by covering a brief overview of each. Then we'll write basic ",(0,o.jsx)(t.code,{children:"stack"})," and ",(0,o.jsx)(t.code,{children:"queue"})," functions."]}),"\n",(0,o.jsxs)(t.p,{children:["Stacks and queues are both data structures that hold a list of elements. However, there is a key difference in how they work. A queue is ",(0,o.jsx)(t.strong,{children:"first in, first out"})," or ",(0,o.jsx)(t.strong,{children:"FIFO"}),". On the other hand, a stack is ",(0,o.jsx)(t.strong,{children:"last in, first out"})," or ",(0,o.jsx)(t.strong,{children:"LIFO"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"Let's use some examples of how both the FIFO and LIFO principles apply in our daily lives."}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"When we get in a line (at the grocery store checkout counter, to go to a movie, or anything else), we expect the first person in line to get served first and so on. This is a prime example of FIFO. People would get very upset if the last people in line were served first."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"On the other hand, let's say we are reorganizing and stacking books from a bookshelf one at a time. When we take a book off the stack, we will most likely take it off the top of the stack, not the bottom. This is an example of LIFO because the last book added to the stack is the first one that's taken off the stack."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"There are plenty of examples in computer programming where we'll use queues and stacks as well. For instance, we might be waiting in a help ticket queue at a code school like Epicodus. Or we might be waiting to download something and others are queued to download that thing first."}),"\n",(0,o.jsx)(t.p,{children:"When it comes to stacks, we work with the JavaScript call stack every time we write JavaScript code. We can see this clearly in the following example:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:'function first() {\n  return second();\n}\n\nfunction second() {\n  return third();\n}\n\nfunction third() {\n  return "hello!"\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["When we call ",(0,o.jsx)(t.code,{children:"first()"}),", what happens? ",(0,o.jsx)(t.code,{children:"first()"})," calls ",(0,o.jsx)(t.code,{children:"second()"})," which calls ",(0,o.jsx)(t.code,{children:"third()"}),". But which one is actually ",(0,o.jsx)(t.em,{children:"resolved"})," first? Well, ",(0,o.jsx)(t.code,{children:"first()"})," can't be resolved until ",(0,o.jsx)(t.code,{children:"second()"})," is \u2014 and ",(0,o.jsx)(t.code,{children:"second()"})," can't be resolved until ",(0,o.jsx)(t.code,{children:"third()"})," is. How can the ",(0,o.jsx)(t.code,{children:"first()"})," function ultimately return ",(0,o.jsx)(t.code,{children:'"hello!"'})," unless the ",(0,o.jsx)(t.code,{children:"third()"})," function resolves first?"]}),"\n",(0,o.jsx)(t.p,{children:"This is the stack:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"TOP OF THE STACK\n\nthird()\nsecond()\nfirst()\n\nBOTTOM OF THE STACK\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The technical term for each function is a stack is a ",(0,o.jsx)(t.strong,{children:"frame"}),". Whenever a function is called in the JavaScript runtime (the time our code is actually executed), the runtime creates a stack frame for that function. There is a limit to that stack \u2014 which you've probably noticed if you've ever run an infinite loop by accident and received a ",(0,o.jsx)(t.code,{children:"Range error: maximum call stack size exceeded"})," error."]}),"\n",(0,o.jsxs)(t.p,{children:["By the way, if you are confused about what the runtime ",(0,o.jsx)(t.em,{children:"is"}),", in the Chrome browser or in Node (JavaScript backend environment) the runtime is the V8 engine."]}),"\n",(0,o.jsxs)(t.p,{children:["And when it comes to queues, we are actually working with a queue every time we run async JavaScript code in the browser. The browser actually uses separate web APIs to run async code and when that async code is ready to run (such as when a response from an API is received), that code is actually put in a ",(0,o.jsx)(t.strong,{children:"callback queue"})," which is ",(0,o.jsx)(t.em,{children:"not"})," the call stack. So our synchronous code is put on the call stack (LIFO) while our asynchronous code is queued up in the callback queue (FIFO). Meanwhile, an event loop determines whether to run code from the call stack or the callback queue. You don't need to have a deep understanding of this to work with JavaScript. The point here is that we are regularly working with both stacks and queues whether we are aware of it or not!"]}),"\n",(0,o.jsx)(t.h3,{id:"writing-our-own-stack-and-queue-functions",children:"Writing Our Own Stack and Queue Functions"}),"\n",(0,o.jsx)(t.h4,{id:"exercise",children:"Exercise"}),"\n",(0,o.jsxs)(t.p,{children:["Next, let's do a little exercise. See if you can write your own ",(0,o.jsx)(t.code,{children:"stack()"})," and ",(0,o.jsx)(t.code,{children:"queue()"})," classes which add and remove elements as needed. Here are some hints \u2014 and don't overthink it. It's actually surprisingly simple to do."]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Remember that both stacks and queues are data structures."}),"\n",(0,o.jsx)(t.li,{children:"What common data structure will allow us to easily add and remove elements?"}),"\n",(0,o.jsx)(t.li,{children:"Stacks are last in, first out, which means we need to add things to the end of the data structure and remove things from the end of the data structure."}),"\n",(0,o.jsx)(t.li,{children:"Queues are first in, first out, which means we need to add things to the end of the data structure and then remove things from the beginning of the data structure."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Take a few minutes to write out these classes and then check out the solution below."}),"\n",(0,o.jsx)(t.h4,{id:"solution",children:"Solution"}),"\n",(0,o.jsxs)(t.p,{children:["The hints hopefully made it fairly clear that we can use arrays to easily model both queues and stacks. ",(0,o.jsx)(t.code,{children:"Array.prototype.push()"})," can be used to add elements to the end of either a stack or a queue. Meanwhile, we can use ",(0,o.jsx)(t.code,{children:"Array.prototype.pop()"})," to remove elements from the end of a stack and we can use ",(0,o.jsx)(t.code,{children:"Array.prototype.shift()"})," to remove elements from the beginning of a queue."]}),"\n",(0,o.jsx)(t.p,{children:"Here's our simple implementation of a stack:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"class Stack {\n  constructor() {\n    this.elements = [];\n  }\n\n  push(element) {\n    return this.elements.push(element);\n  }\n\n  pop() {\n    return this.elements.pop();\n  }\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Yep, that's it. That is really all a stack is doing \u2014 pushing and popping. Note that we can also use ",(0,o.jsx)(t.code,{children:"Array.prototype.shift()"})," and ",(0,o.jsx)(t.code,{children:"Array.prototype.unshift()"})," as well. This feels a bit closer to how a stack actually works since it adds an element to the beginning of the collection and then removes it from the beginning of the collection. The one downside to this approach is that it's a bit slower \u2014 that's because JavaScript needs to re-index the array each time an element is added or removed from the beginning of the stack."]}),"\n",(0,o.jsx)(t.p,{children:"Ultimately, either approach is fine \u2014 the most important thing is that whichever element was added to the stack most recently must also be the one that gets removed most recently \u2014 that's last-in, first-out (LIFO)."}),"\n",(0,o.jsx)(t.p,{children:"Here's our implementation of a queue \u2014 which will look very similar:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"class Queue {\n  constructor() {\n    this.elements = [];\n  }\n\n  enqueue(element) {\n    return this.elements.push(element);\n  }\n\n  dequeue() {\n    return this.elements.shift();\n  }\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["There are a few differences here. First, we call our methods ",(0,o.jsx)(t.code,{children:"Queue.prototype.enqueue()"})," and ",(0,o.jsx)(t.code,{children:"Queue.prototype.dequeue()"}),". That's because when we add an item to a queue, it's known as ",(0,o.jsx)(t.strong,{children:"enqueuing"})," while removing an item from a queue is known as ",(0,o.jsx)(t.strong,{children:"dequeuing"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"Actual queues and stacks generally have other methods as well \u2014 and they are more complex than these very simple implementations. However, on a basic conceptual level, the code examples above encapsulate what we need to know about stacks and queues."}),"\n",(0,o.jsx)(t.p,{children:"We'll get more practice with stacks and queues when we write certain algorithms. For instance, it's common to use a queue with a breadth-first search algorithm and a stack with a depth-first search algorithm."})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var s=n(96540);const o={},a=s.createContext(o);function i(e){const t=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);