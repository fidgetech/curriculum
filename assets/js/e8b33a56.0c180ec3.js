"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[59296],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var s=t(96540);const a={},o=s.createContext(a);function i(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(o.Provider,{value:n},e.children)}},29788:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"intermediate-javascript/asynchrony-and-apis/2-3-2-3-async-and-await","title":"\ud83d\udcd3 2.3.2.3 Async and Await","description":"In this lesson, we\'ll cover async functions, a relatively new JavaScript feature that was added in ES 2017. (Remember that ES6 is ECMAScript 2015.) While you aren\'t required to use async functions for the independent project, they are a really useful piece of JavaScript functionality and definitely a tool you should know about and be familiar with.","source":"@site/versioned_docs/version-v1_3/2_intermediate-javascript/3_asynchrony-and-apis/2-3-2-03-async-and-await.md","sourceDirName":"2_intermediate-javascript/3_asynchrony-and-apis","slug":"/intermediate-javascript/asynchrony-and-apis/2-3-2-3-async-and-await","permalink":"/v1.3/intermediate-javascript/asynchrony-and-apis/2-3-2-3-async-and-await","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 2.3.2.3 Async and Await","day":"tuesday","id":"2-3-2-3-async-and-await","hide_table_of_contents":true},"sidebar":"intermediate-javascript","previous":{"title":"\ud83d\udcd3 2.3.2.2 Fetch API","permalink":"/v1.3/intermediate-javascript/asynchrony-and-apis/2-3-2-2-fetch-api"},"next":{"title":"\ud83d\udcd3 2.3.2.4 Further Exploration: IIFEs","permalink":"/v1.3/intermediate-javascript/asynchrony-and-apis/2-3-2-4-further-exploration-iifes"}}');var a=t(74848),o=t(28453);const i={title:"\ud83d\udcd3 2.3.2.3 Async and Await",day:"tuesday",id:"2-3-2-3-async-and-await",hide_table_of_contents:!0},r=void 0,c={},d=[{value:"<code>async</code> Functions",id:"async-functions",level:2},{value:"<code>async</code> and <code>await</code>",id:"async-and-await",level:3},{value:"Adding <code>async</code> and <code>await</code> to our OpenWeather API Project",id:"adding-async-and-await-to-our-openweather-api-project",level:3}];function l(e){const n={a:"a",code:"code",div:"div",h2:"h2",h3:"h3",hr:"hr",i:"i",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"In this lesson, we'll cover async functions, a relatively new JavaScript feature that was added in ES 2017. (Remember that ES6 is ECMAScript 2015.) While you aren't required to use async functions for the independent project, they are a really useful piece of JavaScript functionality and definitely a tool you should know about and be familiar with."}),"\n",(0,a.jsx)(n.p,{children:"An async function allows us to write asynchronous code as if it were synchronous. This can make our code more concise. And while promises go very well with API calls, there are plenty of other situations where using async functions will handle asynchronous operations better than a promise will. For example, if we wanted to do a series of five or six things in a row, many but not all of them async, code with promises would be very verbose while async functions would be easier to read and reason about."}),"\n",(0,a.jsxs)(n.p,{children:["In fact, even the code from the last lesson chains together two async operations. Throw another API call into the mix that also uses ",(0,a.jsx)(n.code,{children:"fetch()"})," and we are talking about four async operations in a row when we consider the streaming data as well. It's very feasible that we'd do a few synchronous things in between(such as parsing data from the first API call)."]}),"\n",(0,a.jsxs)(n.h2,{id:"async-functions",children:[(0,a.jsx)(n.code,{children:"async"})," Functions"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsxs)(n.p,{children:["Before we update our weather API project to use async functions, let's take a look at an example. We can create an async function with the ",(0,a.jsx)(n.code,{children:"async"})," keyword. Try the following code in the console:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'> async function thisIsAsync() { return "This is async"; }\n> thisIsAsync();\nPromise\xa0{<resolved>: "This is async"}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["All we did here is add the ",(0,a.jsx)(n.code,{children:"async"})," keyword to a basic function that returns a string. When we call the function, it returns a resolved promise. As this example shows, async functions are using promises under the hood, too!"]}),"\n",(0,a.jsxs)(n.h3,{id:"async-and-await",children:[(0,a.jsx)(n.code,{children:"async"})," and ",(0,a.jsx)(n.code,{children:"await"})]}),"\n",(0,a.jsxs)(n.p,{children:["The real power of async functions lies with the ",(0,a.jsx)(n.code,{children:"await"})," keyword. When ",(0,a.jsx)(n.code,{children:"await"})," is used within an async function, our code will stop executing until the line of code that includes ",(0,a.jsx)(n.code,{children:"await"})," is completed. Let's take a look at an example in the context of an API call that uses ",(0,a.jsx)(n.code,{children:"fetch()"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'async function makeApiCall() {\n  const response = await fetch("http://some-api-call.com");\n  const jsonifiedResponse = await response.json();\n  return jsonifiedResponse;\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["We start by adding the ",(0,a.jsx)(n.code,{children:"async"})," keyword to our ",(0,a.jsx)(n.code,{children:"makeApiCall()"})," function. Now we can use the ",(0,a.jsx)(n.code,{children:"await"})," keyword as needed inside of the async function to wait for asynchronous actions to complete."]}),"\n",(0,a.jsxs)(n.p,{children:["Note that we can't use the ",(0,a.jsx)(n.code,{children:"await"})," keyword outside of an ",(0,a.jsx)(n.code,{children:"async"})," function. If we try to, we'll get the following error: ",(0,a.jsx)(n.code,{children:"Uncaught SyntaxError: await is only valid in async function"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Next, we set the value of the ",(0,a.jsx)(n.code,{children:"response"})," variable to be equal to the response of the API call. If we did this without the ",(0,a.jsx)(n.code,{children:"await"})," keyword, ",(0,a.jsx)(n.code,{children:"response"})," would be undefined. That's because the variable is assigned before the async ",(0,a.jsx)(n.code,{children:"fetch()"})," call is complete."]}),"\n",(0,a.jsxs)(n.p,{children:["Once we add the ",(0,a.jsx)(n.code,{children:"await"})," keyword, though, the value of ",(0,a.jsx)(n.code,{children:"response"})," won't be assigned until the ",(0,a.jsx)(n.code,{children:"fetch()"})," call is resolved."]}),"\n",(0,a.jsxs)(n.p,{children:["We also need to ",(0,a.jsx)(n.code,{children:"await"})," the completion of the ",(0,a.jsx)(n.code,{children:"Response.json()"})," method because it's an async operation, too. Once that's done, we're ready to return the final ",(0,a.jsx)(n.code,{children:"jsonifiedResponse"}),". The ",(0,a.jsx)(n.code,{children:"await"})," keyword has given us the ability to write asynchronous code as if it were synchronous. This results in very concise code that is easy to read and understand."]}),"\n",(0,a.jsxs)(n.h3,{id:"adding-async-and-await-to-our-openweather-api-project",children:["Adding ",(0,a.jsx)(n.code,{children:"async"})," and ",(0,a.jsx)(n.code,{children:"await"})," to our OpenWeather API Project"]}),"\n",(0,a.jsxs)(n.p,{children:["Now that we've looked at a basic example, let's update our weather application to use ",(0,a.jsx)(n.code,{children:"async"})," and ",(0,a.jsx)(n.code,{children:"await"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"We'll start by updating our service logic:"}),"\n",(0,a.jsx)(n.div,{className:"filename",children:"src/weather-service.js"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"export default class WeatherService {  \n  static async getWeather(city) {\n    try {\n      const response = await fetch(`http://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${process.env.API_KEY}`);\n      const jsonifiedResponse = await response.json();\n      if (!response.ok) {\n        const errorMessage = `${response.status} ${response.statusText}\n        ${jsonifiedResponse.message}`;\n        throw new Error(errorMessage);\n      }\n      return jsonifiedResponse;\n    } catch(error) {\n      return error;\n    }\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["First, we update our static ",(0,a.jsx)(n.code,{children:"getWeather"})," method to be async. Next, we need to wrap our code in a ",(0,a.jsx)(n.code,{children:"try...catch"})," block. We use a ",(0,a.jsx)(n.code,{children:"try...catch"})," block to handle errors, because ",(0,a.jsx)(n.code,{children:"async"})," functions don't have the capability of resolving or rejecting the promise it uses under the hood."]}),"\n",(0,a.jsxs)(n.p,{children:["Inside the ",(0,a.jsx)(n.code,{children:"try"})," block, we'll make our API call with ",(0,a.jsx)(n.code,{children:"fetch()"})," and then use the ",(0,a.jsx)(n.code,{children:"await"})," keyword to wait for the API call to complete. Then we call ",(0,a.jsx)(n.code,{children:"reponse.json()"}),", and ",(0,a.jsx)(n.code,{children:"await"})," this action. We do this next so that we can use the API response for weather data and for its error messages. The rest of the service code has only minor changes to variable names \u2014 we still throw an error if the ",(0,a.jsx)(n.code,{children:"response"})," property isn't ",(0,a.jsx)(n.code,{children:"ok"}),", and if the response property is ",(0,a.jsx)(n.code,{children:"ok"}),', we return the "jsonified" response.']}),"\n",(0,a.jsx)(n.p,{children:"Next, let's take a look at our user interface logic:"}),"\n",(0,a.jsx)(n.div,{className:"filename",children:"src/index.js"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import 'bootstrap';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport './css/styles.css';\nimport WeatherService from './weather-service.js';\n\n// Business Logic\n\nasync function getWeather(city) {\n  const response = await WeatherService.getWeather(city);\n  if (response.main) {\n    printElements(response, city);\n  } else {\n    printError(response, city);\n  }\n}\n\n// UI Logic\n\nfunction printElements(response, city) {\n  document.querySelector('#showResponse').innerText = `The humidity in ${city} is ${response.main.humidity}%.\n  The temperature in Kelvins is ${response.main.temp} degrees.`;\n}\n\nfunction printError(error, city) {\n  document.querySelector('#showResponse').innerText = `There was an error accessing the weather data for ${city}: \n  ${error}.`;\n}\n\nfunction handleFormSubmission(event) {\n  event.preventDefault();\n  const city = document.querySelector('#location').value;\n  document.querySelector('#location').value = null;\n  getWeather(city);\n}\n\nwindow.addEventListener(\"load\", function() {\n  document.querySelector('form').addEventListener(\"submit\", handleFormSubmission);\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["All of the updates we've made are within the ",(0,a.jsx)(n.code,{children:"getWeather"})," function. Now this function is ",(0,a.jsx)(n.code,{children:"async"}),", and inside we ",(0,a.jsx)(n.code,{children:"await"})," the response of the API call."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"async function getWeather(city) {\n  const response = await WeatherService.getWeather(city);\n  if (response.main) {\n    printElements(response, city);\n  } else {\n    printError(response, city);\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Then, instead of using ",(0,a.jsx)(n.code,{children:"Promise.prototype.then()"}),", we directly run the ",(0,a.jsx)(n.code,{children:"response"})," variable through a conditional to determine whether to print the weather data or print an error message."]}),"\n",(0,a.jsx)(n.p,{children:"And that's it!"}),"\n",(0,a.jsx)(n.p,{children:"Async functions can be a concise and elegant way to write code. However, it's important to think carefully about the code we put inside async functions. We are essentially forcing any code inside an async function to run synchronously. That means any asynchronous actions will block the flow of code until it is complete. If we put too much code inside an async function, we risk overriding JavaScript's non-blocking capabilities, potentially making our code more inefficient. That's not an issue in the code above but it would be if we wrapped our entire application in an async function."}),"\n",(0,a.jsx)(n.p,{children:"You are welcome (but not required) to use async functions for this section's independent project. You are also encouraged to practice writing async functions during the classwork. However, make sure you have a clear understanding of promises first. After all, async functions use promises under the hood."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:(0,a.jsxs)(n.a,{href:"https://github.com/epicodus-lessons/section-6-js-api-call-with-webpack/tree/5_fetch_with_async_await",children:[(0,a.jsx)(n.i,{className:"glyphicon glyphicon-folder-open"}),"  Example GitHub Repo for API Project with ",(0,a.jsx)(n.code,{children:"fetch()"})]})})}),"\n",(0,a.jsxs)(n.p,{children:["The above link takes you to the branch called ",(0,a.jsx)(n.code,{children:"5_fetch_with_async_await"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);