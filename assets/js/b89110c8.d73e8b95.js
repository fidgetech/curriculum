"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[87049],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var i=t(96540);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}},43556:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"c-and-net/test-driven-development-with-c/3-1-2-4-apie-polymorphism","title":"\ud83d\udcd3 3.1.2.4 APIE: Polymorphism","description":"We have one last principle of Object-Oriented Programming (OOP) to learn about","source":"@site/versioned_docs/version-v1_3/3_c-and-net/1_test-driven-development-with-c/3-1-2-04-apie-polymorphism.md","sourceDirName":"3_c-and-net/1_test-driven-development-with-c","slug":"/c-and-net/test-driven-development-with-c/3-1-2-4-apie-polymorphism","permalink":"/v1.3/c-and-net/test-driven-development-with-c/3-1-2-4-apie-polymorphism","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 3.1.2.4 APIE: Polymorphism","day":"tuesday","id":"3-1-2-4-apie-polymorphism","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.1.2.3 Interfaces: Another Tool for Abstraction and Inheritance","permalink":"/v1.3/c-and-net/test-driven-development-with-c/3-1-2-3-interfaces-another-tool-for-abstraction-and-inheritance"},"next":{"title":"\ud83d\udcd3 3.1.2.5 More About Data Types: Value Types, Reference Types, Generic Types, and More","permalink":"/v1.3/c-and-net/test-driven-development-with-c/3-1-2-5-more-about-data-types-value-types-reference-types-generic-types-and-more"}}');var r=t(74848),a=t(28453);const s={title:"\ud83d\udcd3 3.1.2.4 APIE: Polymorphism",day:"tuesday",id:"3-1-2-4-apie-polymorphism",hide_table_of_contents:!0},l=void 0,o={},c=[{value:"Polymorphism",id:"polymorphism",level:2}];function d(e){const n={code:"code",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["We have one last principle of Object-Oriented Programming (OOP) to learn about: polymorphism! As a reminder, polymorphism is one of four principles of OOP that we can remember by the easy acronym ",(0,r.jsx)(n.strong,{children:"APIE"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"A"}),"bstraction"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"P"}),"olymorphism"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"I"}),"nheritance"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"E"}),"ncapsulation"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:['The word "polymorphism" comes from Greek and it means "many forms". In terms of programming, ',(0,r.jsx)(n.strong,{children:"polymorphism"})," happens when an object or method has multiple forms, but is identified by the same name."]}),"\n",(0,r.jsx)(n.h2,{id:"polymorphism",children:"Polymorphism"}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["Let's start with an example. What follows is a ",(0,r.jsx)(n.code,{children:"Triangle"})," class adapted from our Shape Tracker app. This ",(0,r.jsx)(n.code,{children:"Triangle"})," class has an overloaded constructor so that we can create a ",(0,r.jsx)(n.code,{children:"Triangle"})," object with a single value, or we can create a ",(0,r.jsx)(n.code,{children:"Triangle"})," object with three values, one for each side:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class Triangle\n{\n  // Auto-Implemented Properties\n  public int Side1 { get; set; }\n  public int Side2 { get; set; }\n  private int Side3 { get; set; }\n\n  public Triangle(int length)\n  {\n    Side1 = length;\n    Side2 = length;\n    Side3 = length;\n  }\n\n  public Triangle(int length1, int length2, int length3)\n  {\n    Side1 = length1;\n    Side2 = length2;\n    Side3 = length3;\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["When we use an overloaded constructor, we're using polymorphism: we have two different ",(0,r.jsx)(n.code,{children:"Triangle()"})," methods, with just one name, but with two different behaviors."]}),"\n",(0,r.jsxs)(n.p,{children:["More specifically, this is called ",(0,r.jsx)(n.strong,{children:"compile-time polymorphism"}),", because the compiler will sort out which ",(0,r.jsx)(n.code,{children:"Triangle()"})," method to use. So, when we call the following ",(0,r.jsx)(n.code,{children:"Triangle()"})," method:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"class Program\n{\n  static void Main()\n  {\n    Triangle tri = new Triangle(3);\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The compiler will first search for the ",(0,r.jsx)(n.code,{children:"Triangle"})," class constructor methods, and then determine which is the correct version to use; if the compiler can't find one, it will throw an error."]}),"\n",(0,r.jsx)(n.p,{children:"And that's as simple as it gets: polymorphism happens when an object or method has multiple forms and behaviors."}),"\n",(0,r.jsxs)(n.p,{children:["There's also ",(0,r.jsx)(n.strong,{children:"run-time polymorphism"})," in which the exact object type or method to run is determined when our program is running. Let's look at an example."]}),"\n",(0,r.jsx)(n.p,{children:"This next example will build on the previous example and involve inheritance:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class Shape\n{\n  public virtual int CalculateArea()\n  {\n    return 0;\n  }\n}\n\npublic class Triangle : Shape\n{\n  // Auto-Implemented Properties\n  public int Side1 { get; set; }\n  public int Side2 { get; set; }\n  private int Side3 { get; set; }\n\n  public Triangle(int length)\n  {\n    Side1 = length;\n    Side2 = length;\n    Side3 = length;\n  }\n\n  public Triangle(int length1, int length2, int length3)\n  {\n    Side1 = length1;\n    Side2 = length2;\n    Side3 = length3;\n  }\n\n  public override int CalculateArea()\n  {\n    return Side1 * Side2 * Side3;\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Now we've created a new ",(0,r.jsx)(n.code,{children:"Shape"})," class that extends the ",(0,r.jsx)(n.code,{children:"Triangle"})," class, giving it access to the ",(0,r.jsx)(n.code,{children:"virtual CalculateArea()"})," method."]}),"\n",(0,r.jsxs)(n.p,{children:["Within the ",(0,r.jsx)(n.code,{children:"Triangle"})," class, we've overridden the same ",(0,r.jsx)(n.code,{children:"CalculateArea()"})," method. Based on what we learned in the previous lesson about the ",(0,r.jsx)(n.code,{children:"override"})," modifier, we know it allows us to declare a new value for an inherited ",(0,r.jsx)(n.code,{children:"virtual"})," method, and this is exactly what we're doing."]}),"\n",(0,r.jsxs)(n.p,{children:["Now, when we invoke ",(0,r.jsx)(n.code,{children:"shp.CalculateArea();"})," in the following code, do you think it will return ",(0,r.jsx)(n.code,{children:"8"})," or ",(0,r.jsx)(n.code,{children:"0"}),"? Take a moment to review the code and make a guess. Notice that we create a new ",(0,r.jsx)(n.code,{children:"Triangle"})," object, then a new ",(0,r.jsx)(n.code,{children:"Shape"})," object that is assigned ",(0,r.jsx)(n.code,{children:"tri"}),", the original ",(0,r.jsx)(n.code,{children:"Triangle"})," object, as a value."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"class Program\n{\n  static void Main()\n  {\n    Triangle tri = new Triangle(2);\n    Shape shp = tri;\n    int area = shp.CalculateArea();\n    // Will 'area' be equal to 8 or 0?\n    System.Console.WriteLine(area);\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Determining whether ",(0,r.jsx)(n.code,{children:"shp.CalculateArea()"})," should invoke the ",(0,r.jsx)(n.code,{children:"Triangle.CalculateArea()"})," method and return ",(0,r.jsx)(n.code,{children:"8"}),", or the ",(0,r.jsx)(n.code,{children:"Shape.CalculateArea()"})," method and return ",(0,r.jsx)(n.code,{children:"0"}),", is an example of polymorphism. Specifically, this is an example of run-time polymorphism, where exactly which method should be called is determined while our program is running."]}),"\n",(0,r.jsxs)(n.p,{children:["When we run the above code, we'll get ",(0,r.jsx)(n.code,{children:"8"})," returned to us. That's because while our program is running it determined that the ",(0,r.jsx)(n.code,{children:"Triangle.CalculateArea()"})," method has overridden the ",(0,r.jsx)(n.code,{children:"Shape.CalculateArea()"})," method and because of this, the ",(0,r.jsx)(n.code,{children:"Triangle.CalculateArea()"})," method takes precedence."]}),"\n",(0,r.jsxs)(n.p,{children:["If we did not want the original ",(0,r.jsx)(n.code,{children:"Shape.CalculateArea()"})," method to be overridden, we can update our ",(0,r.jsx)(n.code,{children:"Triangle.CalculateArea()"})," method declaration to use the ",(0,r.jsx)(n.code,{children:"new"})," modifier to indicate that it is a new method that is separate from the inherited ",(0,r.jsx)(n.code,{children:"Shape.CalculateArea()"})," method:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class Triangle : Shape\n{\n  ... // other logic\n\n  public new int CalculateArea()\n  {\n    return Side1 * Side2 * Side3;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now if we re-run our program code, as-is, without making any addditional changes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"class Program\n{\n  static void Main()\n  {\n    Triangle tri = new Triangle(2);\n    Shape shp = tri;\n    int area = shp.CalculateArea();\n    System.Console.WriteLine(area);\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We'll get ",(0,r.jsx)(n.code,{children:"0"})," returned to us, because at run time our program has determined that the ",(0,r.jsx)(n.code,{children:"shp.CalculateArea()"})," is in fact invoking the base class ",(0,r.jsx)(n.code,{children:"Shape.CalculateArea()"}),". This is happening because the ",(0,r.jsx)(n.code,{children:"Triangle.CalculateArea()"})," method is declared as ",(0,r.jsx)(n.code,{children:"new"})," and no longer overrides the base class ",(0,r.jsx)(n.code,{children:"Shape.CalculateArea()"})," method."]}),"\n",(0,r.jsx)(n.p,{children:"Is this a little confusing? Well, that's not unexpected with polymorphism since it is all about dealing with an object or method that has multiple forms, but is identified by the same name. Fortunately, it's unlikely that you'll encounter code like we saw in the last example of run time polymorphism, as it is a contrived example. As long as you structure inheritance intentionally in your apps and write tests for your code, any errors that arise from polymorphism will get identified quickly, and you'll be able to resolve those errors just as quickly."}),"\n",(0,r.jsxs)(n.p,{children:["Remember that ",(0,r.jsx)(n.strong,{children:"you are not required to use polymorphism for this section's independent project."})," As always, we encourage you to experiment with it and try it in your code if possible."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);