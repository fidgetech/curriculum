"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[93138],{28453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var t=s(96540);const a={},r=t.createContext(a);function i(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(r.Provider,{value:n},e.children)}},32318:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"c-and-net/lessons-6-18-data-types-and-variables/3-0-0-11-classes-and-instance-methods","title":"\ud83d\udcd3 3.0.0.11 Classes and Instance Methods","description":"We wrote many JavaScript methods and functions in Introduction to Programming. The process is fairly similar in C# as well, but in this case we will always call them methods. That\'s because in C# every method \u2014 custom or built-in \u2014 belongs to some object. In other words, there are no standalone functions.","source":"@site/versioned_docs/version-v1_3/3_c-and-net/0_lessons-6-18-data-types-and-variables/3-0-0-11-classes-and-instance-methods.md","sourceDirName":"3_c-and-net/0_lessons-6-18-data-types-and-variables","slug":"/c-and-net/lessons-6-18-data-types-and-variables/3-0-0-11-classes-and-instance-methods","permalink":"/v1.3/c-and-net/lessons-6-18-data-types-and-variables/3-0-0-11-classes-and-instance-methods","draft":false,"unlisted":false,"tags":[],"version":"v1_3","frontMatter":{"title":"\ud83d\udcd3 3.0.0.11 Classes and Instance Methods","day":"weekend","id":"3-0-0-11-classes-and-instance-methods","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.0.0.10 Booleans, Branching, and Operators","permalink":"/v1.3/c-and-net/lessons-6-18-data-types-and-variables/3-0-0-10-booleans-branching-and-operators"},"next":{"title":"\ud83d\udcd3 3.0.0.12 Namespaces and Checking the Type of an Object","permalink":"/v1.3/c-and-net/lessons-6-18-data-types-and-variables/3-0-0-12-namespaces-and-checking-the-type-of-an-object"}}');var a=s(74848),r=s(28453);const i={title:"\ud83d\udcd3 3.0.0.11 Classes and Instance Methods",day:"weekend",id:"3-0-0-11-classes-and-instance-methods",hide_table_of_contents:!0},o=void 0,l={},h=[{value:"Classes",id:"classes",level:2},{value:"Useful Built-In C# Instance Methods",id:"useful-built-in-c-instance-methods",level:2},{value:"Method Naming Convention",id:"method-naming-convention",level:3},{value:"String Methods with Arguments",id:"string-methods-with-arguments",level:3},{value:"Strong Typing in Arguments",id:"strong-typing-in-arguments",level:3},{value:"Integer Methods",id:"integer-methods",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["We wrote many JavaScript methods and functions in Introduction to Programming. The process is fairly similar in C# as well, but in this case we will always call them ",(0,a.jsx)(n.strong,{children:"methods"}),". That's because in C# every method \u2014 custom or built-in \u2014 belongs to some object. In other words, there are no standalone functions."]}),"\n",(0,a.jsxs)(n.p,{children:["In this lesson, we'll practice calling ",(0,a.jsx)(n.strong,{children:"built-in"})," C# methods, that is, methods that already exist within the C# language that we just need to learn the right syntax in order to use. This is in contrast to ",(0,a.jsx)(n.strong,{children:"custom"})," methods, which we create. We'll learn how to create custom methods in a later lesson."]}),"\n",(0,a.jsxs)(n.p,{children:["This lesson will be focused on learning how to use ",(0,a.jsx)(n.strong,{children:"instance methods"}),", which are methods that are called on an object. This is in contrast to ",(0,a.jsx)(n.strong,{children:"static methods"}),", which are methods that are called on the class itself. We'll learn how to use static methods in an upcoming lesson."]}),"\n",(0,a.jsx)(n.h2,{id:"classes",children:"Classes"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:"First, let's review the difference between an instance of a class, and the class itself."}),"\n",(0,a.jsxs)(n.p,{children:["Just like in JavaScript, a ",(0,a.jsx)(n.strong,{children:"class"})," contains related code for a type of object. Well, nearly all values in C# are a type of object. That means the C# programming language is composed of syntax (like operators) as well as many built-in classes."]}),"\n",(0,a.jsx)(n.p,{children:"The string and integer literals we've created are also objects:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'> "I am a string, but still an object :)"\n"I am a string, but still an object :)"\n> 34\n34\n'})}),"\n",(0,a.jsxs)(n.p,{children:["When we create a string in the ",(0,a.jsx)(n.code,{children:"dotnet-script"})," REPL, we're invoking the built-in C# ",(0,a.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.string?view=net-6.0",children:(0,a.jsx)(n.code,{children:"String"})})," class to create a new object based off it. The ",(0,a.jsx)(n.code,{children:"String"})," class describes all of properties and methods that every C# string should have."]}),"\n",(0,a.jsxs)(n.p,{children:["More specifically, when we create a string like we did in the above code snippet, we're creating an ",(0,a.jsx)(n.strong,{children:"instance"})," of the ",(0,a.jsx)(n.code,{children:"String"})," class that has the same properties and methods described in the ",(0,a.jsx)(n.code,{children:"String"})," class. An instance is an object, whereas the class is the blueprint with which to make objects."]}),"\n",(0,a.jsx)(n.p,{children:"Later on, we'll learn how to create our own custom classes. For now, we'll continue working with built-in C# classes."}),"\n",(0,a.jsx)(n.h2,{id:"useful-built-in-c-instance-methods",children:"Useful Built-In C# Instance Methods"}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsxs)(n.p,{children:["An ",(0,a.jsx)(n.strong,{children:"instance method"})," is a method that's called on an object, not the class. Let's work through some examples of instance methods that we can call on strings. Try these out in the ",(0,a.jsx)(n.code,{children:"dotnet-script"})," REPL:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'> string phrase = "Programming is AWESOME";\n> phrase\n"Programming is AWESOME"\n> phrase.ToUpper()\n"PROGRAMMING IS AWESOME"\n> phrase.ToLower()\n"programming is awesome"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["First understand that ",(0,a.jsx)(n.code,{children:"phrase"})," is an object instance of the ",(0,a.jsx)(n.code,{children:"String"})," class. When we call a method on ",(0,a.jsx)(n.code,{children:"phrase"}),", we're calling an instance method on it."]}),"\n",(0,a.jsx)(n.p,{children:"The pattern for calling a C# method is similar to JavaScript:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["We append a ",(0,a.jsx)(n.code,{children:"."}),", or dot, to the end of our variable (or data we'd like to manipulate, if it's not stored in a variable)."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["We list the method name after the dot. In the first example above, we used the built-in method ",(0,a.jsx)(n.code,{children:"ToUpper"}),". In the second, we used ",(0,a.jsx)(n.code,{children:"ToLower"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Just like with JavaScript, we append a set of parentheses ",(0,a.jsx)(n.code,{children:"()"})," to the end of the method name. Often called ",(0,a.jsx)(n.strong,{children:"parens"})," for short, these are where any arguments go. Sometimes methods have arguments, and sometimes they don't. The examples above don't contain arguments."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["The method then ",(0,a.jsx)(n.em,{children:"does something"})," with or to the data it's called on. In this example, ",(0,a.jsx)(n.code,{children:"ToUpper()"})," makes our string all uppercase whereas ",(0,a.jsx)(n.code,{children:"ToLower()"})," makes it all lowercase."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"For clarity sake, keep in mind that you can call methods directly on the data. Take this for example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'> "Programming is AWESOME".ToUpper()\n"PROGRAMMING IS AWESOME"\n'})}),"\n",(0,a.jsx)(n.h3,{id:"method-naming-convention",children:"Method Naming Convention"}),"\n",(0,a.jsxs)(n.p,{children:["Notice that unlike JavaScript, ",(0,a.jsx)(n.strong,{children:"methods in C# begin with a capital letter"}),". The beginning of any other words in the method name are also capitalized such as ",(0,a.jsx)(n.code,{children:"LikeThis()"})," or ",(0,a.jsx)(n.code,{children:"EvenLikeThisExampleHere()"}),". This is called ",(0,a.jsx)(n.strong,{children:"Pascal case"})," or ",(0,a.jsx)(n.strong,{children:"upper camel case"})," and is a standard and required convention in C#."]}),"\n",(0,a.jsx)(n.h3,{id:"string-methods-with-arguments",children:"String Methods with Arguments"}),"\n",(0,a.jsx)(n.p,{children:"Let's look at a few more methods. This time we'll use some that take arguments:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'> string phraseOne = "hello world";\n> string phraseTwo = "hello";\n> phraseOne.Contains(phraseTwo)\ntrue\n'})}),"\n",(0,a.jsxs)(n.p,{children:["To review, ",(0,a.jsx)(n.strong,{children:"arguments"})," are pieces of data passed into a method. In the example above, ",(0,a.jsx)(n.code,{children:"Contains()"})," is a string method. We pass it the variable ",(0,a.jsx)(n.code,{children:"phraseTwo"})," as an argument. It then determines if ",(0,a.jsx)(n.code,{children:"phraseTwo"})," is included in ",(0,a.jsx)(n.code,{children:"phraseOne"}),", the variable that we call the method on. In this case, ",(0,a.jsx)(n.em,{children:"\u201chello world\u201d"})," contains the phrase, or ",(0,a.jsx)(n.strong,{children:"substring"}),", ",(0,a.jsx)(n.em,{children:'"hello"'}),", so it returns ",(0,a.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Similarly, we could use ",(0,a.jsx)(n.code,{children:"Replace()"})," to swap out part of a string:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'> string phraseOne = "hello world";\n> string phraseTwo = "hello";\n> string phraseThree = phraseOne.Replace("hello", "goodbye");\n> phraseThree\n"goodbye world"\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Replace()"})," takes two arguments. Both are strings. The method finds all substrings that match the first argument ",(0,a.jsx)(n.code,{children:'"hello"'})," and then replaces these substrings with the second argument ",(0,a.jsx)(n.code,{children:'"goodbye"'}),", turning the string ",(0,a.jsx)(n.em,{children:'"hello world"'})," into ",(0,a.jsx)(n.em,{children:'"goodbye world"'}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"strong-typing-in-arguments",children:"Strong Typing in Arguments"}),"\n",(0,a.jsxs)(n.p,{children:["Because ",(0,a.jsx)(n.strong,{children:"C# is a strongly-typed language"}),", when we pass an argument to a method, it ",(0,a.jsx)(n.em,{children:"must"})," be the correct type. For example, the ",(0,a.jsx)(n.code,{children:"Replace()"})," method ",(0,a.jsx)(n.strong,{children:"only"})," accepts string arguments. If we try to pass it an integer (or ",(0,a.jsx)(n.code,{children:"int"}),") instead, we get an error:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"> string phraseOne = \"hello world\";\n> int phraseTwo = 4;\n> phraseOne.Contains(phraseTwo)\n(1,20): error CS1503: Argument 1: cannot convert from 'int' to 'string'\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"1"})," is an integer of the ",(0,a.jsx)(n.code,{children:"int"})," data type, not a ",(0,a.jsx)(n.code,{children:"string"}),". Errors like this one are very common. Whenever we see a message stating something like ",(0,a.jsx)(n.em,{children:"Cannot convert (some data type) to (some other data type)"}),", it means we've provided an incorrect data type in our code. The second data type mentioned in the message (",(0,a.jsx)(n.code,{children:"string"})," in the example above) is the data type C# ",(0,a.jsx)(n.em,{children:"expected"}),"; the first (",(0,a.jsx)(n.code,{children:"int"}),") is the incorrect type we provided instead."]}),"\n",(0,a.jsxs)(n.p,{children:["If we ever need to find out what arguments may be provided to string methods, we can look at the ",(0,a.jsx)(n.a,{href:"https://msdn.microsoft.com/en-us/library/System.String_methods(v=vs.110).aspx",children:"C# String Documentation"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"integer-methods",children:"Integer Methods"}),"\n",(0,a.jsxs)(n.p,{children:["Integers also have built-in methods but there are not very many beyond the mathematical operators covered in the ",(0,a.jsx)(n.em,{children:"Integers, Decimals, and Arithmetic"})," lesson. Here's one that converts an integer to a string:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'> int number = 56;\n> number\n56\n> number.ToString()\n"56"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["We've turned an ",(0,a.jsx)(n.code,{children:"int"})," into a ",(0,a.jsx)(n.code,{children:"string"})," type instead. Now it can be used in methods that work with strings."]}),"\n",(0,a.jsx)(n.p,{children:"Next, we'll take a moment to learn about how .NET organizes its built-in classes into namespaces, and how we can check the type of an object we're working with to learn its class name and how to research more about it."})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);