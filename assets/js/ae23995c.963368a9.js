"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[74066],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var s=t(96540);const r={},o=s.createContext(r);function i(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:n},e.children)}},32874:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"c-and-net/test-driven-development-with-c/3-1-1-3--overloading-constructors-and-methods","title":"\ud83d\udcd3 3.1.1.3- Overloading Constructors and Methods","description":"Let\'s learn a technique that will allow us to make our class constructors and methods more flexible: overloads. As we usually do, let\'s start with an example.","source":"@site/docs/3_c-and-net/1_test-driven-development-with-c/3-1-1-03--overloading-constructors-and-methods.md","sourceDirName":"3_c-and-net/1_test-driven-development-with-c","slug":"/c-and-net/test-driven-development-with-c/3-1-1-3--overloading-constructors-and-methods","permalink":"/v1.2/c-and-net/test-driven-development-with-c/3-1-1-3--overloading-constructors-and-methods","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 3.1.1.3- Overloading Constructors and Methods","day":"monday","id":"3-1-1-3--overloading-constructors-and-methods","hide_table_of_contents":true},"sidebar":"c-and-net","previous":{"title":"\ud83d\udcd3 3.1.1.2- A Closer Look at Compiling and Executing C# Programs","permalink":"/v1.2/c-and-net/test-driven-development-with-c/3-1-1-2--a-closer-look-at-compiling-and-executing-c-programs"},"next":{"title":"\ud83d\udcd3 3.1.1.4- Try/Catch Blocks","permalink":"/v1.2/c-and-net/test-driven-development-with-c/3-1-1-4--trycatch-blocks"}}');var r=t(74848),o=t(28453);const i={title:"\ud83d\udcd3 3.1.1.3- Overloading Constructors and Methods",day:"monday",id:"3-1-1-3--overloading-constructors-and-methods",hide_table_of_contents:!0},a=void 0,l={},d=[{value:"Overloaded Constructors",id:"overloaded-constructors",level:2},{value:"Syntax to DRY Up Our Overloaded Constructor",id:"syntax-to-dry-up-our-overloaded-constructor",level:3},{value:"Overloaded Methods",id:"overloaded-methods",level:2},{value:"When to Use Overloads",id:"when-to-use-overloads",level:2},{value:"Look for Overloads in Documentation",id:"look-for-overloads-in-documentation",level:2}];function c(e){const n={a:"a",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",hr:"hr",img:"img",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Let's learn a technique that will allow us to make our class constructors and methods more flexible: ",(0,r.jsx)(n.strong,{children:"overloads"}),". As we usually do, let's start with an example."]}),"\n",(0,r.jsx)(n.h2,{id:"overloaded-constructors",children:"Overloaded Constructors"}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["Let's modify our Shape Tracker's ",(0,r.jsx)(n.code,{children:"Triangle"})," class to include a new auto-implemented ",(0,r.jsx)(n.code,{children:"Guess"})," property, so that users can submit a guess about what type of triangle they have, before they are told (by our ",(0,r.jsx)(n.code,{children:"Triangle.CheckType()"})," instance method):"]}),"\n",(0,r.jsx)(n.div,{className:"filename",children:"ShapeTracker/Models/Triangle.cs"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"using System.Collections.Generic;\n\nnamespace ShapeTracker.Models\n{\n  public class Triangle\n  {\n    private int _side1;\n    public int Side1\n    {\n      get { return _side1; }\n      set { _side1 = value; }\n    }\n    public int Side2 { get; set; }\n    private int _side3;\n    private static List<Triangle> _instances = new List<Triangle> {};\n    // New auto-implemented property below!\n    public string Guess { get; set; }\n\n    public Triangle(int length1, int length2, int length3)\n    {\n      _side1 = length1;\n      Side2 = length2;\n      _side3 = length3;\n      _instances.Add(this);\n    }\n\n    ... // other methods omitted for brevity\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Now we need to update each use of the ",(0,r.jsx)(n.code,{children:"Triangle()"})," constructor (in our tests and source code) to include an argument for the user's guess:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'Triangle newTriangle = new Triangle(3, 4, 5, "isosceles");\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Aside from the headache of having to update our code, what if we wanted making a guess to be optional? Well, we can use an ",(0,r.jsx)(n.strong,{children:"overloaded constructor"})," that gives us the flexibility to pass in different configurations of arguments. With an overloaded constructor, we could pass in values just for the triangle's sides, or values for the triangle's sides ",(0,r.jsx)(n.em,{children:"and"})," a guess."]}),"\n",(0,r.jsxs)(n.p,{children:["Here's how we would create an overloaded constructor for our ",(0,r.jsx)(n.code,{children:"Triangle"})," class:"]}),"\n",(0,r.jsx)(n.div,{className:"filename",children:"ShapeTracker/Models/Triangle.cs"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"using System.Collections.Generic;\n\nnamespace ShapeTracker.Models\n{\n  public class Triangle\n  {\n    private int _side1;\n    public int Side1\n    {\n      get { return _side1; }\n      set { _side1 = value; }\n    }\n    public int Side2 { get; set; }\n    private int _side3;\n    private static List<Triangle> _instances = new List<Triangle> {};\n    public string Guess { get; set; }\n\n    public Triangle(int length1, int length2, int length3)\n    {\n      _side1 = length1;\n      Side2 = length2;\n      _side3 = length3;\n      _instances.Add(this);\n    }\n\n    // New overloaded constructor below!!!\n    public Triangle(int length1, int length2, int length3, string userGuess)\n    {\n      _side1 = length1;\n      Side2 = length2;\n      _side3 = length3;\n      Guess = userGuess;\n      _instances.Add(this);\n    }\n\n    ... // other methods omitted for brevity\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"We've added a second constructor in the code above. The first constructor includes parameters for the three sides of a triangle, and the second constructor includes parameters for the three sides and a user's guess."}),"\n",(0,r.jsxs)(n.p,{children:["Now we can instantiate new ",(0,r.jsx)(n.code,{children:"Triangle"})," objects in two ways:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'Triangle newTriangle = new Triangle(15, 44, 9);\nTriangle newTriangle = new Triangle(3, 4, 5, "isosceles");\n'})}),"\n",(0,r.jsx)(n.h3,{id:"syntax-to-dry-up-our-overloaded-constructor",children:"Syntax to DRY Up Our Overloaded Constructor"}),"\n",(0,r.jsxs)(n.p,{children:["However, our constructors aren't very DRY. Multiple lines of code are repeated. We can refactor our code with special syntax and the ",(0,r.jsx)(n.code,{children:"this"})," keyword:"]}),"\n",(0,r.jsx)(n.div,{className:"filename",children:"ShapeTracker/Models/Triangle.cs"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"    ... // code omitted for brevity\n\n    public Triangle(int length1, int length2, int length3)\n    {\n      _side1 = length1;\n      Side2 = length2;\n      _side3 = length3;\n      _instances.Add(this);\n    }\n\n    public Triangle(int length1, int length2, int length3, string userGuess) : this(length1, length2, length3)\n    {\n      Guess = userGuess;\n    }\n\n    ... // code omitted for brevity\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Our first constructor looks the same while the second has new syntax. We add ",(0,r.jsx)(n.code,{children:": this(length1, length2, length3)"}),". ",(0,r.jsx)(n.code,{children:": this()"})," allows the second constructor to utilize everything that's in the first constructor, which means we don't need to repeat any code that's already in the first constructor. We have to pass in ",(0,r.jsx)(n.code,{children:"length1, length2, length3"})," because we are utilizing the first constructor and it expects the three ",(0,r.jsx)(n.code,{children:"length1, length2, length3"})," parameters. Then our second, overloaded constructor will take care of the rest."]}),"\n",(0,r.jsx)(n.h2,{id:"overloaded-methods",children:"Overloaded Methods"}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["We can also overload methods just like we can with constructors. Here's a simple example of creating an overload for a static ",(0,r.jsx)(n.code,{children:"Add()"})," method in a made up ",(0,r.jsx)(n.code,{children:"Calc"})," class:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public class Calc\n{\n  public static int Add(int a, int b)\n  {\n    return a + b;\n  }\n  public static int Add(int a, int b, int c)\n  {\n    return a + b + c;\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["With the first definition of the ",(0,r.jsx)(n.code,{children:"Add()"})," method, we only calculate the total of adding two numbers. In the second overloaded method, we calculate the total of adding three numbers."]}),"\n",(0,r.jsx)(n.p,{children:"Just like with constructors, we can use overloaded methods to greatly increase the flexibility of our code!"}),"\n",(0,r.jsx)(n.h2,{id:"when-to-use-overloads",children:"When to Use Overloads"}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["When we define two or more constructors or methods in a class, those constructors/methods that differ from the first constructor are called ",(0,r.jsx)(n.strong,{children:"overloads"}),". Let's look at three use cases for overloads using examples for constructors in the Shape Tracker console app:"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Order of parameters:"})," If we want to pass in a ",(0,r.jsx)(n.code,{children:"userGuess"})," first and then ",(0,r.jsx)(n.code,{children:"length1"}),", etc. afterwards, we could add an overloaded constructor that accounts for arguments being passed into the constructor in a different order."]}),"\n",(0,r.jsx)(n.div,{className:"filename",children:"ShapeTracker/Models/Triangle.cs"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"    ... // code omitted for brevity\n    public string Guess { get; set; }\n\n    public Triangle(int length1, int length2, int length3)\n    {\n      _side1 = length1;\n      Side2 = length2;\n      _side3 = length3;\n      _instances.Add(this);\n    }\n\n    public Triangle(string userGuess, int length1, int length2, int length3) : this(length1, length2, length3)\n    {\n      Guess = userGuess;\n    }\n\n    ... // code omitted for brevity\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Data type of parameters:"})," If we want to allow users to enter an open-ended guess, like entering the string ",(0,r.jsx)(n.code,{children:'"isosceles"'}),", or make a selection from a predefined list, like choosing the char ",(0,r.jsx)(n.code,{children:"'a'"})," or ",(0,r.jsx)(n.code,{children:"'b'"}),", we can add overloaded constructors to account for different type of data. Note that you will need separate properties/fields for each type of data you want to store."]}),"\n",(0,r.jsx)(n.div,{className:"filename",children:"ShapeTracker/Models/Triangle.cs"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"    ... // code omitted for brevity\n    public string OpenGuess { get; set; }\n    public char MultipleChoiceGuess { get; set; }\n\n    public Triangle(int length1, int length2, int length3)\n    {\n      _side1 = length1;\n      Side2 = length2;\n      _side3 = length3;\n      _instances.Add(this);\n    }\n\n    public Triangle(int length1, int length2, int length3, string userGuess) : this(length1, length2, length3)\n    {\n      OpenGuess = userGuess;\n    }\n    \n    public Triangle(int length1, int length2, int length3, char userGuess) : this(length1, length2, length3)\n    {\n      MultipleChoiceGuess = userGuess;\n    }\n\n    ... // code omitted for brevity\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Flexibility of parameters:"})," We can choose to have a different number of parameters (as seen in the example we use above) or even no parameters at all. To include no parameters, add an empty constructor like this:"]}),"\n",(0,r.jsx)(n.div,{className:"filename",children:"ShapeTracker/Models/Triangle.cs"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"    ... // code omitted for brevity\n\n    public Triangle(int length1, int length2, int length3)\n    {\n      _side1 = length1;\n      Side2 = length2;\n      _side3 = length3;\n      _instances.Add(this);\n    }\n\n    public Triangle() { }\n\n    ... // code omitted for brevity\n"})}),"\n",(0,r.jsx)(n.p,{children:"As we can see, overloaded constructors give us additional flexibility in our code. C# is strict about the number of parameters that can be passed into any method, including a constructor. However, in the real world, data can be messy and overloaded constructors can help us write resilient, reusable applications."}),"\n",(0,r.jsx)(n.h2,{id:"look-for-overloads-in-documentation",children:"Look for Overloads in Documentation"}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["Built-in C# and .NET classes and methods often use overloads. For example, if we look at the MS documentation for the static method ",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.console.writeline?view=net-6.0",children:(0,r.jsx)(n.code,{children:"Console.WriteLine()"})}),", we'll see that there are 18 overloaded constructors listed, which effectively means there are 18 different ways we can use this method!"]}),"\n",(0,r.jsxs)(n.p,{children:["As the image below shows, we can quickly get a sense of all overloads for ",(0,r.jsx)(n.code,{children:"Console.WriteLine()"}),' by looking at the "In this article" right-hand menu, or we can start scrolling on the main page to look through the "Overloads" section.']}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Documentation for Console.WriteLine() that shows multiple overloads for the method.",src:t(41895).A+"",width:"985",height:"630"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},41895:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/overloaded-methods-on-MS-docs-b002634accf3b667755b5da6a0fc6423.png"}}]);