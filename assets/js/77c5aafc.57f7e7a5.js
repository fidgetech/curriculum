"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[26022],{8933:(e,r,a)=>{a.r(r),a.d(r,{assets:()=>l,contentTitle:()=>i,default:()=>g,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=a(58168),t=(a(96540),a(15680));const o={title:"\ud83d\udcd3 1.3.0.7 Comparing and Cloning Arrays",day:"weekend",id:"1-3-0-7-comparing-and-cloning-arrays",hide_table_of_contents:!0},i=void 0,s={unversionedId:"introduction-to-programming/arrays-looping/1-3-0-7-comparing-and-cloning-arrays",id:"introduction-to-programming/arrays-looping/1-3-0-7-comparing-and-cloning-arrays",title:"\ud83d\udcd3 1.3.0.7 Comparing and Cloning Arrays",description:'Unlike other data types we\'ve seen so far, we can\'t compare two arrays by using the === comparison operator. In JavaScript, two primitive data type values can be equal. For example, "abc" is the same as any other "abc". But arrays are different \u2014 no two arrays are the same, even if they have the exact same elements inside.',source:"@site/docs/1_introduction-to-programming/3_arrays-looping/AG-1-3-0-7-comparing-and-cloning-arrays.md",sourceDirName:"1_introduction-to-programming/3_arrays-looping",slug:"/introduction-to-programming/arrays-looping/1-3-0-7-comparing-and-cloning-arrays",permalink:"/v1.2/introduction-to-programming/arrays-looping/1-3-0-7-comparing-and-cloning-arrays",draft:!1,tags:[],version:"current",frontMatter:{title:"\ud83d\udcd3 1.3.0.7 Comparing and Cloning Arrays",day:"weekend",id:"1-3-0-7-comparing-and-cloning-arrays",hide_table_of_contents:!0},sidebar:"introduction-to-programming",previous:{title:"\ud83d\udcd3 1.3.0.6 Array Methods",permalink:"/v1.2/introduction-to-programming/arrays-looping/1-3-0-6-array-methods"},next:{title:"\ud83d\udcd3 1.3.0.8 Document Query Methods that Return Collections",permalink:"/v1.2/introduction-to-programming/arrays-looping/1-3-0-8-document-query-methods-that-return-collections"}},l={},p=[{value:"Comparing Arrays",id:"comparing-arrays",level:2},{value:"Cloning Arrays",id:"cloning-arrays",level:2},{value:"Additional Resources",id:"additional-resources",level:3}],c={toc:p},y="wrapper";function g(e){let{components:r,...a}=e;return(0,t.yg)(y,(0,n.A)({},c,a,{components:r,mdxType:"MDXLayout"}),(0,t.yg)("p",null,"Unlike other data types we've seen so far, we can't compare two arrays by using the ",(0,t.yg)("inlineCode",{parentName:"p"},"==="),' comparison operator. In JavaScript, two primitive data type values can be equal. For example, "abc" is the same as any other "abc". But arrays are different \u2014 ',(0,t.yg)("strong",{parentName:"p"},"no two arrays are the same, even if they have the exact same elements inside"),"."),(0,t.yg)("h2",{id:"comparing-arrays"},"Comparing Arrays"),(0,t.yg)("hr",null),(0,t.yg)("p",null,"If you need to compare the ",(0,t.yg)("em",{parentName:"p"},"contents")," of two arrays, one way to accomplish this is to transform the arrays into strings using the ",(0,t.yg)("inlineCode",{parentName:"p"},"toString()")," method on each and comparing the return values. Be careful, though, because there are edge cases where this doesn't work correctly. An ",(0,t.yg)("strong",{parentName:"p"},"edge case")," in computer programming is a possible outcome of an operation that leads to unexpected or inconsistent results. Let's take a look at an example where we can effectively compare two arrays \u2014 and then let's tweak one of the arrays to make it a gotcha:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'> const a = [1,2,3];\n> const b = [1,2,3];\n> a === b;\nfalse\n> a.toString();\n"1,2,3"\n> a.toString() === b.toString();\ntrue\n')),(0,t.yg)("p",null,"Great! This works. But what if one of the arrays includes strings?"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},'> const c = [1,2,"3"];\n> const d = [1,2,3];\n> c === d;\nfalse\n> c.toString();\n"1,2,3"\n> d.toString();\n"1,2,3"\n> c.toString() === d.toString();\ntrue\n')),(0,t.yg)("p",null,"According to the rules of strict equality (",(0,t.yg)("inlineCode",{parentName:"p"},"==="),"), strings and numbers are different \u2014 as well they should be. That means that the string ",(0,t.yg)("inlineCode",{parentName:"p"},'"3"')," inside array ",(0,t.yg)("inlineCode",{parentName:"p"},"c")," should not be considered the same as the number ",(0,t.yg)("inlineCode",{parentName:"p"},"3")," inside array ",(0,t.yg)("inlineCode",{parentName:"p"},"d"),". However, the ",(0,t.yg)("inlineCode",{parentName:"p"},"Array.prototype.toString()")," method does not account for differing data types within each array: they are all turned into strings! So this is an example of when comparing the equality of two arrays by turning them into strings with ",(0,t.yg)("inlineCode",{parentName:"p"},"Array.prototype.toString()")," does not work effectively."),(0,t.yg)("p",null,"As with many things in computer programming, we've found a fairly effective solution that doesn't work all of the time. As a developer, a big part of your job is to find things that work \u2014 but also to understand the little ways and circumstances where things don't work."),(0,t.yg)("h2",{id:"cloning-arrays"},"Cloning Arrays"),(0,t.yg)("hr",null),(0,t.yg)("p",null,"Here is another scenario where arrays operate differently than we might expect."),(0,t.yg)("p",null,"Suppose we have an array that we want to keep in its original form. We also need to manipulate this array in some way. We might have one variable hold the original array and another variable with a copy of the same array that we can change."),(0,t.yg)("p",null,"Try this in the console:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},"> const originalArray = [1,2,3,4,5];\n> originalArray;\n[1, 2, 3, 4, 5]\n> let cloneArray = originalArray;\n> cloneArray;\n[1, 2, 3, 4, 5]\n> cloneArray.push(6);\n6\n> cloneArray;\n[1, 2, 3, 4, 5, 6]\n")),(0,t.yg)("p",null,"What does ",(0,t.yg)("inlineCode",{parentName:"p"},"originalArray")," look like now? We haven't touched it, so we may assume it would retain its original value of ",(0,t.yg)("inlineCode",{parentName:"p"},"[1,2,3,4,5]"),". But if we check it again in the console, we'll see the following:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},"> originalArray;\n[1, 2, 3, 4, 5, 6]\n")),(0,t.yg)("p",null,"In JavaScript, the array is stored in memory. The variables ",(0,t.yg)("inlineCode",{parentName:"p"},"originalArray")," and ",(0,t.yg)("inlineCode",{parentName:"p"},"cloneArray")," are called ",(0,t.yg)("strong",{parentName:"p"},"pointers"),". A pointer references an object in memory but is ",(0,t.yg)("em",{parentName:"p"},"not")," the object itself. Therefore, as the array is changed, the new value is reflected in all of the variables that point to it."),(0,t.yg)("p",null,"The way to clone an array ",(0,t.yg)("em",{parentName:"p"},"without")," simply making another pointer is to create a new variable set to a new array:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-javascript"},"const cloneArray = originalArray.slice();\n")),(0,t.yg)("p",null,"Note that we use the ",(0,t.yg)("inlineCode",{parentName:"p"},"Array.prototype.slice()"),' here in a slightly different way than we learned in the last lesson \u2014 without arguments. This just "slices" the whole array so we can save it in a new variable. This ensures that the new array really is an entirely separate entity instead of simply a pointer to the original array.'),(0,t.yg)("h3",{id:"additional-resources"},"Additional Resources"),(0,t.yg)("p",null,"For more details on how the ",(0,t.yg)("inlineCode",{parentName:"p"},"Array.prototype.slice()")," method works, check out ",(0,t.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice"},"MDN's JavaScript documentation"),"."))}g.isMDXComponent=!0},15680:(e,r,a)=>{a.d(r,{xA:()=>c,yg:()=>d});var n=a(96540);function t(e,r,a){return r in e?Object.defineProperty(e,r,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[r]=a,e}function o(e,r){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),a.push.apply(a,n)}return a}function i(e){for(var r=1;r<arguments.length;r++){var a=null!=arguments[r]?arguments[r]:{};r%2?o(Object(a),!0).forEach(function(r){t(e,r,a[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(a,r))})}return e}function s(e,r){if(null==e)return{};var a,n,t=function(e,r){if(null==e)return{};var a,n,t={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],r.indexOf(a)>=0||(t[a]=e[a]);return t}(e,r);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],r.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(t[a]=e[a])}return t}var l=n.createContext({}),p=function(e){var r=n.useContext(l),a=r;return e&&(a="function"==typeof e?e(r):i(i({},r),e)),a},c=function(e){var r=p(e.components);return n.createElement(l.Provider,{value:r},e.children)},y="mdxType",g={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},m=n.forwardRef(function(e,r){var a=e.components,t=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),y=p(a),m=t,d=y["".concat(l,".").concat(m)]||y[m]||g[m]||o;return a?n.createElement(d,i(i({ref:r},c),{},{components:a})):n.createElement(d,i({ref:r},c))});function d(e,r){var a=arguments,t=r&&r.mdxType;if("string"==typeof e||t){var o=a.length,i=new Array(o);i[0]=m;var s={};for(var l in r)hasOwnProperty.call(r,l)&&(s[l]=r[l]);s.originalType=e,s[y]="string"==typeof e?e:t,i[1]=s;for(var p=2;p<o;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"}}]);