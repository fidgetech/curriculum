"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[23141],{2136:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"intermediate-javascript/asynchrony-and-apis/2-3-1-5-static-methods-and-properties","title":"\ud83d\udcd3 2.3.1.5 Static Methods and Properties","description":"All of the custom methods we\'ve written up to this point have been instance methods. In this lesson, we\'ll learn how to write a static method which can be called directly on an object type. We\'ll also learn how to create static properties.","source":"@site/docs/2_intermediate-javascript/3_asynchrony-and-apis/2-3-1-05-static-methods-and-properties.md","sourceDirName":"2_intermediate-javascript/3_asynchrony-and-apis","slug":"/intermediate-javascript/asynchrony-and-apis/2-3-1-5-static-methods-and-properties","permalink":"/v1.2/intermediate-javascript/asynchrony-and-apis/2-3-1-5-static-methods-and-properties","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcd3 2.3.1.5 Static Methods and Properties","day":"monday","id":"2-3-1-5-static-methods-and-properties","hide_table_of_contents":true},"sidebar":"intermediate-javascript","previous":{"title":"\ud83d\udcd3 2.3.1.4 Promises with API Calls","permalink":"/v1.2/intermediate-javascript/asynchrony-and-apis/2-3-1-4-promises-with-api-calls"},"next":{"title":"\ud83d\udcd3 2.3.1.6 Separating Promise Logic","permalink":"/v1.2/intermediate-javascript/asynchrony-and-apis/2-3-1-6-separating-promise-logic"}}');var a=s(74848),o=s(28453);const r={title:"\ud83d\udcd3 2.3.1.5 Static Methods and Properties",day:"monday",id:"2-3-1-5-static-methods-and-properties",hide_table_of_contents:!0},i=void 0,c={},l=[{value:"Writing a Static Method",id:"writing-a-static-method",level:2},{value:"Static Properties",id:"static-properties",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h2:"h2",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["All of the custom methods we've written up to this point have been ",(0,a.jsx)(t.strong,{children:"instance methods"}),". In this lesson, we'll learn how to write a ",(0,a.jsx)(t.strong,{children:"static method"})," which can be called directly on an object type. We'll also learn how to create ",(0,a.jsx)(t.strong,{children:"static properties"}),"."]}),"\n",(0,a.jsx)(t.p,{children:'Before proceeding, keep in mind that "object type" and "class" are interchangeable terms in JavaScript. Also, in many languages "static methods" are also called "class methods". All that said, always keep in mind that JavaScript only uses classes as syntactic sugar, which sits on top of the original object-creation syntax, using object literals, constructor functions, and prototype methods.'}),"\n",(0,a.jsx)(t.p,{children:'We have already been introduced to the concepts of instance and static, both in lessons and via the instance and static methods we have implemented in our code, however we\'ll still review exactly what "instance" and "static" means, and work through some examples.'}),"\n",(0,a.jsx)(t.h2,{id:"writing-a-static-method",children:"Writing a Static Method"}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsxs)(t.p,{children:["We'll use a ",(0,a.jsx)(t.code,{children:"Car"})," class to demonstrate how to write a static method. Here is what is in our class:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'class Car {\n  constructor(make, model) {\n    this.make = make, \n    this.model = model\n  }\n\n  drive() {\n    return "Vvrrrooooom!"\n  }\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"First, let's take a look at an example of an instance method:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'const car = new Car("pontiac", "aztec");\ncar.drive();\n"Vvrrrooooom!"\n'})}),"\n",(0,a.jsxs)(t.p,{children:["We first have to create an instance of a ",(0,a.jsx)(t.code,{children:"Car"})," before we can drive it. Because the method is called on a single instance of a car (and not all cars), it is an ",(0,a.jsx)(t.strong,{children:"instance"})," method."]}),"\n",(0,a.jsxs)(t.p,{children:["A static method, on the other hand, is called on the class itself. What if we wanted to sort a factory full of cars by color? Well, we can't call that on one car. We need to call it on ",(0,a.jsx)(t.em,{children:"all"})," of the cars, which means we'd need a static method. We can define a static method in a class like this:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"class Car {\n  ...\n\n  static sort(color) {\n    // Code for method here.\n  }\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["As we can see, all we need to do is add the ",(0,a.jsx)(t.code,{children:"static"})," keyword."]}),"\n",(0,a.jsx)(t.p,{children:"Then, when we want to call the method, we can call it directly on the class:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'Car.sort("red");\n'})}),"\n",(0,a.jsx)(t.p,{children:"C#/.NET and Ruby/Rails students will learn a lot more about instance versus static/class methods in their backend courses."}),"\n",(0,a.jsxs)(t.p,{children:["But what do static methods have to do with the code we are writing to make API calls? Well, it would be nice to encapsulate our API logic in its own ES6 class. ",(0,a.jsx)(t.strong,{children:"Encapsulation"})," is the process of storing information inside a class to keep it separate from other logic in our application. It helps us keep our code more modular and organized. That means we can make our code better by creating a class to hold our API logic."]}),"\n",(0,a.jsx)(t.p,{children:"However, it doesn't make much sense to have an instance of the class before we make our API call. It's not just extra code \u2014 there's just no need to create an instance instead of just calling our method on the class itself. This will become apparent when we refactor our code in the next lesson."}),"\n",(0,a.jsxs)(t.p,{children:["By the way, you've already worked with static methods, even if you haven't realized it. For instance, whenever you call a",(0,a.jsx)(t.code,{children:"Math"})," class method, you are using a static method. In fact, the code we used to generate a random number a few lessons ago uses two static methods: ",(0,a.jsx)(t.code,{children:"Math.random()"})," and ",(0,a.jsx)(t.code,{children:"Math.floor()"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"Math.floor(Math.random() * Math.floor(2));\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Also, the code we use to parse an API's response is a static method of the ",(0,a.jsx)(t.code,{children:"JSON"})," object type."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"JSON.parse(apiResponse);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["We also briefly discussed the ",(0,a.jsx)(t.code,{children:"Promise.all()"})," method a few lessons ago \u2014 this is also a static method. A key thing to note about documentation regarding static methods is that they don't use the ",(0,a.jsx)(t.code,{children:"prototype"})," keyword so it would be incorrect to say ",(0,a.jsx)(t.code,{children:"Promise.prototype.all()"}),". Static methods aren't automatically inherited, unlike prototypal methods. (However, we can use ",(0,a.jsxs)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/extends",children:["the ",(0,a.jsx)(t.code,{children:"extends"})," keyword"]})," to ensure that static methods are inherited but that's beyond the scope of this lesson.)"]}),"\n",(0,a.jsx)(t.h2,{id:"static-properties",children:"Static Properties"}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.p,{children:"We can also have static properties as well. That just means that we attach properties to the class itself, not an instance of the class. For instance, we could do something like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'Car.colors = ["red", "green", "blue"];\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The class itself now has a ",(0,a.jsx)(t.code,{children:"colors"})," property with a list of all the colors a car might be."]}),"\n",(0,a.jsxs)(t.p,{children:["If we wanted to declare the ",(0,a.jsx)(t.code,{children:"colors"})," property in our class, we'd also use the ",(0,a.jsx)(t.code,{children:"static"})," keyword:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'class Car {\n  constructor(make, model) {\n    this.make = make, \n    this.model = model\n  }\n\n  static colors = ["red", "green", "blue"];\n\n  drive() {\n    return "Vvrrrooooom!"\n  }\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["You probably won't need to use ",(0,a.jsx)(t.strong,{children:"static properties"})," in any of your projects (and they aren't required for any independent projects), but it's still good to know they exist. You will, however, be required to use a ",(0,a.jsx)(t.strong,{children:"static method"})," for this section's independent project."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>i});var n=s(96540);const a={},o=n.createContext(a);function r(e){const t=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);